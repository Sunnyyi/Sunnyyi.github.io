[{"title":"Codeup和PAT刷题记录——算法初步","date":"2020-05-20T08:45:22.000Z","path":"2020/05/20/算法笔记/算法初步/","text":"记录刷题过程中遇到的问题和技巧。 一、技巧总结1.排序1.1 简单选择排序总共进行n趟操作，每趟选出A[i，n]中最小的元素与A[i]交换。 123456789101112void selectSort()&#123; for(int i=1;i&lt;=n;i++)&#123; int k=i; for(int j=i;j&lt;=n;j++)&#123; if(A[j]&lt;A[k]) k=j; &#125; int temp=A[i]; A[i]=A[k]; A[k]=temp; &#125;&#125; 1.2 直接插入排序总共进行n-1趟，每趟将A[i]插入A[i-1,1]中合适位置。 12345678910void insertSort()&#123; for(int i=2;i&lt;=n;i++)&#123; int temp=A[i]; for(int j=i;j&gt;1;j--)&#123; if(temp&lt;A[j]) A[j]=A[j-1]; &#125; A[j]=temp; &#125;&#125; 1.3 C++标准模板库中的sort()由于c语言中的qsort函数涉及很多指针操作，且std中的sort()在实现中规避了经典快速排序中可能出现的导致实际时间复杂度退化到O(n2)的极端情况。使用C++头文件需要添加std的命名空间： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数cmp(非必填，默认递增排序)) //注意序列中的元素一定要有可比性才可以不写cmp函数，否则需指定cmp比较规则，例如结构体。//基本数据类型数组的排序 int double ...int A[6]=&#123;&#125;;bool cmp(int a, int b) &#123;return a&gt;b;&#125;sort(A,A+4,cmp); //将A[0]-A[3]从大到小排序//结构体的排序struct Node&#123; int x,y; char name[10];&#125;ssd[10];bool cmp(node a, node b)&#123; //若x不等，按x从大到小排序，否则按y从小到大排序。 if(a.x!=b.x) return a.x&gt;b.x; else return a.y &lt; b.y&#125;strcmp(a.name,b.name)&lt;0; //表示a.name字典序小于b.name的字典序。&lt;font color=Crmison&gt;注意！strcmp返回值不一定是-1或+1,故==-1写法错误。&lt;/font&gt;sort(ssd,ssd+3,cmp);//容器的排序vector&lt;int&gt; vi;vi.push_back(3);....//初始化bool cmp(int a, int b) &#123;return a&gt;b;&#125; //vector中类型为int型sort(vi.begin,vi.end,cmp);string str[3]=&#123;\"bbbb\",\"cc\",\"aaa\"&#125;;str[0]&gt;str[1]; //true,c++中string之间可直接比较大小。bool cmp(string str1,string str2)&#123;return str1.length &lt; str2.length;&#125; //按字符串长度递增排序sort(str,str+3);sort(str,str+3,cmp); 1.4 排名的实现分数不同排名不同，分数相同排名相同但占用一个排位：先排序：思路1：将排名这一项添加到结构体中进行记录，若当前个体分数等于上一个个体则排名等于上一个个体排名，否则当前个体排名等于数组下标+1。思路2：不记录进结构体，直接输出排名。 2. 散列2.1 散列的定义有些算法题消耗时间很长，需要利用空间换时间的策略，如将输入的数字作为数组下标来统计这个数出现的次数，而输入的数不一定为整数，且有可能出现冲突，即输入多个相同的数，这时就需要用到散列的策略。定义：将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素。可使用C++标准模板库中的map或reordered_mp直接使用整数hash的功能。散列常应用在查找某个字符串或数字是否出现或出现的次数。 2.2 整数散列其中直接定址法、平方取中法、除留余数法为散列方法；线性探查法(开放定址法)、平方探查法(开放定址法)、链地址法(拉链法)为解决冲突的方法。 2.2.1 直接定址法H(key)=keyH(key)=a*key+b 2.2.2 平方取中法取key的平方的中间若干位作为hash值，很少用。 2.2.3 除留余数法为最常用方法。H(key)=key%mod该方法可将一个较大的数变为可行的数组下标。表长TSize必须不小于mod，否则越界，一般取TSize=mod，且mod取素数可有效避免冲突。 2.2.4 线性探查法若H(key)位置被占用，则检查H(key)+1，H(key)+2,…，直到找到一个没被占用的位置，若超过了表长则回到表的首位继续循环查找。此方法容易出现扎堆现象，即表中连续若干个位置都被使用，一定程度上会降低效率。 2.2.5 平方探查法 该方法可避免扎堆现象。 若H(key)位置被占用，则检查H(key)+12，H(key)-12,H(key)+22,H(key)-22…，直到找到一个没被占用的位置，也可只进行正向平方探查。 若超过了表长则计算(H(key)+k2)%mod。 若H(key)-k2&lt;0,则计算((H(key)-k2)%TSize+TSize)%TSize;相当于将H(key)-k2不断加上TSize直到出现第一个非负数。 可证明，若k在[0，TSize)范围内都无法找到位置，那么当k&gt;=TSize时也一定无法找到位置。 2.2.6 链地址法（拉链法）设定一个数组链表，Link[0]-Link[mod-1],用Link[h]将所有H(key)=h的key链接起来。注意！以上方法一般都无需自己实现，除非必须模拟这些算法或提升效率，否则都可以直接使用标准模板库中的map函数来直接使用hash功能，C++11以后可以用unordered_map，速度更快。 2.3 字符串hash初步利用其它进制转换为10进制的策略，仅限字符串长度不是很长的情况。 若字符串均由大写字母构成：将26个大写字母视为26进制，转换为10进制。 若出现了小写字母，则将A-Z作为0—25,将a-z作为26-51(例如a-‘a’+26)，共52进制，转换为10进制。 若出现了数字，则可按照小写字母的处理方法增大进制数至62。 若能保证字符串末尾是数字则可将末尾的数字直接拼接上去。 ASCII码的hash值可用 字符-‘\\0’ 计算，因为’\\0’的ASCII码值为0。 3. 递归3.1 分治分治法三个步骤： 分解：将原问题分解为若干与原问题拥有相同或相似结构的子问题。子问题应当互相独立、没有交叉，否则不能使用分治法。 解决：递归求解所有子问题。 合并：将子问题的解合并为原问题的解。当子问题个数为1时，称为减治，如求n!,大于1则称为分治，如求Fibonacci数列。分治法既可以用递归手段也可用非递归手段去实现。 3.2 递归递归很适合用来实现分治思想。 3.2.1 递归的三要素出自https://www.zhihu.com/question/31412436/answer/683820765?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=697560822683041792&amp;utm_content=sec的讲解 明确函数想要做的事情(函数功能)。 寻找递归结束条件，避免程序一直调用自己，进入无底洞(递归边界)。需要找出当参数为什么时，递归结束，即能直接知道函数的结果，结束后需要返回或输出结果。 找出函数的等价关系式(递归式、递归调用)。最难也是最关键的一步。需要不断缩小参数的范围，且缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。这些条件一旦漏掉可能会导致死循环。 3.2.2 求n! 第一步，明确函数的功能1234//求n的阶乘int f(int n)&#123;&#125; 第二步，寻找递归结束条件123456//由于0！=1，不妨将f(0)=1作为递归边界int f(int n)&#123; if(n==0)&#123; return 1; &#125;&#125; 第三步，找出函数的等价关系式1234567//f(n)这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1)*n。int f(int n)&#123; if(n==0)&#123; return 1; &#125; else return f(n-1)*n;&#125; 3.2.3 求Fibonacci数列的第n项 第一步，明确函数的功能1234//求Fibonacci的第n项，1、1、2、3、5、8、13、21、34....int f(int n)&#123;&#125; 第二步，寻找递归结束条件123456//显然f(1)=f(2)=1,故可设置递归边界为n&lt;=2。int f(int n)&#123; if(n&lt;=2)&#123; return 1; &#125;&#125; 第三步，找出函数的等价关系式1234567//观察数列可轻易得到等价关系为f(n)=f(n-1)+f(n-2),int f(int n)&#123; if(n&lt;=2)&#123; return 1; &#125; return f(n-1) + f(n-2);&#125; 3.2.3 小青蛙跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 第一步，明确函数的功能1234//求青蛙跳上一个n级的台阶总共有多少种跳法int f(int n)&#123;&#125; 第二步，寻找递归结束条件123456//直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少。显然f(n)=1int f(int n)&#123; if(n&lt;=2)&#123; return n; &#125;&#125; 第三步，找出函数的等价关系式12345678910//每次跳的时候，小青蛙有两种跳法。即跳一个台阶或跳两个台阶。//第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。//第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。//所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。int f(int n)&#123; if(n&lt;=2)&#123; return n; &#125; ruturn f(n-1) + f(n-2);&#125; 3.2.4 反转单链表例如链表为：1-&gt;2-&gt;3-&gt;4。反转后为 4-&gt;3-&gt;2-&gt;1链表节点定义如下：1234class Node&#123; int date; Node next;&#125; 第一步，明确函数的功能1234//反转单链表，其中 head 表示链表的头节点。Node reverseList(Node head)&#123;&#125; 第二步，寻找递归结束条件123456//直接把链表压缩到只有一个节点和空表分析，若为空表或只有头节点存在则直接返回head节点。int reverseList(int n)&#123; if(head == null || head.next == null)&#123; return head; &#125;&#125; 第三步，找出函数的等价关系式 首先缩小范围分析，对2-&gt;3-&gt;4反转得到4-&gt;3-&gt;2并将递归的结果用一个新节点newList保存起来。1 这个节点我们并没有去碰它，所以1的 next 节点仍然是连接着2。 接下来只需要把节点 2 的 next 指向 1，然后把 1 的 next 指向 null即完成了反转。1234567891011121314151617int reverseList(int n)&#123; // 1.递归结束条件 if (head == null || head.next == null) &#123; return head; &#125; // 递归反转 子链表 Node newList = reverseList2(head.next); // 改变 1，2节点的指向。 // 通过 head.next获取节点2 Node t1 = head.next; // 让 2 的 next 指向 2 t1.next = head; // 1 的 next 指向 null. head.next = null; // 把调整之后的链表返回。 return newList;&#125; 3.2.5 递增输出n个数的全排列 第一步，明确函数的功能12345678//按从小到大输出1-n的全排列，即为每一位填入一个从1-n枚举的不重复的数字//P为当前排列，hashTable记录整数x是否已经在当前排列中，即P中const int maxn=11;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123;&#125; 第二步，寻找递归结束条件1234567891011//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列const int maxn=11;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; for(int i=1;i&lt;=n;i++) ptintf(\"%d\",P[i]); printf(\"\\n\"); return; &#125;&#125; 第三步，找出函数的等价关系式 首先处理index节点，枚举1-n，将第一个还未填入P中的值x填入P[index]中，并记录hashTable[x]=true。 接下来只需要处理下一个位置，即generateP(index+1); 当处理完p[index]=x的子问题后，还原hashTable[x]=false;123456789101112131415161718192021//输出从1-n的全排列，从index开始填const int maxn=11;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; for(int i=1;i&lt;=n;i++) ptintf(\"%d\",P[i]); printf(\"\\n\"); return; &#125; //枚举1-n，将x填入P[index]位置。 for(int x=index;x&lt;=n;x++)&#123; if(hashTable[x]==false)&#123; P[index]=x; hashTable[x]=true; generateP(index+1); hashTable[x]=false; &#125; &#125; &#125; 3.2.6 n皇后问题 第一步，明确函数的功能12345678//在一个n*n棋盘上放置n个皇后使其两两均不在同一行、同一列、同一条对角线上，求合法方案数。//考虑每行和没每列均只能放置一个皇后，问题归结为求全排列中的合法放置方案数，即求全排列中两两不在同一对角线的方案并统计。int count = 0;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123;&#125; 第二步，寻找递归结束条件1234567891011121314//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列//判断当前方案是否合法有两种方式，暴力法和回溯法//暴力法：在每一次递归边界遍历任两个皇后，判断是否在同一条对角线//回溯法：每次处理第index位时，遍历之前的皇后检查是否有冲突，若有冲突，则无需继续处理之后的位置，直接返回上一层即可。//回溯法比暴力法效率要高。int count = 0;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; //能到达递归边界的方案一定是合法方案 count++; return; &#125;&#125; 第三步，找出函数的等价关系式12345678910111213141516171819202122232425262728int count = 0;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; //能到达递归边界的方案一定是合法方案 count++; return; &#125; //枚举1-n，将x填入P[index]位置。 for(int x=1;x&lt;=n;x++)&#123; if(hashTable[x]==false)&#123; bool flag = true; //true表示不会冲突 for(int pre=1;pre&lt;index;pre++)&#123; // if(abs(index-pre)==abs(x-P[pre]))&#123; flag=false; break; &#125; &#125; if(flag)&#123; P[index]=x; hashTable[x]=true; generateP(index+1); hashTable[x]=false; &#125; &#125; &#125; &#125; 3.2.7 递归的优化 记录重复计算的子问题递归有时候是会产生大量重复计算的，例如求Fibonacci的第n项，例如f(5)=f(4)+f(3)，而f(4)会重复计算f(3)，优化时可保存下来已经被计算过的子问题即arr[n]=f(n),若未计算过，则置arr[n]=-1。在递归时判断一下是否计算过，若计算过则直接取出结果即可，否则再进行递归计算。 1234567891011121314int f(int n)&#123; if(n &lt;= 2)&#123; return n; &#125; //先判断有没计算过 if(arr[n] != -1)&#123; //计算过，直接返回 return arr[n]; &#125;else&#123; // 没有计算过，递归计算,并且把结果保存到 arr数组里 arr[n] = f(n-1) + f(n-2); return arr[n]; &#125;&#125; 考虑是否可以递推实现递归往往都是自上往下递归的，直到递归到最底，再一层一层把值返回。但是当n比较大的时候栈空间可能会不够。这时候可以考虑自底向上的做法，这种做法被称为递推。例如Fibonacci数列的例子。 1234567891011121314public int f(int n) &#123; if(n &lt;= 2) return n; int f1 = 1; int f2 = 2; int sum = 0; for (int i = 3; i &lt;= n; i++) &#123; sum = f1 + f2; f1 = f2; f2 = sum; &#125; return sum; &#125; 4. 贪心4.1 简单贪心总是考虑当前状态下局部最优解，来使全局的结果达到最优。 4.2 开区间不相交问题题目描述给出n个开区间(x,y)，计算最多可以选择多少个区间，使得这些开区间两两没有交集。输入输入第一行为n表示n个开区间，第二行n个开区间对(x,y)。输出输出1行为方案个数。样例输入42 4 1 3 3 5 6 7样例输出3思路 按左端点从大到小排序，若左端点相同则按右端点从小到大排序 lastX记录上一个被选区间的左端点。 若当前区间的右端点在上一个区间左端点的左边(&lt;=)则方案数+1 4.3 闭区间选点问题题目描述给出n个闭区间[x,y]，计算最少需要确定多少个点，使得这些闭区中都至少存在一个点。输入输入第一行为n表示n个开区间，第二行n个闭区间对[x,y]。输出输出1行为方案个数。样例输入31 4 2 6 5 7样例输出2思路 按左端点从大到小排序，若左端点相同则按右端点从小到大排序 lastX记录上一个被选区间的左端点。 若当前区间的右端点在上一个区间左端点的左边(&lt;)则方案数+1 二、经典题目2.1 问题 B: 分组统计题目描述先输入一组数，然后输入其分组，按照分组统计出现次数并输出，参见样例。输入输入第一行表示样例数m，对于每个样例，第一行为数的个数n，接下来两行分别有n个数，第一行有n个数，第二行的n个数分别对应上一行每个数的分组，n不超过100。输出输出m行，格式参见样例，按从小到大排。样例输入173 2 3 8 8 2 31 2 3 2 1 3 1样例输出1={2=0,3=2,8=1}2={2=1,3=0,8=1}3={2=1,3=1,8=0}思路 利用一个二维矩阵A[i][j]记录数字j在组别i中出现的次数 flagS[j]和flagG[i]分别记录数字j和组别i是否出现，这里容易出错 找出最大组别编号和最大数字，若组号i和数字j均存在，则输出result[i][j] 易错点:组号i小于n，但样例数大小j范围未知，二维数组的第二维应初始化大一些，否则容易错误50%12345678910111213141516171819202122232425262728293031323334353637383940414243int main()&#123; int m,n; while(scanf(\"%d\",&amp;m)!=EOF)&#123; while(m--)&#123; scanf(\"%d\",&amp;n); //在循环内部定义数组就无须初始化为0了 int sample[110]=&#123;&#125;,flagS[2010]=&#123;&#125;,group[110]=&#123;&#125;,flagG[110]=&#123;&#125;; int maxs=0,maxg=0; //找出最大样例和最大组别，方便输出。 for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",sample+i); if(sample[i]&gt;maxs) maxs=sample[i]; flagS[sample[i]]=1; &#125; int result[110][2010]=&#123;&#125;; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",group+i); if(group[i]&gt;maxg) maxg=group[i]; flagG[group[i]]=1; //记录统计结果 result[group[i]][sample[i]]++; &#125; //输出统计结果 for(int i=0;i&lt;=maxg;i++)&#123; if(flagG[i]==1)&#123; printf(\"%d=&#123;\",i); for(int j=0;j&lt;=maxs;j++)&#123; if(flagS[j]==1)&#123; printf(\"%d=%d\",j,result[i][j]); if(j&lt;maxs) printf(\",\"); &#125; &#125; printf(\"&#125;\\n\"); &#125; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"}]},{"title":"Java中的继承","date":"2020-05-01T05:55:39.000Z","path":"2020/05/01/Java基础知识/Java中的继承/","text":"一、类、超类和子类1. 定义子类已存在的类称为超类、基类或父类; 新类称为子类、派生类或孩子类。在设计类时，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中。 12345678910111213141516171819202122232425262728293031323334353637public class Manager extends Employee //在 Java 中， 所有的继承都是公有继承&#123; //定义子类特有数据域 private double bonus; //定义子类特有方法 public void setBonus(double bonus) &#123; //属于 Employee 类的对象不能使用该方法，但Manager 类自动地继承了超类 Employee 中的方法。 this.bonus = bonus; &#125; //覆盖超类方法 public double getSalary() &#123; double baseSalary = super.getSalary(); //子类不能直接访问超类的私有域，应通过关键字super调用超类的域访问器来访问。 return baseSalary + bonus; &#125; public Manager(String name, double salary, int year, int month, int day) &#123; //如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。 //如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器， 则 Java 编译器将报告错误。 //调用构造器的语句只能作为另一个构造器的第一条语句出现。 super(name, salary, year, month, day); //通过 super调用超类构造器实现对超类私有域进行初始化 bonus = 0; &#125;&#125;Manager boss = new Manager(\"Carl Cracker\" , 80000，1987, 12 , 15);boss.setBonus(5000);Employee[] staff = new Employee[3];staff[0] = boss; //变量 staff[0] 与 boss 引用同一个对象。但编译器将 staff[0]看成 Employee 对象。故staff[0]不能调用子类特有方法setBonus()staff[1] = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);staff[2] = new Employee(\"Tony Tester\" , 40000, 1990, 3, 15);for(Employee e : staff) //e 既可以引用 Employee 类型的对象，也可以引用 Manager 类型的对象。 System.out.println(e.getName() + \" \" + e.getSalary()); //虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。 super关键字与this引用不同，它不是一个对象引用，它只是一个指示编译器调用超类方法的特殊关键字。 在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。 在覆盖方法时， 一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。称该方法具有可协变的返回类型 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。 多态：一个对象变量可以指示多种实际类型的现象被称为多态。动态绑定：在运行时能够自动地选择调用哪个方法的现象称为动态绑定。静态绑定：如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定。 2. 继承层次继承层次：由一个公共超类派生出来的所有类的集合被称为继承层次。继承链：从某个特定的类到其祖先的路径被称为该类的继承链。Java 不支持多继承。 3. 多态 即超类变量既可以引用一个超类对象， 也可以引用一个超类的任何一个子类的对象。 不能将一个超类的引用赋给子类变量。 1234567//在 Java 中，子类数组的引用可以转换成超类数组的引用， 而不需要采用强制类型转换。Manager[] managers = new Manager[10];EmployeeQ staff = managers; // OK//所有数组都要牢记创建它们的元素类型， 并负责监督仅将类型兼容的引用存储到数组中。//这里使用 new managers[10] 创建的数组是一个经理数组。如果试图存储一个 Employee 类型的引用就会引发 ArrayStoreException 异常。staff[0] = new Employee(\"Harry Hacker\", . . .); //ArrayStoreException 异常 4. 理解方法调用x.f(param)调用过程： 编译器査看对象的声明类型和方法名。编译器将会一一列举所有x所声明类中名为f的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）。 编译器进行重载解析。以获得需要调用的方法名字和参数类型。 编译器采用静态绑定或动态绑定方式生成一条调用f(param)的指令。 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。若没有则在其超类中寻找。 虚拟机预先为每个类创建了一个方法表, 其中列出了所有方法(包括继承的方法)的签名和实际调用的方法。这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。 5. 阻止继承：final 类和方法不允许扩展的类被称为 final 类。 1234567//如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。public final class Executive extends Manager&#123; public final String getName()&#123; //final方法不能被覆盖 return name; &#125;&#125; 6. 强制类型转换将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检査。但是只有引用子类变量的超类引用可以被强制类型转换为子类引用。一般只有在会使用到 Manager 中特有的方法时才需要进行类型转换。 1234567891011//只能在继承层次内进行类型转换。 //在将超类转换成子类之前，应该使用instanceof进行检查。Manager boss = (Manager)staff[0]; //okManager boss = (Manager)staff[1]; // Error //若未捕获ClassCastException 异常，程序就会终止执行。if(staff[1] instanceof Manager) &#123; boss = (Manager)staff[1];&#125;x instanceof C //若x为null则不会产生异常只是返回false。 7. 抽象类抽象类一般作为派生其他类的基类，而不作为想使用的特定的实例类。通常它只包含一些通用的属性和方法，而这些通用方法往往只是一个定义不需要具体的实现。 123456789101112131415161718192021//利用abstract关键字修饰方法就无需实现该方法//包含一个或多个抽象方法的类本身必须被声明为抽象的。//抽象类的子类也可以为抽象类//类即使不含抽象方法，也可以将类声明为抽象类。public abstract class Person&#123; private String name; public Person(String name)&#123; this.name = name; &#125; public abstract String getDescription(); public String getName()&#123; return name; &#125;&#125;//抽象类不能被实例化。可以定义一个抽象类的对象变量，但是不能构造抽象类对象，它只能引用非抽象子类的对象。Person p = new Student(\"Vinee Vu\" , \"Economics\"); 8. 受保护访问 由于类中的私有域对所有其他类包括子类都是不可见的，因此若子类的方法想访问超类的某个域或方法，可将超类中的方法或域声明为protected。 不过子类中的方法只能够访问子类对象中继承的超类的受保护域，而不能访问超类对象中的这个域，如此可避免滥用受保护机制。 在实际应用中，要谨慎使用 protected 属性。因为有可能会违背OOP提倡的数据封装原则。 受保护的方法更具有实际意义。它对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。 9. 控制可见性的4个访问修饰符private:仅对本类可见。public:对所有类可见。protected:对本包和所有子类可见。默认：对本包可见。其中只有public和默认可用于修饰类。 二、Object是所有类的超类 可以使用 Object 类型的变量引用任何类型的对象。 在 Java 中，只有基本类型不是对象。 所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。 123456Object obj = new Employee(\"Harry Hacker\", 35000);Employee e = (Employee)obj ;Employee[] staff = new Employee[10];obj = staff; // OKobj = new int[10]; // OK 1. equals方法是基类Object中的一个可覆盖方法，在基类中，该方法与==运算符等价，比较的都是对象的内存地址， 可在子类中覆盖改写该方法。 1234567891011121314151617181920212223242526272829public class Employee&#123; //equals方法改写原则 public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; //若引用同一个对象则返回true,实际是比较两个对象的默认hashcode是否相等 if (otherObject == null) return false; //若显示参数为null则返回false //比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测。 //如果所有的子类都拥有统一的语义，就使用 instanceof 检测。 //if (!(otherObject instanceof ClassName)) return false; if (getClass() != otherObject.getClass()) return false; //若两个对象所属的类不同则返回false，getClass 方法将返回一个对象所属的类 //比较两个相同类的不为null的对象的数据域是否相等 Employee other = (Employee)otherObject; //如果两个参数都为 null， Objects.equals(a，b) 调用将返回 true; 如果其中一个参数为 null ,则返回 false ; 否则， 如果两个参数都不为 null，则调用 a.equals(b) // //使用 =比较基本类型域，使用 equals 比较对象域。 return Objects.equals(name,other.name) &amp;&amp; salary == other.salary &amp;&amp; Object.equals(hireDay,other.hireDay);&#125;public class Manager extends Employee&#123; public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; //在子类中定义 equals 方法时，首先调用超类的 equals,若检测失败对象就不可能相等。 Manager other = (Manager)otherObject; return bonus == other.bonus; &#125; &#125; 2. 相等测试与继承设计equals方法的原则：自反性：对于任何非空引用 x, x.equals(x) 应该返回 true。对称性：对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true , x.equals(y) 也应该返回 true。传递性：对于任何引用 x、y 和 z, 如果 x.equals(y) 返回 true， y.equals(z) 返回 true, x.equals(z) 也应该返回 true。一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。对于任意非空引用 x, x.equals(null) 应该返回 false。 12static boolean equals(type[]a , type[] b) //如果两个数组长度相同， 并且在对应的位置上数据元素也均相同static boolean equals(Object a, Object b) //如果a和b都为null，返回true;如果只有其中之一为 null，则返回false;否则返回a.equals(b)。 3. hashCode方法由于 hashCode方法定义在 Object 类中， 因此每个对象都有一个默认的散列码，其值为对象的存储地址。 12345678910111213141516171819//String的散列码是由内容导出的int hash = 0;for (int i = 0; i &lt; length0；i++) hash = 31 * hash + charAt(i);//StringBuilder 类中没有定义hashCode 方法//在重写hashcode方法时可以调用 Objects.hash并提供多个参数，这个方法会对各个参数调用 Objects.hashCode，并组合这些散列值。public int hashCode()&#123; return Objects,hash(name, salary, hireDay); &#125;static int hash(Object . .. objects) //返回一个散列码，由提供的所有对象的散列码组合而得到。static int hashCode(Object a ) //如果 a 为 null 返回 0， 否则返回 a.hashCode()static int hashCode((int11ong|short|byte|double|f1oat|char|boolean) value) //返回给定值的散列码。static int hashCode(type[] a ) //计算数组 a 的散列码。这个散列码由数组元素的散列码组合得到。 java规定如果重新定义 equals方法，就必须重新定义 hashCode 方法。因为Hashcode是用于散列数据的快速存取的，如利用 HashSet/HashMap/HashTable类来存储数据时，都是根据存储对象的hashcode值来判断是否相同。如果我们对一个对象重写了 equals方法，意思是只要对象的成员变量的值相等那么equals就返回true，但不重写hashcode方法，那么我们再new一个新的对象的时候，当原对象.equals(新对象)等于true的时候，两者的hashcode值是不相等的。由此产生了理解上的不一致，比如在存储散列集合（如Set类）的时候，将会存储了两个一样的对象，导致混淆，因此，也就必须重写hashcode方法,且Equals与hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( )就必须与 y.hashCode( ) 具有相同的值。 4. toString方法Object 类定义了 toString 方法， 用来打印输出对象所属的类名和散列码即类名@散列码。toString方法是一种非常有用的调试工具。在标准类库中，许多类都定义了 toString方 法， 以便用户能够获得一些有关对象状态的必要信息。因此java建议为自定义的每一个类增加 toString 方法。 12345678910111213141516171819202122232425262728293031323334System.out.println(System.out); //因为 PrintStream 类的设计者没有覆盖 toString方法故得到java.io.PrintStream@2f6684的结果。public String toString()&#123; return getClass().getName() //getClaSS( ).getName( ) 获得类名的字符串 + \"[name=\" + name + \",salary=\" + salary + \",hireDay=\" + hireDay + \"]\"; &#125;public class Manager extends Employee&#123; public String toString() &#123; return super.toString() + \"[bonus=\" + bonus + \"]\"; &#125; &#125;Point p = new Point(10, 20); String message = \"The current position is \" + p; //此处编译器会自动的调用p.toString()方法，以便获得这个对象的字符串描述。\"\"+x; //可替代x.toString()的调用，与 toString 不同的是，如果 x 是基本类型，这条语句照样能够执行。int[] luckyNumbers = &#123; 2, 3, 5, 7, 11, 13 &#125; ; String s = \"\" + luckyNumbers; //[I@la46e30（前缀 [I 表明是一个整型数组）。String s = Arrays.toString(luckyNumbers); //[2,3,5,7,11,13]Arrays.deepToString; //打印多维数组Class getSuperclass( ); //以 Class 对象的形式返回这个类的超类信息。 三、泛型数组列表ArrayListArrayList 是一个采用类型参数的泛型类,它在添加或删除元素时， 具有自动调节数组容量的功能。&lt;&gt;中的类型不能是基本数据类型。 1. 创建ArrayList12345678910111213141516ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;(); //构造一个空数组列表ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); //可以结合new操作符使用“菱形”语法,编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，编译器会检査这个变量、 参数或 //方法的泛型类型，然后将这个类型放在&lt;&gt;中。//在 Java SE 5.0 以后的版本中， 没有后缀 &lt;...&gt; 仍然可以使用ArrayList, 它将被认为是一个删去了类型参數的“ 原始” 类型。//添加对象staff.add(new Employee(\"Harry Hacker\", ...)); //在数组列表的尾端添加一个元素，如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。staff.ensureCapacity(l00); //可以指定数组大小，则在100次调用add之间不用重新分配空间。ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(l00); //可以把初始容量传递给 ArrayList 构造器。表明它拥有保存100个元素的潜力，重新分配空间的话会超过100staff.size(); //返回数组列表中包含的实际元素数目void trimToSize( ) //将数组列表的存储容量削减到当前尺寸。垃圾回收器将回收多余的存储空间。应该在确认不会添加任何元素时，再调用该方法否则添加元素时需要花时间再次移动存储块。 2. 访问数组列表元素1234567891011121314151617181920staff.set(i, harry); //设置第i个元素，只有i小于或等于数组列表中当前实际元素个数时才可以调用。Employee e = staff.get(i); //获得数组列表的元素//灵活扩展数组ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();while (. . .) &#123; x = . .; list.add(x); &#125;//方便访问数组X[] a = new X[list.size()];list.toArray(a); staff.add(i,e); //在数组列表的中间插入元素Employee e = staff.remove(i); //从数组列表中间删除一个元素。for (Employee e : staff) //可以使用“ foreach” 循环遍历数组列表： 3. 类型化与原始数组列表的兼容性12345678910public class EmployeeDB&#123; public void update(ArrayList list) &#123; . . . &#125; public ArrayList find(String query) &#123; . . . &#125; &#125;ArrayList&lt;Employee〉staff = . . .; //可以将一个类型化的数组列表传递给 update 方法,无需任何类型转换，但是这样不安全employeeDB.update(staff); //也可以将 staff 对象传递给 update 方法。@SuppressWarnings(\"unchecked\") ArrayList&lt;Employee&gt; result = employeeDB.find(query); //将一个原始 ArrayList 赋给一个类型化 ArrayList 会得到一个警告。一旦能确保不会造成严重的后果，可以用@SuppressWamings(\"unchecked\") 标注来标记这个变量能够接受类型转换。 四、对象包装器与自动装箱 包装器：所有的基本类型都有一个与之对应的类，称为包装器。Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean (前 6 个类派生于公共的超类 Number)。对象包装器是不可变的，不可改变其值，还是final的，不可定义其子类。 自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到固定的对象中。此时若用==比较两个值相同的包装器对象则一定为true。 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。 1234567891011121314151617181920212223242526272829303132333435ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //效率远低于int[],仅在构造小型集合时使用它。list.add(3); //自动装箱；会自动变换为list.add(Integer.valueOf(3));int n = list.get(i); //自动拆箱；会自动翻译成 int n = list.get(i).intValue();//算术表达式中也能自动装箱和拆箱Integer n = 3;n++; //编译器会自动地插入一条对象拆箱的指令， 然后进行自增计算， 最后再将结果装箱。Integer a = 1000;Integer b = 1000;if (a == b) //一般为false，而java中若将经常出现的值包装到同一个对象中，这种比较就有可能成立。为了避免这种不确定性，一般在两个包装器对象比较时调用 equals 方法。Integer n = null; //可以引用nullSystem.out.println(2 * n); //会抛出一个 NullPointerException 异常Integer n = 1;Double x = 2.0;System.out.println(true ? n : x); //输出1.0；如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱，提升为 double, 再装箱为 Double。int x = Integer.parseInt(s); //将字符串转换成整型。public static void triple(IntHolder x) //org.omg.CORBA 包中定义的持有者类型， 包括 IntHolder、BooleanHolder 等，都包含一个公有域值，可以改变x的值。&#123; x.value = 3 * x.value; &#125;static String toString(int i ) //以一个新 String 对象的形式返回给定数值 i 的十进制表示。 static String toString(int i ,int radix ) //返回数值 i 的基于给定 radix 参数进制的表示。static int parseInt(String s,int radix)Static Integer valueOf(String s, int radix)Number parse(String s) //返回数字值，假设给定的 String 表示了一个数值。 五、参数数量可变的方法也称为变参方法。 123456789101112131415161718192021//printf方法的定义public class PrintStream&#123; public PrintStream printf(String fmt , Object... args) //... 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除 fmt参数之外）。Object…参数类型与 Object[]完全一样。 &#123; //如果调用者提供的是整型数组或者其他基本类型的值，自动装箱功能将把它们转换成对象。 return format(fmt, args); //现在将扫描 fmt 字符串， 并将第 i 个格式说明符与 args[i] 的值匹配起来。 &#125; &#125;System.out.printf(\"%d %s\", new Object[] &#123; new Integer(n), \"widgets\" &#125; ); //编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上，并在必要的时候进行自动装箱.//自定义变参方法:计算若干个数值的最大值。public static double max (double... values) &#123; double largest = Double.NECATIVEJNFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest; &#125;double m = max(3.1, 40.4, -5);public static void main(String... args) 允许将一个数组传递给可变参数方法的最后一个参数,因此，可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。 六、枚举类所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。 1234567891011121314151617181920public enum Size &#123; SMALL , MEDIUM, LARGE, EXTRAJARGE &#125;; //实际上定义了一个类刚好有4个实例，由于Enum中equlas方法直接用==实现，故在比较两个枚举变量值时直接使用==即可//可以在枚举类型中添加一些构造器、 方法和域。public enum Size&#123; SMALL(\"S\"), MEDIUM(\"M\"), LARGE(\"L\"), EXTRA_LARGE(\"XL\"); private String abbreviation; private Size(String abbreviation) &#123; this,abbreviation = abbreviation; &#125; public String getAbbreviation() &#123; return abbreviation; &#125; &#125;Size.SMALL.toString(); //返回字符串\"SMALL\"。Size s = Enum.valueOf(Size,class, \"SMALL\"); //将 s 设置成 Size.SMALLSize[] values = Size.values(); //返回一个包含全部枚举值的数组。int ordinal () //返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。int compareTo( E other ) //如果枚举常量出现在 Other 之前， 则返回一个负值；如果 this=other，则返回 0; 否则，返回正值。枚举常量的出现次序在 enum 声明中给出。 七、反射能够分析类能力的程序称为反射，反射库提供了一个非常丰富且精心设计的工具集，使用它的主要人员是工具构造者，而不是应用程序员。反射的功能： 在运行时分析类的能力。 在运行时查看对象，例如，编写一个 toString 方法供所有类使用。 实现通用的数组操作代码。 利用 Method 对象， 这个对象很像C++中的函数指针。 1. Class类Class类中保存着Java 运行时系统始终为所有对象维护的一个被称为运行时的类型标识，虚拟机利用运行时类型信息选择相应的方法执行。通过Class类可以访问这些信息。一个Class对象将表示一个特定类的属性。Class 类实际上是一个泛型类。例如， Employee.class 的类型是 Class&lt;Employee&gt;,但是它将已经抽象的概念更加复杂化了。在大多数实际问题中， 可以忽略类型参数， 而使用原始的 Class 类。 1234567891011121314151617181920212223242526Employee e;Class cl = e.getClass(); //返回一个 Class 类型的实例。System.out.println(e.getClass().getName() + \" \" + e.getName()); //Class的 getName返回类的名字。返回 Employee Harry Hacker或Manager Harry HackerRandom generator = new Random():Class cl = generator.getClass();String name = cl.getName(); // \"java.util .Random\"。如果类在一个包里，包的名字也作为类名的一部分String className = \"java.util.Random\";Class cl = Class.forName(className); //获得类名对应的 Class 对象。 //这个方法只有在 dassName 是类名或接口名时才能够执行。否则将抛出一个 checked exception(已检查异常），在使用时必须提供一个异常处理器。Class dl = Random.class; // if you import java.utilClass cl 2 = int.class; //一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。Class cl 3 = Double[].class; //通过T.class获得Class对象。Double[ ] class.getName( ) //返回 [Ijava.lang.Double;int[ ].class.getName( ) //返回 [I if (e.getClass() == Employee.class) //可以使用==比较两个Class对象e.getClass().newInstance(); //来动态地创建一个与类e具有相同类型的实例String s = \"java.util.Random\";Object m = Class.forName(s).newInstance(); 2. 捕获异常若程序中没有提供捕获异常的处理器对异常情况进行处理，程序在运行时发生异常就会终止执行，并在控制台上打印一条信息给出异常类型。已检查异常：编译器将会检查是否为调用了抛出已检查异常方法的相关代码提供了异常处理器，否则将不能通过编译。未检查异常：编译器不要求强制处置的异常，虽然你有可能出现错误，但是我不会在编译的时候检查，需要自己精心编写代码来避免。例如访问 null 引用等。 123456789try&#123; String name = . . .; Class cl = Class.forName(name); //如果类名不存在， 则将跳过 try 块中的剩余代码，程序直接进人 catch 子句，否则跳过catch子句的处理器代码。&#125;catch (Exception e) &#123; e.printStackTrace(); //利用Throwable 类（Exception类的超类）的 printStackTrace 方法打印出栈的轨迹。&#125; 3. 利用反射分析类的能力在 java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、方法和构造器。 123456789101112131415161718import java.lang.Class;Field getField(String name ) //返回指定名称的公有域Field[] getDeclaredFields() //返回类中声明的给定名称的域， 或者包含声明的全部域的数组。//如果类中没有域， 或者 Class 对象描述的是基本类型或数组类型， 这些方法将返回一个长度为 0 的数组。Field[] getFields() //getFields 方法将返回一个包含 Field 对象的数组， 这些对象记录了这个类或其超类的公有域。Filed[] getDeclaredFie1ds() //getDeclaredField 方法也将返回包含 Field 对象的数组， 这些对象记录了这个类的全部域。//返回包含 Method 对象的数组//getMethods 将返回所有的公有方法， 包括从超类继承来的公有方法；//getDeclaredMethods 返回这个类或接口的全部方法， 但不包括由超类继承了的方法。Method[] getMethods()Method[] getDeclareMethods()//返回包含 Constructor 对象的数组Constructor[] getConstructors() //返回公有构造器Constructor[] getDeclaredConstructors() //返回所有构造器 12345678910111213141516171819202122232425import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Constructor;Class getDeclaringClass( ) //返冋一个用于描述类中定义的构造器、 方法或域的 Class 对象。Class[] getExceptionTypes ( ) //( 在 Constructor 和 Method 类中）返回一个用于描述方法抛出的异常类型的 Class 对象数组。int getModifiers( ) //返回一个用于描述构造器、 方法或域的修饰符的整型数值。使用 Modifier 类中的这个方法可以分析这个返回值。用不同的位开关描述 public 和 static 这样的修饰符使用状况String getName( ) //返冋一个用于描述构造器、 方法或域名的字符串。Class[] getParameterTypes ( ) //( 在 Constructor 和 Method 类 中）返回一个用于描述参数类型的 Class 对象数组。 Class getReturnType( ) //( 在 Method 类中）返回一个用于描述返H类型的 Class 对象。static String toString(int modifiers ) //返回对应 modifiers 中设置的修饰符的字符串表示。//这些方法将检测方法名中对应的修饰符在 modifiers 值中的位，即方法和构造器是否是public、 private 或 final。static boolean isAbstract(int modifiers )static boolean isFinal (int modifiers )static boolean islnterface(int modifiers )static boolean isNative(int modifiers )static boolean isPrivate(int modifiers )static boolean isProtected(int modifiers )static boolean isPublic(int modifiers )static boolean isStatic(int modifiers )static boolean isStrict(int modifiers )static boolean isSynchronized(int modifiers )static boolean isVolati1e(int modifiers ) 4. 在运行时使用反射分析对象 在编写程序时， 如果知道想要査看的域名和类型，查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域,从而进一步查看运行时数据域的实际内容。 反射机制的默认行为受限于 Java 的访问控制。除非拥有访问权限，否则Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。可利用需要调用 Field、 Method 或Constructor 对象的 setAccessible 方法来覆盖访问控制。 当调用get方法获得域值时参数为基本数据类型，则反射机制将会自动地将这个域值打包到相应的对象包装器中。也可以调用Field 类中的 getDouble 等方法。12345678910111213141516Employee harry = new Employee(\"Harry Hacker\", 35000, 10, 1, 1989);Class cl = harry.getClass; Field f = cl .getDeclaredField(\"name\"); f.setAtcessible(true); //覆盖访问控制Object v = f.get(harry); //获得name域运行时的具体值为\"Harry Hacker\"f.set(obj,value); //将 obj 对象的 f 域设置成新值public String toString() &#123; return new ObjectAnalyzer().toString(this); //利用ObjectAnalyzer类的toString方法可为每个自定义类重写一个通用的toString方法，很方便。将打印类的所有信息，包括运行时的具体域值。&#125;boolean isAccessible( ) //返回反射对象的可访问标志的值。static void setAccessible(AccessibleObject[] array,boolean flag) //是一种设置对象数组可访问标志的快捷方法。 5. 使用反射编写泛型数组代码将一个 Employee[]临时地转换成 Object[] 数组， 然后再把它转换回来是可以的，但一从开始就是 Object[] 的数组却永远不能转换成 Employee[] 数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。 1234567891011121314151617181920212223//注意，这个 CopyOf 方法可以用来扩展任意类型的数组， 而不仅是对象数组。//应该将 goodCopyOf 的参数声明为 Object 类型，而不要声明为对象型数组（Object[])。整型数组类型 int[] 可以被转换成 Object，但不能转换成对象数组。public static Object goodCopyOf(Object a, int newLength) &#123; Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength): System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; &#125;static Object get(Object array,int index) //( xxx 是 boolean、byte、 char、 double、 float、 int、 long、 short 之中的一种基本类型。)static xxx getXxx(Object array,int index) //这些方法将返回存储在给定位置上的给定数组的内容。static void set(Object array,int index,Object newValue) //( xxx 是 boolean、 byte、char、double、float、 int、 long、 short 之中的一种基本类型。)static setXxx(Object array,int index,xxx newValue) //这些方法将一个新值存储到给定位置上的给定数组中。static int getLength(Object array) //返回数组的长度。static Object newInstance(Class componentType,int length)static Object newInstance(Class componentType,int[] lengths) //返回一个具有给定类型、给定维数的新数组。 6. 利用反射调用任意方法利用反射中的Method类的invoke方法可以回调任意对象的任意方法。 1234567891011Object invoke(Object obj, Object... args) //第一个参数是隐式参数， 其余的对象提供了显式参数，对于静态方法，第一个参数可以被忽略， 即可以将它设置为 null。 //如果返回类型是基本类型， invoke 方法会返回其包装器类型。必须相应地完成类型转换。Method getMethod(String name, Class... parameterTypes) //利用Class类中的getMethod方法获得Method对象 //也可以通过调用 getDeclareMethods 方法， 然后对返回的 Method 对象数组进行查找， 直到发现想要的方法为止。Method ml = Employee.class.getMethod(\"getName\");Method m2 = Employee.class.getMethod(\"raiseSalary\", double.class);String n = (String) ml.invoke(harry); double s = (Double) m2.invoke(harry);f.invoke(null, x); //有可能存在若干个相同名字的方法，鉴于此，还必须提供想要的方法的参数类型。 反射的优缺点： 反射对于编写系统程序来说极其实用，但是通常不适于编写应用程序。 如果在调用方法的时候提供了一个错误的参数，那么 invoke 方法将会抛出一个异常； 且使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。 反射是很脆弱的，即编译器很难帮助人们发现程序中的错误， 因此只有在运行时才发现错误并导致异常。 因此建议仅在必要的时候才使用 Method 对象，而最好使用接口以及 Java SE8 中 的 lambda 表达式，它们的代码的执行速度更快，更易于维护。 八、继承的设计技巧 将公共操作和域放在超类； 不要使用受保护的域； 使用继承实现严格“ is-a” 关系，即超类中不能存在子类不需要的域； 除非所有继承的方法都有意义，否则不要使用继承； 在覆盖方法时，不要改变预期的行为； 使用多态(具有动态邦迪机制)，而非类型信息； 不要过多地使用反射。","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Java面向对象","date":"2020-04-29T01:45:33.000Z","path":"2020/04/29/Java基础知识/Java中的对象与类/","text":"Java 是完全面向对象(OOP)的，而面向对象更加适用于解决规模较大的问题。 一、类和对象1. 类类：类是构造对象的模板或蓝图，由类构造对象的过程称为创建类的实例。封装: 从形式上看，封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。实例域：对象中的数据。方法：操纵数据的过程。状态：对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。并不是所有的类都具有面向对象特征，例如Math类只封装了功能，它不需要也不必隐藏数据。 2. 对象三个主要特征： 对象的行为（behavior)—可以对对象施加哪些操作，或可以对对象施加哪些方法。 对象的状态（state )—对象状态的改变必须通过调用方法实现，否则会破坏封装性。 对象标识（identity )—每个对象都有一个唯一的身份。 对象与对象变量的区别： 12345678Date deadline; //变量deadline不是一个对象， 实际上也没有引用对象,因此还不能将任何 Date 方法应用于这个变量上。deadline = new Date(); //一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 //表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 deadline 中。Date birthday = new Date();deadline = birthday; deadline = null; //显式地将对象变量设置为 null,表明这个对象变量目前没有引用任何对象。该对象不能使用任何方法。 //局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。 3. 类之间的关系 依赖（“uses-a”）:一个类的方法操纵另一个类的对象，即一个类依赖于另一个类。又称为耦合度，实际开发中应让这种耦合最小。 聚合（“has-a”） :类 A 的对象包含类 B 的对象。 继承（“is-a”）:用于表示特殊与一般关系。如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。 表示关系的UML符号： 二、使用预定义类1. Java类库中的LocalDate类12345678910111213Local Date.now(); //使用类中的静态工厂方法LocalDate.of(1999, 12, 31); //提供年、 月和日来构造对应一个特定日期的对象：LocalDate newYearsEve = Local Date.of(1999, 12, 31); //将构造的对象保存在一个对象变量中供再次使用。LocalDate aThousandDaysLater = newYearsEve.plusDays(1000); //得到距当前对象指定天数的一个新日期对象。LocalDate minusDays(int n) //生成当前日期之后或之前 n 天的日期。int getYear( ) int getMonthValue( ) int getDayOfMonth( ) //得到当前日期的年、 月和日。DayOfWeek getDayOfWeek; //得到当前日期是星期几， 作为 DayOfWeek 类的一个实例返回。 调用 getValue 来得到1 ~ 7 之间的一个数， 表示这是星期几， 1 表示星期一， 7 表示星期日。 2. CregorianCalendar类12345CregorianCalendar someDay = new CregorianCalendar(1999, 11, 31);someDay.add(Calendar.DAY_0F_M0NTH, 1000); //更改器方法year = someDay.get(Calendar.YEAR); //访问器方法month = someDay.get(Calendar.MONTH)+ 1; day = someDay.get(Ca1endar.DAY_0F_M0NTH); 三、用户自定义类123456789101112131415161718192021222324252627282930313233343536373839404142class Employee&#123; //私有数据域 private String name; private double salary; private Local Date hireDay;//构造器与类同名//构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的，否则会产生编译错误。//每个类可以有一个以上的构造器//构造器可以有 0 个、1 个或多个参数，没有返回值 public Employee (String n , double s, int year, int month , int day) &#123; name = n; salary = s; hireDay = Local Date,of(year, month, day); //注意， 不要在构造器中定义与实例域重名的局部变量。否则实例域会被覆盖从而使构造器失效。 &#125;//域访问器public String getName()&#123; return name;&#125;public double getSalary()&#123; return salary;&#125;public Local Date getHireDay() //注意不要编写返回引用可变对象的访问器方法。否则会破坏封装性，由第三方改变类中的私有状态。该方法就违反了这个设计原则&#123; //如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone )。 //return hireDay; return (Date)hireDay.clone();&#125;//域更改器public void raiseSalary(double byPercent) //raiseSalary 方法有两个参数。 第一个参数称为隐式参数， 是出现在方法名前的Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。 &#123; double raise = this.salary * byPercent / 100; //关键字 this 表示隐式参数 salary += raise; &#125;&#125; 1. 多个源文件的使用在开发中习惯于将每一个类存在一个单独的源文件中，这时既可以显式编译也可以隐式编译。当 Java 编译器发现 EmployeeTest.java 使用 Employee 类时会查找名为 Employee.class 的文件。如果没有找到这个文件， 就会自动地搜索 Employee.java, 然后，对它进行编译。如果 Employee,java 版本较已有的 Employee.class 文件版本新，Java 编译器就会自动地重新编译这个文件。 2. 封装封装一个类一般提供下面三项内容： 私有的数据域； 公有的域访问器方法； 一个公有的域更改器方法。 3. 基于类的访问权限类中的方法可以访问所属类对象的私有特性, 而不仅限于访问隐式参数的私有特性。 1234567class Employee&#123; ... public boolean equals(Employee other) &#123; return name.equals(other.name); &#125; &#125; 4. 私有方法绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。有些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密， 或者需要一个特别的协议以及一个特别的调用次序。在 Java 中，为了实现一个私有的方法， 只需将关键字 public 改为 private 即可。只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方法是公有的， 就不能将其删去，因为其他的代码很可能依赖它。 5. final 实例域12345678910class Employee&#123; //final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类）。 private final String name; //必须确保在每一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。 //对于可变的类， 使用 final 修饰符可能会对读者造成混乱 //final 关键字只是表示存储在 evaluations 变量中的对象引用不会再指示其他 StringBuilder对象。不过这个对象可以更改。 private final StringBuiIcier evaluations; &#125; 四、静态域与静态方法1. 静态域12345class Employee&#123; private static int nextld = 1; //如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。 private int id; &#125; 2. 静态常量静态变量使用得比较少，但静态常量却使用得比较多。静态常量可以被设置为public，因为final常量不允许被修改。 123456789public class Math&#123; public static final double PI = 3.14159265358979323846; &#125;public class System&#123; public static final PrintStream out = . . .; &#125; 3. 静态方法使用静态方法的两种情况： 一 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow)。 一个方法只需要访问类的静态域。 12345678910//静态方法不能访问实例域， 因为它不能操作对象。但是，静态方法可以访问自身类中的静态域//可以认为静态方法是没有 this 参数的方法。//可以使用对象调用静态方法但没必要。因为静态方法与对象实例域毫无关系。public static int getNextId()&#123; return nextId; // returns static field &#125;//使用类名调用该方法int n = Employee.getNextld(); 如果一个域是静态的基本数据类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化的值就是null。static关键字不能应用于局部变量，因此它只能作用于域。 4. 工厂方法工厂方法是静态方法的另一种常见用途，类似 LocalDate 和 NumberFormat 的类使用静态工厂方法来构造对象。 12345NumberFormat currencyFormatter = NumberFormat.getCurrencylnstance();NumberFormat percentFormatter = NumberFormat.getPercentlnstance()；double x = 0.1;System.out.println(currencyFormatter.format(x)); // prints $O.10System.out.println(percentFomatter.format(x)); // prints 10% 使用工厂方法的两个原因： 无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例和百分比实例采用不用的名字。 当使用构造器时，无法改变所构造的对象类型。而 Factory 方法将返回一个 DecimalFormat类对象，这是 NumberFormat 的子类。 5. main方法 main方法也是一种静态方法，不能操作所在类的实例域。静态的main 方法将执行并创建程序所需要的对象。 每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。可独立的对类进行测试。 五、方法参数 按值调用：表示方法接收的是调用者提供的值，即形参为实参的一个拷贝，对形参的修改不能改变实参的值。 按引用调用：表示方法接收的是调用者提供的变量地址。 Java 总是采用按值调用，方法不能修改传递给它的任何参数变量的内容。 1234567891011121314151617181920public static void tripieValue(double x) // doesn't work&#123; x = 3 * x; &#125;double percent = 10; tripieValue(percent); //一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。public static void tripleSalary (Employee x) // works&#123; x.raiseSa1ary(200); &#125;harry = new Employee(. . .);tripleSalary(harry); //一个方法可以改变一个对象参数的状态。public static void swap(Employee x , Employee y) // doesn't work&#123; Employee temp = x; x = y; y = temp; //一个方法不能让对象参数引用一个新的对象。&#125; 六、对象构造1. 重载 方法签名：要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名。返回类型不是方法签名的一部分。 重载：多个方法有相同的名字、 不同的参数，便产生了重载。不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。 重载解析:通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误。 2. 默认域初始化 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。 域与局部变量不同，必须明确地初始化方法中的局部变量。 3. 无参数的构造器 如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。 如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。此时必须显式提供一个不带参数的构造器才可以将所有的实例域设置为默认值。 4. 显式域初始化12345678910111213141516171819202122232425262728293031323334353637383940class Employee&#123; //初始值为常量值，用在当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时。 //在执行构造器之前，先执行赋值操作。 private String name =\"\"; //初始值不一定是常量值 private static int nextId; //静态域在类加载时即被加载且未被赋初值的会被赋予默认值。 private int id = assignId(); private static int assignId() &#123; int r = nextId; nextId++; return r; &#125; //使用初始化块 //在一个类的声明中，可以包含多个代码块 //首先运行初始化块，然后才运行构造器的主体部分。 //不常见 &#123; id = nextld; nextld++; &#125; //在类第一次加载的时候， 将会进行静态域的初始化 //所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。 static &#123; Random generator = new Random(); nextld = generator.nextInt(lOOOO); &#125; //从 Java SE 7 以后，java 程序首先会检查是否有一个 main 方法。 static &#123; System.out.println(\"Hel1o, World\"); &#125;&#125; 域初始化的顺序很复杂，调用构造器的具体处理步骤： 所有数据域被初始化为默认值（0、false 或 null）。 按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块。 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 执行这个构造器的主体。 5. 参数名123456789public Employee(String aNaie, double aSalary) &#123; name = aName ; salary = aSalary; &#125;public Employee(String naie, double salary) &#123; this.name = name; this,sal ary = salary; &#125; 6. 利用this调用同一个类中的另一个构造器12345//可有效减少代码重复public Employee(double s) &#123; // calls Employee(String, double) this(\"Employee #\" + nextld, s); nextld++; &#125; 七、包使用包的主要原因是确保类名的唯一性，而不会产生冲突。 1. 类的导入一个类可以使用所属包中的所有类， 以及其他包中的公有类。 12345678910111213141516171819java.time.LocalDate today = java.tine.LocalDate.now(); //繁琐//import 语句应该位于源文件的顶部(但位于 package 语句的后面)。//只能使用星号（*) 导入一个包， 而不能使用 import java.* 或import java.*.* 导入以 java 为前缀的所有包。import java.util.*;LocalDate today = Local Date.now();//此时若在程序直接使用 Date 类的时候， 就会出现一个编译错误，因为二者均包含Date类import java.util.*;import java.sql.*;//可明确指出使用哪个包中的Dateimport java.util.*;import java.sql.*;import java.util.Date;//若两个Date均需要使用应添加上完整包名java.util.Date deadline = new java.util.Date();java.sql.Date today = new java.sql.Date(...); 2. 静态导入123import static java.lang.System.*;out.println(\"Goodbye, World!\"); // System.outexit(0); //System.exit 3. 将类放入包中如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包(没有名字)中。 123456789package com.horstmann.corejava;public class Employee&#123;&#125;//编译javac PackageTest.javajavac com/horstmann/corejava/Employee.java 编译器在编译源文件的时候不检查目录结构。如果源文件不在指定package中且不依赖于其他包， 就不会出现编译错误。但是， 最终的程序将无法运行，因为虚拟机找不到类。 4. 包作用域 标记为 public 的部分可以被任意的类使用； 标记为 private 的部分只能被定义它们的类使用。 如果没有指定 public 或 private , 这个部分（类、方法或变量）可以被同一个包中的所有方法访问。 八、类路径类路径是所有包含类文件的路径的集合。类路径包含三种情况： 基目录 /home/user/classdir 或 c:\\classes 当前目录 (.); JAR 文件 /home/user/archives/archive.jar 或c:\\archives\\archive.jar 类路径所列出的目录和归档文件是搜寻类的起始点。 1. 虚拟机搜寻类文件的过程 首先要查看存储在 jre/lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。 若找不到相应类文件，再查看类路径。 /home/user/classdir/com/horstmann/corejava/Employee.classcom/horstmann/corejava/Employee.class 从当前目录开始com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar 2. 编译器搜寻类文件的过程 如果引用了一个类，而没有指出这个类所在的包， 那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。 如果找到了一个以上的类， 就会产生编译错误。 编译器还要查看源文件是否比类文件新，如果是这样的话，那么源文件就会被自动地重新编译。 3. 设置类路径1234567//采用 -classpath (或 -cp) 选项指定类路径java -classpath /home/user/dassdir: .:/home/user/archives/archive.jar HyProgjava -classpath c:\\classdir; .;c:\\archives\\archive.jar MyProg//设置 CLASSPATH 环境变量export CLASSPATH=/home/user/classdir:.:/ home/user/archives/archive.jar //Bourne Again shell ( bash)set CLASSPATH=c:\\classdir;.;c:\\archives\\archive.jar //Windows shell 九、文档注释利用JDK中的javadoc命令工具，可以由源文件生成一个 HTML 注释(/** */)文档。文档注释与源代码在同一个文件中，在修改源代码的同时， 重新运行 javadoc 就可以轻而易举地保持两者的一致性。 1. 注释的插入javadoc抽取信息生成文档的位置如下，也应当在这些位置编写注释： 包 公有类与接口 公有的和受保护的构造器及方法 公有的和受保护的域 文档注释的格式： 12345/*** 自由格式文本：标记如@author或 @param等* 第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽取出来形成概要页。* 在自由格式文本中，可以使用 HTML 修饰符，如&lt;em&gt;&lt;/em&gt;等*/ 2. 类注释类注释必须放在 import 语句之后，类定义之前。 3. 方法注释每一个方法注释必须放在所描述的方法之前。可以使用以下标记：@param:对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。@return:这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。©throws:这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。 4. 域注释只需要对公有域（通常指的是静态常量）建立文档。 5. 通用注释用于类文档的注释中。 12345678910/**@author 姓名@version 文本@since 文本@deprecated 文本@see 引用 @see com.horstraann.corejava.Employee#raiseSalary(double) @see &lt;a href=\"m«w.horstmann . com/corejava. htinl \"&gt;The Core ]ava home page&lt;/a&gt; Isee \"Core Java 2 volume 2n&#123;@link package.class#feature label &#125;*/ 6. 包与概述注释要想产生包注释，就需要在每一个包目录中添加一个单独的文件。有两种方式添加： 提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;—&lt;/body&gt; 之间的所有文本都会被抽取出来。 提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** 和 */ 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。 还可以为所有的源文件提供一个概述性的注释。名为overview,html 的文件中，这个文件位于包含所有源文件的父目录中。标记&lt;body&gt;—&lt;/body&gt;间的所有文本将被抽取出来。 7. 注释的抽取详见http://docs.oracle.com/javase/8/docs/guides/javadoc 123456789101112//docDirectory为HTML文件的存放目录1. 切换到包含想要生成文档的源文件目录。2. javadoc -d docDirectory nameOfPackage //如果省略了 -d docDirectory 选项， 那 HTML 文件就会被提取到当前目录下。3. javadoc -d docDirectory nameOfPackage1 nameOfPackage2 . . .4. javadoc -d docDirectory *.java //文件在默认包中//可以使用 -author 和 -version 选项在文档中包含@author 和@version 标记（默认情况下，这些标记会被省略)。//使用-link为标准类添加超链接javadoc -link http://docs.oracle.eom/:javase/8/docs/api *.java //所有的标准类库类都会自动地链接到 Oracle 网站的文档。//使用 -linksource 选项，则每个源文件被转换为 HTML (不对代码着色，但包含行编号) 并且每个类和方法名将转变为指向源代码的超链接。 十、类设计技巧 一定要保证数据私有 一定要对数据初始化 不要在类中使用过多的基本类型 不是所有的域都需要独立的域访问器和域更改器 将职责过多的类进行分解 类名和方法名要能够体现它们的职责 优先使用不可变的类","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Codeup和PAT刷题记录——入门模拟","date":"2020-04-24T08:45:22.000Z","path":"2020/04/24/算法笔记/入门模拟/","text":"记录刷题过程中遇到的问题和技巧。 一、技巧总结1. 简单模拟①将字符型数字转换为整型数字：例如&#39;8&#39;-&#39;0&#39;。②当 -109&lt;a,b&lt;109,或者-231&lt;a,b&lt;231，a+b仍为Int型,但当区间带等号时a,b,c都应当定义为long long型变量。 2. 图形输出③整数n/2避免使用round函数来进行四舍五入： 12if(n%2==0) n=n/2;else n=n/2+1; ②使用指定字符输出图形实质上是确定每一行输出的不同字符数与行数之间的数学计算关系。 3. 日期处理①日期处理问题往往需要使用数组存储与日期如平年和闰年的月份、月份和星期的英文字符串等 12345678910//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！month[m][0]存储平年每个月天数，month[m][1]存储闰年每个月天数 int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//存储月份英文名称和罗马数字的关系char monthToNum[13][20]=&#123;\" \",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\", \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;;//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ char numToWeek[8][20]=&#123;\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"&#125;; ②判断是否为闰年的函数写法 12//判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125; ③查找任意年y的某个月m的天数写法 1month[m][isLeapTear(y)]; ④提取int型变量中的任意几位：例如提取20130102中的YYYY、MM、DD。 1y1=date1/10000,m1=date1%10000/100,d1=date1%10000%100; ⑤计算任意两个日期间差值可分别计算它们与公元1年1月1日的差值然后再计算两个差值的差值。⑥计算某个日期的星期数可首先计算与公元1年1月1日天数差值，再对差值取余即为星期数的下标。 4. 进制转换①P进制数x转换为十进制数y，利用while循环 12345while(x!=0)&#123; y=y+(x%10)*product; x/=10; product*=P;&#125; ②十进制数y转换为Q进制数z[num-1,0],利用“除基取余法”和do while循环，防止y=0而没有输出 1234do&#123; z[num++]=y%Q; y/=Q;&#125;while(y!=0); ②注意当数组z为字符数组时，在末尾应手动添加’\\0’，否则容易出错。③当十进制整数超出整型可存储的范围时，用字符数组来存储处理比较方便，来模拟十进制整数的运算过程。 5. 字符串处理①边输入边处理被空格分隔的字符串有两种方式 12while((c=getchar())!='\\n')&#123;...&#125;while(scanf(\"%s\",s[num++])!=EOF); ②一定要注意scanf(“%c”)和gets(s)之间要用getchar()吸收换行符，否则很容易出错。③若题设条件未给出输入字符串格式，则应考虑带空格的输入。此时应用gets(s)进行输入。 二、经典题目1. 比较交换3个实数值，并按序输出题目描述从键盘输入3个实数a, b, c，通过比较交换，将最小值存储在变量a中，最大值存储在变量c中，中间值存储在变量b中，并按照从小到大的顺序输出这三个数a, b, c。末尾输出换行。输入输入以空格分隔的三个实数输出按照从小到大的顺序输出这三个实数，中间以空格分隔，最小值在前，最大值在后。小数点后保留2位小数。注意末尾的换行。样例输入3 7 1样例输出1.00 3.00 7.00 思路冒泡法。 12345678910111213#include&lt;stdio.h&gt;int main()&#123; double a,b,c,temp; scanf(\"%lf%lf%lf\",&amp;a,&amp;b,&amp;c); //冒泡法 if(a&gt;b)temp=a,a=b,b=temp; if(b&gt;c)temp=b,b=c,c=temp; if(a&gt;b)temp=a,a=b,b=temp; printf(\"%.2f %.2f %.2f\\n\",a,b,c); return 0;&#125; 2. 三个整数求最大值题目描述有3个整数a, b, c，由键盘输入，输出其中最大的数。输入以空格分割的三个整数。输出三个数中的最大值，末尾换行。样例输入1 3 2样例输出3思路比较 1234567891011#include&lt;stdio.h&gt;int main()&#123; int a,b,c,max; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); max=a&gt;b?a:b; max=max&gt;c?max:c; printf(\"%d\\n\",max); return 0;&#125; 3. 矩阵输出题目描述输出以下4*5的矩阵 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20要求使用循环实现，注意每行输出5个数字，每个数字占3个字符的宽度，右对齐。输入无输出每行输出5个数字，每个数字占3个字符的宽度，右对齐。样例输入无样例输出 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20思路 i保存每一行的输出值，a为每行的累加值， i=i+a; 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int i=1,a=1; while(a&lt;=4)&#123; printf(\"%3d\",i); //依次输出元素 if(i%5==0)&#123; printf(\"\\n\"),a++,i=a; continue; //若每行元素达到5个，则换行且重置a和i的值，并跳出本次循环。 &#125; i+=a; &#125; return 0;&#125; 4. 杨辉三角题目描述按要求输入如下格式的杨辉三角11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1最多输出10层输入输入只包含一个正整数n，表示将要输出的杨辉三角的层数。输出对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开样例输入5样例输出11 11 2 11 3 3 11 4 6 4 1思路i控制输出的行数，j控制每行元素个数，j&lt;=i,a[j]保存上一行的元素，b[j]根据a[j]计算本行的元素值并输出； ① 首先输出每行的第一个元素b[1]；② 然后控制j=2,j&lt;i,输出每行中间元素b[j]=a[j-1]+a[j]；③ 最后输出每行最后一个元素b[j]=a[j],并换行；④ 更新a[j]，回到步骤① 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,i,j,a[15]=&#123;0,1,1,1,1,1,1,1,1,1,1&#125;,b[15]; b[1]=a[1]; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++)&#123; printf(\"%d \",b[1]); //输出每一行第一个元素 for(j=2;j&lt;i;j++)&#123; //输出每行中间的元素 b[j]=a[j-1]+a[j]; printf(\"%d \",b[j]); &#125; if(j&gt;i)&#123; printf(\"\\n\"); continue; &#125; b[j]=a[j]; //输出每一行最后一个元素 printf(\"%d\\n\",b[j]); for(j=2;j&lt;i;j++) a[j]=b[j]; //更新a[j] &#125; return 0;&#125; 5. Shortest Distance (20)题目描述The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.输入Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.输出For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.样例输入5 1 2 4 14 931 32 54 1样例输出3107思路本题中的距离不能暴力求解，否则极易出现超时错误！ ①输入距离d的同时利用circle累加距离，并同时利用数组dist[i+1]=circle记录出口i到出口1的距离，输入结束后circle即为计算的周长。②计算任意出口a,b间的顺时针距离d1，利用d1=abs(dist[b]-dist[a])。③计算任意出口a,b间的逆时针距离d2，利用d2=circle-d1。④输出d1和d2中较小的那一个距离。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; //Codeup中的C++编译器不支持cmath中的abs函数int main()&#123; int N,M,a,b,d; //出口个数N、区间[a,b]的个数M，以及出口间距离d while(scanf(\"%d\",&amp;N)!=EOF)&#123; int circle=0,dist[100010]=&#123;0&#125;; //周长及各出口离起始出口的距离 for(int i=1;i&lt;=N;i++)&#123; scanf(\"%d\",&amp;d); circle+=d; //计算周长 dist[i+1]=circle; //计算各出口距离出口1的距离 &#125; scanf(\"%d\",&amp;M); while(M--)&#123; int d1,d2; //正向反向距离 scanf(\"%d%d\",&amp;a,&amp;b); d1=abs(dist[b]-dist[a]); //计算正向距离 d2=circle-d1; //反向距离=周长-正向距离 if(d1&gt;d2) printf(\"%d\\n\",d2); else printf(\"%d\\n\",d1); &#125; &#125; return 0;&#125; 6. 日期差值题目描述有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。 输入有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD 输出每组数据输出一行，即日期差值 样例输入2013010120130105样例输出5思路 ①首先求出每个日期到公元1年1月1日的天数days1和days2，则days2-days1+1即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125;//计算任意日期距离公元1年1月1日的天数 int daysFromFirstYear(int y,int m,int d)&#123; int days=0,i=1,j=1,k=1; //累加年 for(;i&lt;y;i++)&#123; if(isLeapYear(i)) days+=366; else days+=365; &#125; //累加月 for(;j&lt;m;j++)&#123; if(isLeapYear(i)) days+=month[j][1]; else days+=month[j][0]; &#125; //累加日 days+=(d-k+1); return days;&#125; int main()&#123; int y1,m1,d1,y2,m2,d2; int date1,date2; while(scanf(\"%d\\n%d\",&amp;date1,&amp;date2)!=EOF)&#123; if(date1&gt;date2)&#123; int temp=date1; date1=date2; date2=temp; &#125; y1=date1/10000,m1=date1%10000/100,d1=date1%10000%100; y2=date2/10000,m2=date2%10000/100,d2=date2%10000%100; int days1,days2; days1=daysFromFirstYear(y1,m1,d1); days2=daysFromFirstYear(y2,m2,d2); printf(\"%d\\n\",days2-days1+1); &#125; return 0;&#125; 7. Day of Week题目描述We now use the Gregorian style of dating in Russia. The leap years are years with number divisible by 4 but not divisible by 100, or divisible by 400.For example, years 2004, 2180 and 2400 are leap. Years 2004, 2181 and 2300 are not leap.Your task is to write a program which will compute the day of week corresponding to a given date in the nearest past or in the future using today’s agreement about dating. 输入There is one single line contains the day number d, month name M and year number y(1000≤y≤3000). The month name is the corresponding English name starting from the capital letter. 输出Output a single line with the English name of the day of week corresponding to the date, starting from the capital letter. All other letters must be in lower case. 样例输入21 December 20125 January 2013样例输出FridaySaturday思路 ①存储闰年平年天数int month[13][2]、英文月份char monthToNum[13][20]以及英文星期char numToWeek[8][20]，注意!格里高利纪元中公元1年1月1日为星期一;②计算给定日期距离1年1月1日天数days;③numToWeek[days%7]即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt; //存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;, &#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//存储月份英文名称和罗马数字的关系char monthToNum[13][20]=&#123;\" \",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\", \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;;//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ char numToWeek[8][20]=&#123;\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"&#125;; //判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125;//计算任意日期距离公元1年1月1日的天数 int daysFromFirstYear(int y,int m,int d)&#123; int days=0,i=1,j=1,k=1; //累加年 for(;i&lt;y;i++)&#123; if(isLeapYear(i)) days+=366; else days+=365; &#125; //累加月 for(;j&lt;m;j++)&#123; if(isLeapYear(i)) days+=month[j][1]; else days+=month[j][0]; &#125; //累加日 days+=(d-k+1); return days;&#125; int main()&#123; int d,m,y; char mon[20]; while(scanf(\"%d%s%d\",&amp;d,mon,&amp;y)!=EOF)&#123; //获取英文月份的罗马数字 for(int i=1;i&lt;=12;i++)&#123; if(strcmp(monthToNum[i],mon)==0)&#123; m=i; break; &#125; &#125; int days=daysFromFirstYear(y,m,d); printf(\"%s\\n\",numToWeek[days%7]); &#125; return 0;&#125; 8. 进制转换题目描述将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。 输入多组数据，每行为一个长度不超过30位的十进制非负整数。（注意是10进制数字的个数可能有30个，而非30bits的整数） 输出每行输出对应的二进制数。 样例输入9852111126样例输出11110110011101001110001100110思路 ①输入超过整型可存储范围，使用字符数组模拟除法过程和判断是否为0过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt; //模拟十进制除法，返回余数 char divideBy2(char number[],char result[])&#123; int num=0,sum=0; for(int i=0;i&lt;strlen(number);i++)&#123; int temp=number[i]-'0'; sum=sum*10+temp; result[num++]=sum/2+'0'; sum=sum%2; &#125; result[num]='\\0'; return sum+'0';&#125;//判断字符串转为十进制是否为0 bool isZero(char number[])&#123; int i; for(i=0;i&lt;strlen(number);i++)&#123; if(number[i]!='0') return false; &#125; if(i==strlen(number)) return true;&#125; //输入超过整型可存储范围，使用字符数组模拟除法过程 int main()&#123; char number[35]; char result[100]; char left[100]; //定义商和余数 while(scanf(\"%s\",number)!=EOF)&#123; int num=0; do&#123; left[num++]=divideBy2(number,result); strcpy(number,result); &#125;while(!isZero(number)); for(int i=num-1;i&gt;=0;i--) printf(\"%c\",left[i]); printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"}]},{"title":"算法复杂度和黑盒测试","date":"2020-04-23T15:29:52.000Z","path":"2020/04/23/算法笔记/算法复杂度和黑盒测试/","text":"引言了解算法复杂度很重要，我们在编写算法时常常要注意算法复杂度以避免出现程序运行超时的结果，此外，了解常用OJ的黑盒测试方法也有助于编写正确高效的算法。本篇简单介绍了三种算法复杂度和黑盒测试的代码写法，并简单罗列了OJ在判定时出现的一些结果，以便找到出错原因。 一、算法复杂度1. 时间复杂度时间复杂度是算法执行基本运算(如加减乘除)的次数所处的等级，是评判算法时间效率的有效标准，较高的时间复杂度会让评测系统返回“运行超时”，对一般的OJ系统来说，一秒能承受的运算次数大概是107至108。 讲时间复杂度是不带系数的，称为时间复杂度常数，例如基本运算次数为cn,cn2，则时间复杂度分别为O(n)，O(n2)。 高等级的幂次会覆盖低等级的幂次，因此O(3n2+n+2)=O(n2)。 当某些算法实现较为复杂时，其常数会比较大，这时即使时间复杂度相同其性能也会有较大差距。 不同级别时间复杂度比较：O(1)&lt;O(logn)&lt;O(n)&lt;O(n2)。 2. 空间复杂度空间复杂度和时间复杂度的写法相同，表示算法需要消耗的最大数据空间。一般来说空间都是足够使用的，只要不开好几个107以上的数组，故一般会使用以空间换时间的算法策略。 3. 编码复杂度编码复杂度是一个定性的概念，没有一个量化标准，就是指代码的冗长程度。如果使用了冗长的算法思想则编码复杂度就会很大。 二、黑盒测试OJ后台会准备若干组数据(一般是放在一个文件里)让程序运行，并将运行结果在字符串意义上进行比较，若完全相同，则称通过了本题的黑盒测试，否则返回不同判定结果，根据黑盒测试对每组数据单独测试还是一次性全部测试，分为单点和多点测试。 1. 单点测试PAT采取的是单点测试，它会对每组数据都给出相应的测评结果，并且每组数据都有得分值，题目总得分等于通过数据得分值之和。所以它仅要求编写的程序能一次运行一组数据，采用普通写法。 2. 多点测试大部分OJ如Codeup等都是采用多点测试，它要求编写的程序能够一次性运行所有的数据，并要求所有输出结果都必须完全正确才算通过测试，故需要用到循环结构。多点测试能够考验算法编写的严谨性。题目一般会有3种输入格式，需要采取不同的输入方式。 三种输入类型 123456789101112131415//循环输入直到文件末尾while(scanf(\"%d\",&amp;n)!=EOF)&#123; ...//scanf返回值为成功读入的参数个数，当读取文件到达末尾时才会读取失败，此时返回-1，C语言中用EOF(End Of File)代替-1。 //在运行框输入数据时并不会触发EOF，需要手动输入&lt;Ctrl+Z&gt;键，再按&lt;Enter&gt;键触发。&#125;while(scanf(\"%s\",str)!=EOF)&#123;...&#125;while(gets(str)!=NULL)&#123;...&#125;//输入直到满足某个条件时退出while(scanf(\"%d%d\",&amp;a,&amp;b), a||b)&#123; ...//当a和b中有一个不为零时就进行循环。注意！输入多少数据(&amp;a和&amp;b)，判零条件就有几个(a||b)，否则输入输出的格式会出错。&#125;//输入题目指定组数的数据while(T--)&#123;...&#125; 另外要注意！多点测试中每一次循环都要重置一下变量和数组(memset函数或fill函数)，否则在下一组数据来临之前变量和数组的状态就不是初始状态了。 三、OJ常见评测结果1. 答案正确(Accepted, AC)若为单点测试，则每通过一组数据就会返回一个Accepted,若是多点测试，那么只有当通过了所有数据时，才会返回Accepted。 2. 编译错误(Compile Error, CE)出现这种情况有可能是选错了语言。 3. 答案错误(Wrong Answer, WA)代码逻辑问题或输出的内容有误。 4. 运行超时(Time Limit Excees, TLE)一般来说，导致该结果是由于算法的时间复杂度导致的，也可能是某组数据使得代码某处死循环了。 5. 运行错误(Runtime Error, RE)段错误(非法访问内存，如数组越界、指针乱指)、浮点错误(例如除数为0、模数为0)、递归爆栈(一般由于递归层数过深)。 6. 内存超限(Memory Limit Exceeded, MLE)如果程序使用太多空间，例如数组太大可能会导致此结果。 7. 格式错误(Presentation Error, PE)多输出了空格或换行。 8. 输出超限(Output Limit Exceeded, OLE)输出了过量的内容，如大量调试信息或者特殊数据导致的死循环。","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"},{"name":"C","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"}]},{"title":"Java基本语法","date":"2020-04-20T04:05:33.000Z","path":"2020/04/20/Java基础知识/Java基本语法/","text":"一、Java应用程序的结构1. 程序的组成123456public class FirstSample&#123; public static void main(String[] args) &#123; //要运行java程序，必须有一个main方法，public和static的位置可以互换，但其它部分位置固定 System.out.println(\"We will not use 'Hello, World!\"'); &#125; &#125; java区分大小写； public关键字为访问修饰符，用于控制程序的其他部分对这段代码的访问级別； 关键字 class 表明 Java 程序中的全部内容都包含在类中； class 后面紧跟类名，名字必须以字母开头，后面可以跟字母和数字的任意组合，采用驼峰命名法，不能使用java保留字； 源代码的文件名必须与public类的名字相同，并用 .java 作为扩展名。源文件可以包含多个类定义，但最多只能包含一个public类定义。可以没有public类定义，此时文件名可随意。 成功编译后会得到一个包含这个类字节码的文件。Java 编译器将字节码文件自动地命名为 ClassName. class, 并与源文件存储在同一个目录下。 运行已编译的程序时，Java 虚拟机将从指定类中的 main 方法开始执行,故在类的源文件中必须包含一个 main方法。 在 Java SE 1.4 及以后的版本中强制 main方法是 public 的。 Java 中的 main 方法必须是静态static的。 在 Java 中，每个句子必须用分号结束。特别需要说明，回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。 2. 注释123456789//单行注释/*比较长的一段话，注意不能嵌套*//***多行注释，可自动生成文档。***/ 二、8种基本数据类型4种整型，2种浮点型，1种用于表示 Unicode 编码的字符单元的字符类型 char和 1 种用于表示真值的 boolean 类型。 1. 整型 int：109以内； long：1010——1018，数值有一个后缀L或l； 二进制从Java7开始，要加上前缀0b或0B；八进制加前缀0(容易混淆数值，不推荐)；十六进制加前缀0x或0X； 从Java7开始还可以为数字字面量加下划线让程序更易读，Java编译器会去除这些下划线。如1_000_000或0b1111_0100_0010_0200_0000。 Java中所有的数值类型所占据的字节数量与平台无关，而C和C++会随着平台改变而改变。 注意!Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。 2. 浮点型2.1 两种浮点类型 float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。 也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。 绝大部分应用程序都采用 double 类型。在很多情况下，float 类型的精度很难满足需求。 可以使用十六进制表示浮点数值。例如，0.125=2—3可以表示成 0xl.0p-3。在十六进制表示法中， 使用 p 表示指数， 而不是 e。 注意， 尾数采用十六进制，指数采用十进制。指数的基数是 2。 2.2 浮点型的计算 所有的浮点数值计算都遵循 IEEE 754 规范。 三个特殊浮点值表示溢出和出错情况： 正无穷大(常量 Double.POSITIVE_INFINITY或Flocat.POSITIVE_INFINITY) 负无穷大(Double.NEGATIVE_INFINITY或Float.NEGATIVE_INFINITY) NaN(非数值，Double.NaN或Float.NaN):注意！所有非数值都认为是不相同的。 12if (x = Double.NaN) // is never true 错误判断方法if (Double.isNaN(x)) // check whether x is \"not a number\" 正确判断方法 浮点数值采用二进制系统表示，故无法精确表示1/10，如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal类 3. Unicode编码与字符编码表设计 Unicode 编码的目的是将世界不同地区的不同编码标准如美国的 ASCII、 西欧语言中的ISO 8859-1 俄罗斯的 KOI-8、 中国的 GB 18030 和 BIG-5 等统一起来，起初Unicode是固定的16位，而经过一段时间的发展，Unicode 字符超过了 65 536 个，其主要原因是增加了大量的汉语、 日语和韩语中的表意文字。为了解决这个问题，设计了不同的变长编码方式，如UTF-8和UTF-16，要理解这两种编码方式，必须首先理解Unicode码点等含义。码点：是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中，码点采用 U+十六进制 书写,Unicode 的码点可以分成 17 个代码级别，从U+10000 到 U+10FFFF。基本的多语言级别：码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；辅助字符级别：其余的 16个级别的码点从 U+10000 到 U+10FFFF , 其中包括一些辅助字符。 3.1 UTF-16字符编码表UTF-16 编码采用不同长度(2字节和4字节)的编码表示所有 Unicode 码点。在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元; 而辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的 2048 字节内， 通常被称为替代区域，其中 U+D800 ~ U+DBFF 用于第一个代码单元，U+DC00 ~ U+DFFF 用于第二个代码单元，而这些替代区域Unicode规定不对应与任何字符。这样设计十分巧妙，我们可以从中迅速地知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。参见https://zh.wikipedia.org/wiki/UTF-16#从U+0000至U+D7FF以及从U+E000至U+FFFF的码位UTF-16编码算法： 码位减去 0x10000，得到的值的范围为20比特长的 0…0xFFFFF。 高位的10比特的值（值的范围为 0…0x3FF）被加上 0xD800 得到第一个码元或称作高位代理，值的范围是 0xD800…0xDBFF。由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理。 低位的10比特的值（值的范围也是 0…0x3FF）被加上 0xDC00 得到第二个码元或称作低位代理，现在值的范围是 0xDC00…0xDFFF。由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理。 UTF-16编码示例： 3.2 UTF-8字符编码表UTF-8编码也采用不同字节编码所有Unicode码点(1字节-6字节)参见https://zhuanlan.zhihu.com/p/72254734UTF-16编码规则表：UTF-16编码示例：汉字「吕」的 Unicode 编码是 U+5415，对应二进制为 0101010000010101，总共有 15 位。因为两字节最多表示 11 位，三字节最多表示 16 位，所以使用三字节编码。对应二进制拆成（从低位到高位）三部分，分别是 0101, 010000, 010101，再拼上编码前缀得到 11100101, 10010000, 10010101，对应十六进制为 0xe5, 0x90, 0x95，这就是汉字「吕」的 UTF-8 编码。 4. char类型 char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。 char 类型的字面量值要用单引号括起来。 char 类型的值可以用转义序列\\u和十六进制值表示，其范围从 \\u0000 到 \\uffff。 除了转义序列 \\u 之外， 还有一些用于表示特殊字符的转义序列： 所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\\02122’ 或 “Hello\\n”。转义序列 \\u还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以。 Unicode 转义序列会在解析代码之前得到处理。123456public static void main(String\\u005B\\ u00SD args); //\\u005B 和 \\u005D 是 [ 和 ] 的编码。\"\\u0022+\\u0022\"; //\"\"+\"\" 即空串// \\u00A0 is a newline //\\u00A0为换行符，故会产生一个语法错误// Look inside c:\\users //也会产生一个语法错误， 因为 \\u 后面并未跟着 4 个十六进制数。 5. boolean类型boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件。要注意！整型值和布尔值之间不能进行相互转换。 三、变量1. 变量的声明 变量名必须是一个以字母开头并由字母或数字构成的序列。 需要注意，与大多数程序设计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括 ‘A’ ~ ‘Z’、 ‘a’ ~ ‘z’、或在某种语言中表示字母的任何 Unicode 字符。 但 V 和 ‘©’这样的符号不能出现在变量名中，空格也不行。可以使用 Character 类的isJavaldentifierStart 和 isJavaldentifierPart 方法来检查哪些 Unicode 字符属于 Java 中的“ 字母”。 另外， 不能使用 Java 保留字作为变量名。 12345int i,j; //不提倡int a;int b; //提倡，可读性强Box box;Box aBox; 2. 变量的初始化12345int vacationDays; //声明一个变量之后，必须用赋值语句对变量进行显式初始化,否则不能使用vacationDays=12; //可以将变量的声明和初始化放在同一行中。//在 Java 中可以将声明放在代码中的任何地方,但应尽可能地靠近变量第一次使用的地方。int vacationDays = 12; //在 Java 中， 不区分变量的声明与定义。 3. 常量12345final double CM_PER_INCH = 2.54; //关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。//类常量的定义位于 main 方法的外部。public static final double CM_PER_INCH = 2.54; //使用关键字 static final 可设置一个类常量,可使其在一个类中的多个方法中使用 //如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量，ClassName.常量名。 const 是 Java 保留的关键字，但目前并没有使用。 四、运算符+ - * / %加、减、乘、除、取余数 需要注意， 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。 在默认情况下， 虚拟机设计者允许对中间计算结果采用扩展的精度。但是， 对于使用 strictfp 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。 如果将一个类标记为strictfp, 这个类中的所有方法都要使用严格的浮点计算。1public static strictfp void main(String[] args) 1. 数学函数与数学常量123456789101112131415161718192021222324252627282930313233343536import static java.lang.Math.*; //静态导入Math包后，就不需要使用 Math.方法名 来调用了//解决负整数取余数问题的方法,n%2=-1，若n为负整数floorMod(position+adjustment,12); //（对于负除数，floorMod 会得到负数结果，不过这种情况在实际中很少出现。//三角函数方法static double sin(double a ) ： 返回角的三角正弦static double cos(double a) ： 返回角的三角余弦static double tan(double a) ： 返回角的三角正切static double asin(double a) : 返回角的反正弦static double acos(double a) : 返回角的反余弦static double atan(double a) ： 返回角的反正切static double toRadians(double a) : 将角转换为弧度static doueble toDegrees(double a) : 将弧度转化为角//指数函数方法static double exp(double a) : 用于获取e的a次方；static double log(double a) : 即lna;static double log10(double a) : 即log10a;static double sqrt(double a ):用于取a的平方根；static double cbrt(double a) : 用于取a的立方根；static double pow(double a, double b) : 用于求a的b次方；//取整函数方法static double ceil(double a)：返回大于等于a的整数值，返回值类型为double；static double floor(double a) : 返回小于等于a的整数值，返回值类型为double；static double rint(double a) : 返回与a最接近的整数值，返回值类型为double；（如果两个同为整数且同样接近，选取偶数值的那个）static double random( ):返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。//四舍五入函数static long round(double a ): 其值等于Math.floor(a + 0.5)，返回值类型为long;static int round(float a ): 其值等于Math.floor(a + 0.5)，返回值类型为int;//求绝对值运算和最值运算，这里的类型就是double，float，int和long类型static 类型 abs(类型); 返回对应类型的绝对值static 类型 max(类型1,类型2); 返回对应类型的最大值static 类型 min(类型1,类型2); 返回对应类型的最小值 2. 数值类型之间的合法自动转换其中6个实心箭头，表示无信息丢失的转换；有 3 个虚箭头，表示可能有精度损失的转换。当进行二元操作时，会将两个操作数自动转换为同一种类型，再进行计算，转换规则为： 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 否则， 两个操作数都将被转换为 int 类型。 3. 强制类型转换cast当存在信息丢失的可能时，需要进行强制类型转换才可以，比如long—&gt;int,强制类型转换会进行截断。 12(目标类型)变量; //不要在 boolean 类型与任何数值类型之间进行强制类型转换， 这样可以防止发生错误。b?1:0; //极少情况下使用 4. 结合赋值运算符+= -= *= /= %= 12int x;x += 3.5; //等价 (int)(x+3.5) 运算符得到一个值， 其类型与左侧操作数的类型不同， 就会发生强制类型转换。 5. 自增与自减运算符12345int n=12;n++; //由于这些运算符会改变变量的值，所以它们的操作数不能是数值。n-- //不推荐使用++,容易产生bug。++n;--n; 6. 关系运算符和boolean运算符 关系运算符：== != &lt; &gt; &lt;= &gt;= boolean运算符:&amp;&amp; || ! ?: 7. 位运算符&amp; | ^(异或) ~ &lt;&lt;(左移) &gt;&gt;(右移) 利用 &amp; 并结合使用适当的 2 的幂， 可以把其他位掩掉， 而只保留其中的某一位。 &gt;&gt;&gt; 运算符会用 0 填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。 移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作数模 64 )。 C/C++中&gt;&gt;对于负数生成的结果可能会依赖于具体的实现。Java 则消除了这种不确定性。 123(n &amp; (1 &lt;&lt; 3)) &gt;&gt; 3;1&lt;&lt;35; //等价8或者1&lt;&lt;3 8. 括号与运算符的优先级 9. 枚举类型用于变量的取值只在一个有限的集合内的情况。 12enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;; //定义枚举类型Size s = Size.MEDIUM; //声明变量，只能存储Size中给定的枚举值或null值，null 表示这个变量没有设置任何值。 五、字符串 Java 字符串就是 Unicode 字符序列。Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。每个用双引号括起来的字符串都是 String类的一个实例。String 类对象为不可变字符串，不能修改字符串中的任一字符，但是可以修改整个字符串变量，让它引用另外一个字符串。字符串存放在一个公共存储池(堆)中，字符串变量指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同的字符。即：编译器可以让字符串共享。Java 将自动地进行垃圾回收。 如果修改字符串变量后之前的字符串所占的一块内存不再使用了， 系统最终会将其回收。 1. String中的各种字符串操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849String greeting = \"Hello\";String expletive = \"Expletive\";//子串 substring方法String s = greeting.substring(0, 3); //\"Hel\"//拼接 +String message = expletive + greeting; //当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串（任何一个 Java 对象都可以转换成字符串）。nt age = 13;String rating = \"PC\" + age; //PG13System.out.println(\"The answer is \" + answer);//join方法：把多个字符串放在一起， 用一个定界符分隔String all = String.join(\" / \", \"S\", \"M\", \"L\", \"XL\"); //\"S / H / L / XL\"//修改字符串变量，达到修改字符的效果greeting = greeting.substring(0, 3) + \"p!\"; //共享享带来的高效率远远胜过于提取、 拼接字符串所带来的低效率。因为对字符串进行的操作往往只是比较。//检测字符串是否相等s.equals(t); \"Hello\".equals(greeting);\"Hello\".equalsIgnoreCase(\"hel1o\"); //判断是否相等而不区分大小写if (greeting.compareTo(\"Hel1o\") == 0)//检测字符串是否放置在同一个位置上greeting == \"Hello\"; //可能正确也可能错误，因为实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。int n = greeting.length(); //返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。int cpCount = greeting.codePointCount(0, greeting.length()); //得到实际的长度，即码点数量s.charAt(n); //返回位置 n 的代码单元int index = greeting.offsetByCodePoints(0, i); //得到第 i 个码点int cp = greeting.codePointAt(index); //遍历字符串的码点int[] codePoints = str.codePointsO.toArray();//把一个码点数组转换为一个字符串String str = new String(codePoints, 0, codePoints.length);//返回一个新字符串。 这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。String toLowerCase( )String toUpperCase( )//返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。String trim( )//返回一个新字符串。这个字符串用 newString 代替原始字符串中所有的 oldString。可以用 String 或 StringBuilder 对象作为 CharSequence 参数。String replace( CharSequence oldString,CharSequence newString) Java 中的 String类包含了 50 多个方法。详参https://docs.oracle.com/javase/8/docs/api/ 2. 空串与null串123456String e = \"\"; // 空串,它是长度为0的字符串，有自己的内容(空)String str=null; //这表示目前没有任何对象与该变量关联if (str == null) //检查一个字符串是否为 nullif (str != null &amp;&amp; str.length() != 0) //检查一个字符串既不是 null 也不为空串，注意！首先要检查 str 不为 null。因为如果在一个 mill 值上调用方法， 会出现错误。 3. 使用StringBuilder类构建字符串1234StringBuilder builder = new StringBuilder();builder.append(ch); // appends a single characterbui1der.append(str); // appends a stringString completedString = builder.toString(); StringBuffer是StringBuilder的前身，其效率稍有些低， 但允许采用多线程的方式执行添加或删除字符的操作。 如果所有字符串在一个单线程中编辑 （通常都是这样)，则应该用 StringBuilder 替代它。 六、输入输出1. 读取输入1234567891011121314151617181920212223242526import java.util.*; //当使用的类不是定义在基本java.lang 包中时，一定要使用import指示字将相应的包加载进来。//构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。Scanner in = new Scanner(System.in);//使用 Scanner 类的各种方法实现输入String name = in.nextLine(); //nextLine()可读入空白符String firstName = in.next(); //以空白符结束int age = in.nextlnt(); //读取一个整数double num = nextDouble(); //读取一个浮点数boolean hasNext( ) //检测输人中是否还有其他单词。//检测是否还有表示整数或浮点数的下一个字符序列。boolean hasNextInt()boolean hasNextDouble()//用Console类从控制台读取密码Console cons = System.console();String username = cons.readLine(\"User name: \")；char[] passwd = cons.readPassword(\"Password:\"); //为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素//显示字符串 prompt 并且读取用户输入，直到输入行结束。args 参数可以用来提供输人格式。有关这部分内容将在下一节中介绍。static char[] readPassword(String prompt, Object...args)static String readLine(String prompt, Object...args) 采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有能够读取一个单词或一个数值的方法。 2. 格式化输出123456double x = 10000.0 / 3.0;System.out.print(x);System.out.printf(\"%8.2f\", x); //Java SE5.0沿用了C中的printf方法用于对输出进行各种格式控制//使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出String message = String.format(\"Hello, %s. Next year, you'll be %d\", name , age); 还可以在printf中给出控制格式化输出的各种标志:printf方法中日期与时间的格式化选项，格式包括两个字母， 以 t 开始， 以表中的任意字母结束： 12345System.out.printf(\"%tc\", new Date()); //打印当前完整的日期和时间//使用格式化的参数索引System.out.printf(\"l$s %2$tB %2$te, %2$tY\", \"Due date:\", new DateQ); //%1$表示对第1个参数格式化， Due date: February 9, 2015System.out .printf(\"%s %tB %&lt;te, %&lt;tY\", \"Due date:\", new DateO); //&lt; 示前而格式说明中的参数将被再次使用 以上有关printf方法中日期与时间的格式化选项已过时，新代码应使用java.time 包中的方法。printf格式说明符的语法图：许多格式化规则是本地环境特有的。例如，在德国，组分隔符是句号而不是逗号，Monday 被格式化为 Montag,java可以控制控制应用的国际化行为。 3. 文件输入与输出1234567//若读取文件时不设置字符编码，则会使用运行该java程序的默认编码，若在不同的机器上运行可能会有不同的表现//可使用Scannner的任意方法对文件进行读取Scanner in = new Scanner(Paths.get(\"myfile.txt\"), \"UTF-8\"); //如果文件名中包含反斜杠符号，需要在每个反斜杠之前再加一个额外的反斜杠：“ c:\\\\mydirectory\\\\myfile.txt ”//写入文件//可以像输出到 System.out—样使用 print、 println 以及 printf命令。PrintWriter out = new PrintWriter(\"myfile.txt\", \"UTF-8\"); 如果用一个不存在的文件构造一个Scanner,或者用一个不能被创建的文件名构造一个PrintWriter,那么就会发生异常。Java 编译器认为这些异常比“被零除”异常更严重。 七、控制流程1. 块作用域 块，即复合语句，是由一对大括号括起来的若干条简单的 Java 语句。 一个块可以嵌套在另一个块中。 但是，不能在嵌套的两个块中声明同名的变量，否则无法通过编译。 123456&#123; int n; &#123; int k; &#125;&#125; 2. 条件语句123456789101112131415if(condition)&#123;...&#125;if(condition)&#123; ...&#125;else&#123; ...&#125;if(condition1)&#123; ...&#125;else if(condition2)&#123; ...&#125;else if(condition3)&#123; ...&#125; 3. 循环12345678910111213while(condition)&#123; ...&#125;do&#123; ...&#125;while(condition);for (int i = 1; i &lt;= 10; i++)&#123; ...&#125;for (double x = 0; x != 10; x += 0 .1) //由于浮点数的舍入误差，该循环永远不可能结束 4. switch语句12345678910111213141516171819202122232425switch (choice) &#123; //case标签范围：类型为 char、byte、 short 或 int 的常量表达式。 case 1: //枚举常量。 ... //从 Java SE 7开始， case 标签还可以是字符串字面量。 break; case 2: ... break; case 3: ... break; case 4: ... break; default: ... break; &#125;Size sz = . . .;switch (sz) &#123; case SMALL: // 无需使用Size.SMALL ... break; ...&#125; 5. 中断控制流程语句12345678910111213141516171819202122232425262728//不带标签的break语句，用于跳出当前循环while(c)&#123; ... break;&#125;//带标签的break语句，用于跳出多重嵌套的循环语句,也可以应用到任何语句中。//标签必须放在希望跳出的最外层循环之前， 并且必须紧跟一个冒号。read_data:while(...)&#123; for(...)&#123; ... break read_data; &#125;&#125;label:&#123; ... if(condition) break label; ...&#125;//continue语句跳过本次循环剩余部分，进入下一次循环for(...)&#123; ... break;&#125; 八、大数值Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算，类提供的方法参见java文档https://docs.oracle.com/javase/8/docs/api/。 12345import java.math.*Biglnteger a = Biglnteger.valueOf(100); //将普通的数值转换为大数值Biglnteger c = a.add(b); // c = a + bBiglnteger d = c.multiply(b.add(Biglnteger.valueOf(2))); // d = c * (b + 2) 大数值不能使用 + 和 * 与 C++ 不同， Java 没有提供运算符重载功能。 程序员无法重定义 + 和 * 运算符，虽然为字符串的连接重栽了+ 运算符，但没有重载其他的运算符。 九、数组1. 数组的创建/初始化/匿名数组123456789101112int[] a = new int[100]; //也可用int a[];声明数组，但是不推荐，创建一个数字数组则所有元素会被初始化为0boolean[] b = new boolean[100]; //元素初始化为 falseString[] names = new String[10]; //对象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。int actualSize = . . .;Employee[] staff = new Employee[actualSize]; //Java允许在运行时确定数组的大小。a.length; //获取数组中元素个数int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13 &#125;; //创建数组的同时进行初始化small Primes = new int[] &#123; 17, 19, 23, 29, 31, 37 &#125;; //匿名数组初始化，可以在不创建新变量的情况下重新初始化一个数组new elementType[0]; //创建一个长度为 0 的数组,与null不同。 如果经常需要在运行过程中扩展数组的大小， 应该使用数组列表（array list)。 2. 数组的for each循环1234for (int element : a) System.out.println(element);System.out.println(Arrays.toString(a)); //以[2,3,5,7,11,13]方式打印数组 3. 数组拷贝1234567int[] luckyNumbers = smallPrimes; //将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组luckyNumbers[5] = 12; //如果数组元素是数值型，那么多余的元素将被赋值为 0 ; //如果数组元素是布尔型，则将赋值为 false。//相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length*2); //将一个数组的所有值拷贝到一个新的数组中去,第二个参数为新数组大小，该方法常用来增加数组大小 java中没有指针运算，不能通过 a+1 得到数组的下一个元素。[]被预定义为检查数组边界。 4. 命令行参数main函数中的String[] args表明main 方法将接收一个字符串数组， 也就是命令行参数。 12345678public class Message&#123; public static void main(String[] args) &#123; ... &#125;&#125;//在命令行输入命令可读入内容到args数组中,程序名并没有存储在 args 数组中java Message -g cruel world //args[0]:\"-g\" args[l]:\"cruel\" args[2]:\"cruel\" \"world\" 4. 数组排序123456789101112131415import java.util.Arrays;static String toString(type[] a) //类型为 int、long、short、 char、 byte、boolean、float 或 double 的数组。static type copyOf(type[]a, int length)static type copyOfRange(type[]a , int start, int end)static void sort(type[] a) //采用优化的快速排序算法对数组进行排序。static int binarySearch(type[]a , type v) //采用二分搜索算法查找值 vstatic int binarySearch(type[]a, int start, int end, type v) //类型为 int、 long、 short、 char、 byte、 boolean 、 float 或 double 的有序数组。static void fill(type[]a , type v) //将数组的所有数据元素值设置为 Vstatic boolean equals(type[]a, type[]b) //如果两个数组大小相同， 并且下标相同的元素都对应相等， 返回 true。 5. 多维数组12345678910111213141516//创建double[][] balances = new double[100][100];int[][] magicSquare = &#123; &#123;16, 3, 2, 13&#125;， &#123;5, 10, 11, 8&#125;, (9, 6, 7, 12&#125;, &#123;4, 15, 14, 1&#125; &#125;;//遍历for (double[] row : a) for (double value : row) .......//快速打印System.out.println(Arrays.deepToString(a)); //输出[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]//交换二维数组中的两行double[] temp = balances[i];balances[i] = balances[i + 1];balances[i + 1] = temp; 6. 不规则数组12345//首先分配一个具有所含行数的数组int[][] odds = new int[NMAX + 1][];//接下来，分配这些行for (int n = 0; n &lt;= NMAX ; n++) odds[n] = new int[n + 1];","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"C和C++的常用语法","date":"2020-04-15T09:45:33.000Z","path":"2020/04/15/算法笔记/C和C++常用语法/","text":"在算法机试中，最适合使用的就是C语言和C++语言，C++可以向下兼容C，且其基本语法除了输入输出部分，其余顺序结构、循环结构、数组、指针都是几乎一样的。C++中的cin和cout消耗时间比C中的scanf和printf多得多，而C中有一些不太顺手的设定可以使用C++来取代，故我们在机试时通常选择C++的编译器，而混用C和C++的语法来优化算法。本篇简单介绍一下机试中常用的C/C++基本语法。 一、C程序的组成1234567#include &lt;stdio.h&gt;int main()&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\",a+b); return 0;&#125; 1.头文件#include &lt;stdio.h&gt;即是头文件，用来添加程序中需要使用到的库函数，其中stdio.h是标准输入输出库，是一个.h格式的文件，其中包含了一些与输入输出有关的东西，其他功能的库文件还有math.h，负责数学函数,string.h负责字符串相关函数，等等。当我们需要用到这些库函数时就必须将其头文件include起来。此外，C++中的等价写法为#include &lt;csdio&gt;,#include &lt;cmath&gt;,include &lt;cstring&gt;。 2.主函数12345int main()&#123; ... return 0;&#125; 主函数是一个程序的入口，也就是程序开始执行的地方，一个程序最多只能有一个主函数。注意！请不要在同一个程序中使用cout和printf，有时会出问题。 二、基本数据类型1. 变量的定义变量类型 变量名;变量类型 变量名 = 初值;变量名区分大小写。 2. 变量类型 2.1 整型短整型(short): 2Byte，机试中一般用不到。整型(int): 4Byte,绝对值在109范围内整数都可以定义为Int型。长整型(long long): 8Byte,赋值大于231-1的初值，需要在初值后面加上LL，否则编译错误。 2.2 浮点型单精度(float): 有效精度6-7位。双精度(double): 有效精度15-16位,因此机试中碰到浮点型一般都是用double来存储。 浮点数在经过容易损失精度得计算后，计算结果总是不精确得，有一定得误差，故需要引入一个极小数eps来修正误差，从而进行各种比较操作，可以取eps为10-8,变量b的浮动范围为[b-eps,b+eps],各种比较操作的宏定义如下： a==b: a&gt;b: a&lt;b: a&gt;=b: a&lt;=b: 123456789101112131415#include &lt;stdio.h&gt;#include &lt;math.h&gt;double db1=4*asin(sqrt(2)/2); //PI的损失精度的计算double db2=3*asin(sqrt(3.0)/2);db1==db2; //flase;const double pi=acos(-1); //定义piconst double eps=1e-8; //注意该用括号的地方用括号#define Equ(a,b) ((fabs((a)-(b)))&lt;(eps)) //a==b,不等于可使用!Equ(a,b)#define More(a,b) (((a)-(b))&gt;(eps)) //a&gt;b#define Less(a,b) (((a)-(b))&lt;(-eps)) //a&lt;b#define MoreEqu(a,b) (((a)-(b))&gt;(-eps)) //a&gt;=b#define LessEqu(a,b) (((a)-(b))&lt;(eps)) //a&lt;=b 2.3 字符型字符常量和字符变量: 1char c1 = 'z', c2 = 'j', c3 = 117; 字符常量统一使用ASCII编码，小写字母比大写字母码值大32。0-9（48-57），A-Z（65-90），a-z（97-122）。转义字符: \\n（换行）、\\t（Tab）、\\0（代表空字符NULL，其ASCII码为0，请注意\\0不是空格） 字符串常量: 1char str[25]=\"wo ai de ren ye ai wo\"; C语言中无基本数据类型可存储字符串常量，只能用字符数组，而C++中有string类型。 2.4 布尔型1bool flag1=0, flag2=true; bool在C++中可直接使用，在C中必须添加stdbool.h,但机试选择C++编译器，故可不添加。用整型赋值时true(非零)，false(零)。bool可以%d格式输出0或1。 3. 强制类型转换1(新类型名)变量名; 其中(int)f直接将小数部分切掉，即向下取整。在赋值时，编译器可以自动进行转换，但在计算过程中需要手动强制类型转换。 4. 符号常量和const常量(宏定义、宏替换)#define 标识符 常量 : 1#define pi 3.14 const 数据类型 变量名 = 常量; : 推荐方式。 1const double pi = 3.14; #define 标识符 任何语句或片段 : 不推荐。 1# difine ADD(a,b) ((a)+(b)) 由于宏定义是直接将对应部分替换然后进行编译和运行，故能加括号的地方应添加括号，否则会出现逻辑错误。 5. 运算符7个常用算术运算符 : + - * / % ++ --+ - * /优先级与四则运算相同， %和/优先级相同，且当/和%的除数为0时会导致程序异常退出或得到错误”1.#INF00”。6个关系运算符 : &lt; &gt; &lt;= &gt;= == !=3个逻辑运算符 : &amp;&amp; || ！1个条件运算符(c中唯一的三目运算符) : A ? B : C6个位运算符 : &lt;&lt;(左移) &gt;&gt;(右移) &amp;(位与) |(位或) ^(位异或) ~(位取反)运算符的优先级和结合性参见https://zh.cppreference.com/w/c/language/operator_precedence程序中无穷大的数INF的设置： 1const int INF = (1 &lt;&lt; 30) - 1; 或者 1const int INF = 0x3fffffff; 二者等价。 三、顺序结构1. 赋值表达式给多个变量赋值，可使用连续等号。 12int n, m;n = m = 5; 复合赋值运算符+= -= *= /= %=可以加快编译速度，提高代码可读性，故在程序中经常用到。 2. 使用C语言中的scanf和printf输入/输出2.1 scanf(“格式控制”,变量地址)123scanf(\"%d:%d:%d\",&amp;hh,&amp;mm,&amp;ss); //输入hh:mm:ssscanf(\"%d,%lf%c\",&amp;a,&amp;b,&amp;c); //输入a,b,cscanf(\"%d%d\",&amp;a,&amp;b); //输入a b scanf函数的格式控制符如下图所示： 格式控制和我们在控制台输入的格式一致。 &amp;为取地址符，char数组名本来就是一个地址，故不需要&amp;。 除了控制符%c可以读入一个空白符(空格、换行、Tab)以外,scanf的其他格式符的输入均以空白符为结束判断标志。 scanf中可以用转义字符，不过一般用不到。 2.2 printf(“格式控制”, 变量名称)1printf(\"%d\",n); printf函数的格式控制符如下图所示： printf中不使用&amp;。 注意double类型变量scanf的格式符为%lf,printf的格式符为%f。 printf中可使用转义字符\\n、\\t等。 12printf(\"%%\"); //输出%printf(\"\\\\\"); //输出\\ 3种实用的输出格式: %md &emsp;使不足m位的int变量以M位右对齐输出，高位空格补齐；若变量本身超过m位则保持原样。%0md &nbsp;相比于%md高位补0。%.mf &nbsp;使浮点数保留m位小数输出，使用“四舍六入五成双”规则，而不是四舍五入。 C++中的输入与输出函数cin与cout 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt; //string#include &lt;iomanip&gt; //控制double型精度using namespace std;cin&gt;&gt;n&gt;&gt;db&gt;&gt;c&gt;&gt;str;cout&lt;&lt;n&lt;&lt;\" \"&lt;&lt;db&lt;&lt;\" \"&lt;&lt;str&lt;&lt;\"haha\"&lt;&lt;\"\\n\"&lt;endl; //\"\\n\"和endl都表示换行char str[100];cin.getline(str,100); //读入一行string str; //使用C++中的string容器输入一行getline(cin,str);cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;123.4567&lt;&lt;endl; //控制double型变量输出小数点后两位。 cin与cout在输入/输出大量数据的情况下表现得非常糟糕，有时题目中数据还没有输入完毕就已经超时，故还是推荐使用scanf与printf输入与输出。 3. 使用getchar和putchar输入/输出字符getchar用来输入单个字符，注意它能够读入空白符，它经常使用在某些scanf使用不便的场合。putchar用来输出单个字符。 4. 注释123456//单行注释/*多行注释...*/ 编译时会自动跳过注释部分，不执行。 5. typedef用于给复杂的数据类型起一个别名，用别名代替原来的写法，提高编码效率。 1typedef long long LL; 6. 常用math函数除了abs在C编译器中需要添加stdlib.h外，其它数学函数使用时需要添加头文件math.h和cmath。注意! 123456789101112131415161718192021double fabs(double x); // double型变量取绝对值int abs(int x); //int型变量取绝对值double floor(double x); //向下取整double ceil(double x); //向上取整double pow(double x, double p); //返回x的p次方double sqrt(double x); //返回根号xdouble log(double x); //返回以自然对数e为底数的logx,c语言中没有对任意底数求对数的函数，只能使用此公式和换底公式来实现。double sin(double x); //三角函数,x必须为弧度制，如pi/2double cos(double x);double tan(double x);const double pi = acos(-1.0); double asin(double x); //反三角函数double acos(double x);double atan(double x);double round(double x); //对x四舍五入到整数位，以%d格式printf时需取整(int)double round(double x)&#123;return (x&gt;0.0) ? floor(x+0.5) : ceil(x-0.5);&#125; //有些编译器如PAT不支持round函数，可利用floor和ceil写一个。 四、选择结构1. if语句用于分支条件较少的情况。 123456789101112131415161718192021222324252627if(A)&#123; ...&#125;if(A)&#123; ...&#125;else&#123; ...&#125;if(A)&#123; ...&#125;else if(B)&#123; ...&#125;else&#123; ...&#125;if(A)&#123; //if语句嵌套 ... if(B)&#123; ... &#125; ...&#125;else&#123; ...&#125; 2. switch语句用于分支条件较多的情况。 12345678910111213switch(表达式)&#123; case 常量表达式1: ... break; case 常量表达式2; ... break; case 常量表达式n; ... break; default: ...&#125; 删除break则会从第一个匹配的case开始执行之后的所有语句。 五、循环结构1. while语句1234567while(A)&#123; //推荐 ...&#125;do&#123; ...&#125;while(A); //不推荐 2. for语句123for(A;B;C)&#123; //注意！C中A位置不允许定义变量而C++可以。 ...&#125; 3. break和continue语句break：跳出循环体。continue：跳出当前循环，即continue后面的代码不执行，直接进入下一轮循环。 六、数组如果数组大小较大（大概106级别），则需要将其定义在主函数外面，否则会使程序异常退出，因为函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的全局变量来自静态存储区，允许申请的空间较大。数组的长度计算： 1int length = sizeof(arr) / sizeof(arr[0]); //数组占内存总空间，除以单个元素占内存空间大小 1. 一维数组1数据类型 数组名[数组大小]; //数组大小必须是整数常量，不可以是变量。 初始化： 123int a[10]=&#123;1,2&#125;; //后面未被初始化的元素将根据编译器内部实现的不同而被赋以不同的初值（可能是很大的随机数），但一般默认为0。int a[10]=&#123;0&#125;;int a[10]=&#123;&#125;; 2. 二维数组1数据类型 数组名[第一维大小][第二维大小]; 初始化： 1int a[5][6]=&#123;&#123;1,2,3&#125;,&#123;&#125;,&#123;8,4&#125;&#125;; 3. 字符数组 初始化：12char str[15] = &#123;'G','o','o','d',' ','s','t','o','r','y','!'&#125;;char str[15] = \"Good story!\"; //直接赋值字符串，注意！仅限于初始化，程序其他位置不允许这样直接赋值整个字符串。 注意！定义了数组或字符指针之后，需要做一个初始化，否则里面将是随机值，以后将无法判断改字符串是否为空。123memset(数组名,‘\\0’,sizeof(数组名)); if (strlen(str) == 0) //推荐判空方式 if (str[0] == '\\0') /避免使用，容易crash 输入输出：12345678910char str[10];scanf(\"%c\",&amp;str[0]); //%c能读入空白符（空格，TAB，换行），%s以空白符为结束符。scanf(\"%s\",str);printf(\"%s\",str);str[0]=getchar(); //getchar()可以读入空白符。注意！在scanf(\"%s\\n\")和gets(str)之间应先使用getchar()吸收掉\\n，否则不能读取str,因为gets(str)以\\n为结束符。putchar(str[0]);gets(str); //gets()以换行符\\n为结束符，可以读入空格。PAT OJ中不支持gets()函数。puts(str); //输出一个字符串并紧跟换行 3. 字符数组的存放方式：每一个一维数组的末尾都有一个空字符\\0，占一位，表示存放的字符串的结尾，puts和printf就是通过识别\\0来输出字符串的。故在定义字符数组时长度一定要比实际存储字符串的长度至少多1。\\0在使用gets和scanf(“%s”)时会自动添加，其他的输入如getchar()则需要在字符串末尾手动添加\\0，否则puts和printf将由于无法识别字符串末尾而输出一大堆乱码。 4. memset——对数组中每一个元素赋相同的值12#include&lt;string.h&gt;memset(数组名，值，sizeof(数组名)); //速度快，但它是按字节赋值，即对每一个字节赋同样的值，故常用它赋0或-1不容易出错。 5. string.h头文件包含了很多关于字符数组的函数。 123456#include&lt;string.h&gt;int strlen(str); //返回字符数组中第一个\\0之前的字符的个数。int strcmp(str1,dtr2); //按字典序返回两个字符串大小的比较结果: 大于0的数(str1 &gt; str2)、返回0(str1 == str2)、小于0的数(str1 &lt; str2),返回值根据不同编译器处理而有不同的返回值，通常为1、0、-1。void strcpy(str1,str2); //将str2复制给str1，包括\\0。void strcat(str1,str2); //将str2拼接到str1的后面。 6. sscanf与sprintf处理字符串格式输入输出问题的利器。 1234567#include&lt;stdio.h&gt;sscanf(str, \"%d\", &amp;n); //将str中的内容以%d格式写入n中，从左至右。sprintf(str, \"%d\", n); //将n以%d格式写入字符数组str中，从右至左。sscanf(str, \"%d:%f,%s\",&amp;n1,&amp;n2,&amp;n3);sprintf(str, \"%d:%.2f,%s\",n1,n2,n3); sscanf还支持正则表达式，可解决字符串中的复杂问题。 七、函数1. 函数定义12345返回类型 函数名称(参数类型 参数)&#123; 函数主题&#125;void func(int c); //值传递,传入的是实参的一个副本，故不能改变实参的值 2. 以数组作为函数参数123void func(int a[], int b[][5]); //第一维度可不写长度，第二维度需要写明长度，可以再函数内部修改实参数组中的元素的值。func(a,b); //调用时只需要写数组名。 注意！数组可以作为函数的参数却不允许作为函数返回值，若想返回数组只有将返回的数组作为参数传入。函数可以嵌套调用，也可以递归调用。 八、指针C语言中用指针来表示内存地址，它是一个unsigned类型的整数，若这个内存地址恰好是某个变量的地址，则称这个指针指向该变量，变量的地址一般指它占用的字节中第一个字节的地址。在变量前加上取地址运算符&amp;即可得到变量的地址。 1. 指针变量指针变量用来存放指针。 1234567891011121314//定义和初始化int a,b;int* p=&amp;a; //C++写法，地址是赋值给p而不是*p的，*是类型的一部分。int *p1=&amp;b,p2; //C写法int *q1,*q2,*q3; //基类型(int)必须和指针变量存储的地址类型相同。char* str=\"I love china!\";*(str+1); //获得str+1位置的字符printf(\"%s\",a+n); //输出包括a+n位置及后面所有字符的字符串。//操作*p; //获得变量a的值，对*p的操作等同于对a操作。 p+1; //p所指的int型变量的下一个int型变量地址，跨越了一整个Int型(4Byte)。p++,p--;p1-p2; //2个指针之间相差的Int型变量的个数。 注意！若指针不进行初始化则指向的地址是随机的，而且很可能随机指向系统工作区，那么就会出错。 2. 使用指针变量作为函数参数使用指针变量作为函数参数时，在函数内部对指针变量(形参)本身进行修改并不能使传入的指针变量(实参)改变，因为传入的指针变量相当于传入一个副本，能够使实参改变的只能是该函数中对指针指向的数据进行的修改。 123456void swap(int* m, int* n)&#123; int temp=*m; *m=*n; *n=temp;&#125;swap(p,p1); 3. 引用引用(&amp;，区分取地址符)可以不使用指针，也能达到修改传入参数的目的，且引用不产生副本，而是给原变量(而不是常量，常量不可使用引用)起了个别名，故旧名字与新名字指向同一个东西，对引用变量的操作就是对原变量的操作。 12void func(int &amp;x);func(p2); 指针的引用：通过将指针的引用作为形参，从而达到将传入的地址交换以交换两个变量的结果。 1234567void swap(int* &amp;m, int* &amp;n)&#123; int* temp=m; m=n; n=temp;&#125;swap(p,p1); //swap(&amp;p,&amp;p1)写法错误，因为&amp;p,&amp;p1为常量，而常量不可使用引用。 九、结构体(struct)的使用需要将一些相关的变量放在一起存储时，需要用到结构体。 123struct Name &#123; //一些基本的数据结构或自定义的数据类型。&#125;结构体变量名; 1. 结构体的定义123456789struct StudentInfo &#123; int id; char gender; char name[20]; char major[20]; StudentInfo* next; //结构体内不能定义自己，会引起循环定义问题，但可以定义自身类型的指针变量，它可以定义除自身外的任何数据类型。注意！结构体指针变量不能在匿名结构体内定义。&#125;Alice,stu[1000]; //直接定义结构体变量StudentInfo Bob,*p; 2. 访问结构体内的元素12345678910stu[0].id;stu[0].gender;(*p).id;(*p).name;(*p).next;p-&gt;id;p-&gt;name;p-&gt;next; 3. 结构体的初始化和赋值结构体使用构造函数来进行初始化，对于一个普通定义的结构体，其内部会生成一个默认构造函数(但不可见)，如studentInfo(){}，正是由于默认构造函数的存在才可以直接定义结构体变量而不进行初始化，因为它没有让用户提供任何初始化参数。 1234567891011121314struct StudentInfo&#123; int id; char gender; StudentInfo(int _id, char _gender)&#123; //自定义构造函数 id=_id; gender=_gender; &#125; StudentInfo(int _id, char _gender): id(_id), gender(_gender) &#123;&#125; //构造函数的简化写法&#125;stu[3]=&#123;1,'M',2,'F'&#125;;StudentInfo stu = StudentInfo(10086,'M'); //初始化结构体stu[2]=stu; //C++中相同类型结构体之间可以直接赋值，而C语言中不可以。 注意！若自定义了构造函数而不想进行初始化，则需要手动添加默认构造函数。只要参数和类型不完全相同，就可以定义任意多个构造函数，以适应不同的初始化场合。 4. 共用体共用体可定义在结构体内部，用于建立有不同类型数据组成的组合型的数据结构。原则上，共用体的大小取决于占据最多内存的成员的长度，但会受到最宽基本类型成员大小的影响。即:共用体的总大小为共用体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。 12345678union MyUnion&#123; int i; char chs[11];&#125;u = &#123; 10 &#125;, u2 = &#123;.chs=\"niko\"&#125;; // 初始化;union MyUnion mu = &#123; 1 &#125;; // 默认初始化第一个成员union MyUnion mu2 = &#123; .chs = \"hello\" &#125;; // 指定要初始化的成员","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"},{"name":"C","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"}]},{"title":"SpringMVC","date":"2019-02-20T04:05:33.000Z","path":"2019/02/20/Spring实战/SpringMVC/","text":"","tags":[{"name":"java","slug":"java","permalink":"https://sunnyyi.github.io/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://sunnyyi.github.io/tags/Spring/"}]}]