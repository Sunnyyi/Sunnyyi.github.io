[{"title":"Java内存区域与内存溢出异常","date":"2020-06-01T04:05:33.000Z","path":"2020/06/01/Java虚拟机/自动内存管理/Java内存区域与内存溢出异常/","text":"一、运行时的数据区域 1. 程序计数器 程序计数器是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器。 它是程序控制流的指示器,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成。 每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为线程私有的内存。 2. Java虚拟机栈 Java虚拟机栈也是线程私有的,它的生命周期与线程相同。 虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候,Java虚拟机都会同步创建一个栈帧用于存储局部变量表,操作数栈,动态连接,方法出口等信息。 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型,对象引用和returnAddress 类型(指向了一条字节码指令的地址)。 这些数据类型在局部变量表中的存储空间以局部变量槽来表示,其中64位长度的long和 double类型的数据会占用两个变量槽,其余的数据类型只占用一个。 局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在栈帧中分配多大的（指变量槽的个数）局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小。 虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特,64个比特,或者更多)来实现一个变量槽完全由具体的虚拟机实现自行决定。 该区域会出现两类异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展,当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 3. 本地方法栈本地方法栈的Java虚拟机栈实现的功能类似，只不过本地方法栈则是为虚拟机使用到的本地(Native) 方法服务的，本地方法栈中方法使用的语言,使用方式与数据结构并没有任何强制规定,因此具体的虚拟机可以根据需要自由实现它。 4. Java堆 对于Java应用程序来说,Java堆是虚拟机所管理的内存中最大的一块，又称为GC堆（Garbage Collected Heap）。 它是线程共享的，在虚拟机启动时创建，只能存放对象实例。 从分配内存的角度看,所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer,TLAB),以提升对象分配时的效率。 Java堆可以物理不连续但必须逻辑连续，可被实现为固定大小也可以是扩展的，若在Java堆中没有内存完成实例分配,并且堆也无法再 扩展时,Java虚拟机将会抛出OutOfMemoryError异常。 5. 方法区 方法区是线程共享的，用于存储已被虚拟机加载的类型信息,常量,静态变量,即时编译器编译后的代码缓存等数据。 方法区不需要连续的内存，可以选择固定大小或者可扩展,甚至还可以选择不实现垃圾收集。 对该区域的垃圾收集目标主要是针对常量池的回收和对类型的卸载，若对此区域未完全回收则会导致内存泄漏。 如果方法区无法满足新的内存分配需求时,将抛出OutOfMemoryError异常。 6. 运行时常量池 Class文件中除了有类的版本,字段,方法,接口等描述信息外,还有一项信息是常量池表,用于存放编译期生成的各种字面量与符号引用,这部分内容将在类加载后存放到方法区的运行时常量池中。 除了保存Class文件中描述的符号引用外,还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。 运行时常量池具备动态性，即不要求常量一定只有编译期才能产生,运行期间也可以将新的常量放入池中。 二、直接内存 NIO(New Input/Output)类是一种基于通道与缓冲区的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。 本机直接内存的分配不会受到Java堆大小的限制，但仍然受本机总内存大小以及处理器寻址空间的限制，当各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现 OutOfMemoryError异常。 三、HotSpot虚拟机对象探秘1. 对象的创建 当Java虚拟机遇到一条字节码new指令时，首先检查该指令参数是否能在常量池中定位到一个类的符号引用，并检查其代表的类是否已被加载,解析和初始化过，如果没有,那必须先执行相应的类加载过程。 类加载检查通过后,虚拟机将为新生对象分配内存（大小在类加载完后即可完全确定）: 指针碰撞方式：假设Java堆中内存是绝对规整的，就把分界点指示器指针向空闲空间方向挪动一段与对象大小相等的距离。空闲列表方式：假设使用的内存和空闲的内存相互交错在一起,则虚拟机就维护一个列表,记录哪些内存块是可用的,在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表记录。 使用哪种方式取决于Java堆所采用的垃圾收集器是否带有空间压缩整理的能力3. 内存分配必须保证原子性： 比较并替换（Compare and substitute，CAS）加上失败重试的方式 本地线程分配缓冲(线程本地分配缓冲区，TLAB)：为每个线程在Java堆中预先分配一小块内存TLAB, 则在需要内存时直接在线程的本地缓冲中分配，只有当本地缓冲区用完了才需要同步锁定来安全分配内存。 内存分配完成之后,虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，以保证对象的实例字段在Java代码中可以不赋初始值就直接使用。 最后虚拟机在对象头中设置一些必要信息，如这个对象是哪个类的实例,如何才能找到类的元数据信息,对象的哈希码(实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算),对象的GC分代年龄等信息. 至此从虚拟机的视角来看,一个新的对象已经产生了，但从Java程序的视角看来,还需要再执行 ()方法后对象才算构造完成。 2. 对象的内存布局对象在堆内存中的存储布局包括三个部分：对象头、实例数据和对齐填充。 2.1 对象头 用于存储对象自身的运行时数据Mark Word：哈希码,GC分代年龄,锁状态标志,线程持有的锁,偏向线程ID,偏向时间戳,32bit或64bit; 类型指针:对象指向它的类型元数据的指针,Java虚拟机通过这个指针来确定该对象是哪个类的实例,并非所有的虚拟机实现都必须在对象数据上保留类型指针,因为查找对象的元数据信息并不一定要经过对象本身。 如果对象是一个Java数组,那在对象头中还必须有一块用于记录数组长度的数据。 2.2 实例数据 实例数据部分是对象真正存储的有效信息,无论是从父类继承下来的,还是在子类中定义的字段都必须记录起来。 存储顺序受到虚拟机分配策略参数(-XX：FieldsAllocationStyle参数，默认为true)和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary对象指针，OOP),即相同宽度的字段总是被分配到一起存 放,在此前提下,在父类中定义的变量会出现在子类之前。 如果HotSpot虚拟机的 +XX：CompactFields参数值为true(默认就为true),那子类之中较窄的变量也允许插入父类变量的空隙之中,以节省出一点点空间。 2.3 对齐填充由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，即任何对象的大小都必须是8字节的整数倍，而对象头部分已经被精心设计成正好是8字节的倍数,因此,如果对象实例数据部分没有对齐的话,就需要通过对齐填充来补全。 3. 对象的访问定位创建完对象后Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种。 3.1 句柄访问 reference中存储的是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自具体的地址信息。 使用句柄访问对象的优点是reference中存储的是稳定句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针而无需修改reference。 3.2 直接指针访问 reference中存储的直接就是对象地址,Java堆中对象的内存布局还必须考虑如何放置访问类型数据的相关信息。 最大的好处就是速度更快,它节省了一次指针定位的时间开销。 虚拟机HotSpot主要使用直接指针方式进行对象访问。 四、 实战：OutOfMemoryError异常 通过实战可验证运行时数据区域存储的内容。 当遇到实际的内存溢出异常时,能根据异常的提示信息迅速得知是哪个区域的内存溢出,溢出的原因以及相应的处理方法。 1. Java堆溢出1.1 溢出原因 IDEA中设置虚拟机参数:run-&gt;Edit Configurations-&gt;VM options: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError； 限制Java堆的大小为20MB,不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数 设置为一样即可避免堆自动扩展);通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析。 不断创建对象并避免垃圾收集机制清除这些对象，当触及设定的最大堆容量限制后就会产生内存溢出异常。 控制台错误输出信息： 123java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid13516.hprof ...Heap dump file created [28164792 bytes in 0.104 secs] 123while (true) &#123; list.add(new OOMObject());&#125; 1.2 分析和解决的方法 使用内存映像分析工具（IDEA可以使用插件viaualvm分析）对Dump出来的堆转储快照进行分析，查看是出现了内存泄漏还是内存溢出。 若为内存泄漏，则利用工具根据泄漏对象的类型信息以及它到GC Roots引用链的信息比较准确地定位到这些对象创建的位置,进而找出产生内存泄漏的代码的具体位置。 若为内存溢出(比如申请了一个integer,但给它存了long才能存下的数)，则应适当调整Java虚拟机的堆参数大小，然后检查代码中是否存在某些对象生命周期过长,持有状态时间过长,存储结构设计不合理等情况。 2 虚拟机栈和本地方法栈溢出 使用-Xss128K参数减少栈内存容量或定义大量的本地变量,增大此方法帧中本地变量表的长度. 无论是由于栈帧太大还是虚拟机栈容量太小,当新的栈帧内存无法分配的时候, HotSpot虚拟机抛出的都是StackOverflowError异常，因为HotSpot是不允许动态扩展栈容量大小的虚拟机。1234public void stackLeak() &#123; stackLength++; stackLeak();&#125; 3. 方法区和运行时常量池溢出3.1 运行时常量池溢出 设置参数-XX:PermSize=6M -XX:MaxPermSize=6M来限制永久代的大小以间接限制其中常量池的容量。 在jdk6中String.intern()方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储,返回的也是永久代里面这个字符串实例的引用 在jdk7中原本存放在永久代的字符串常量池被移至Java堆之中，故intern()方法只需要在常量池里记录一下首次出现的实例引用即可。 注意！字符串”java”在加载sun.misc.Version这个类的时候就进入常量池的,因此不属于第一次出现。 在JDK8以后,永久代便完全退出了历史舞台,元空间作为其替代者登场。12345678910111213141516//// 使用Set保持着常量池引用，避免Full GC回收常量池行为//jdk6中会产生溢出，jdk7中不会溢出Set&lt;String&gt; set = new HashSet&lt;String&gt;(); // 在short范围内足以让6MB的PermSize产生OOM了 short i = 0; while (true) &#123; set.add(String.valueOf(i++).intern()); &#125;//String.intern()返回引用的测试//在jdk6中将返回2个flase，而在jdk7及以上则得到一个true和一个flaseString str1 = new StringBuilder(\"计算机\").append(\"软件\").toString();System.out.println(str1.intern() == str1);String str2 = new StringBuilder(\"ja\").append(\"va\").toString();System.out.println(str2.intern() == str2); 3.2 方法区溢出 若在运行时产生的大量的类填满了方法区，方法区就会产生溢出，当前流行的很多主流框架如Spring，Hibernate在对类进行增强时(用到了CGLib这类字节码技术)就很容易溢出。 很多运行于Java虚拟机上的动态语言(例如Groovy等)通常都会持续创建新类型来支撑语言的动态性, 因此也容易出现方法区溢出场景。 大量JSP或动态产生JSP文件的应用(JSP第一次运行时需要编译为Java类),基于OSGi的应用(即使是同一个类文件,被不同的加载器加载也会视为不同的类)等也容易产生方法区的溢出。设置虚拟机参数的解决方法： -XX: MaxMetaspaceSize: 设置元空间最大值,默认是-1,即不限制,或者说只受限于本地内存大小; -XX: MetaspaceSize: 指定元空间的初始空间大小,以字节为单位,达到该值就会触发垃圾收集进行类型卸载,同时垃圾收集器会对根据垃圾收集情况对该值进行自适应调整； -XX: MinMetaspaceFreeRatio: 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比,可减少因为元空间不足导致的垃圾收集的频率。 -XX: Max-MetaspaceFreeRatio: 用于控制最 大的元空间剩余容量的百分比。 4. 本机直接内存溢出 由直接内存导致的内存溢出,一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况,如果读者发现内存溢出之后产生的Dump文件很小,而程序中又直接或间接使用了 DirectMemory(典型的间接使用就是NIO类)。 使用DirectByteBuffer分配内存也会抛出内存溢出异常,但它抛出异常时并没有真正向操作系统申请分配内存,而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常,真正申请分配内存的方法是Unsafe::allocateMemory()。 直接内存(Direct Memory)的容量大小可通过-XX：MaxDirectMemorySize参数来指定,如果不去指定,则默认与Java堆最大值(由-Xmx指定)一致。123456Field unsafeField = Unsafe.class.getDeclaredFields()[0];unsafeField.setAccessible(true);Unsafe unsafe = (Unsafe) unsafeField.get(null);while (true) &#123; unsafe.allocateMemory(_1MB);&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://sunnyyi.github.io/tags/JVM/"}]},{"title":"Java中的并发","date":"2020-05-27T04:05:33.000Z","path":"2020/05/27/Java基础知识/Java中的并发/","text":"多进程程序中的每一个进程都拥有自己的一整套变量，而线程则共享数据，共享变量使线程之间的通信比进程之间的通信更有效、 更容易，且在有的操作系统中线程更加轻量级。在实际应用中有很多地方都用到了多线程，例如一个浏览器可以同时下载几幅图片等等。 一、创建线程12345678910111213141516171819202122232425//在一个单独的线程中执行一个任务的简单过程Runnable r = () -&gt; //1. 将任务代码移到实现了 Runnable 接口的类的 run 方法中,由于 Runnable 是一个函数式接口，可以用 lambda 表达式建立一个实例&#123; try &#123; for (int i = 1; i &lt;= STEPS; i ++) &#123; ball.move(comp.getBounds()); comp.repaint(); Thread.sleep(DELAY); //休眠给定的毫秒数，以阻塞线程 &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;;Thread t = new Thread(r); //2. 由 Runnable 创建一个 Thread 对象t.start(); //3. 启动线程//函数式接口Runnablepublic interface Runnable&#123; void run(); &#125; 二、中断线程 当线程的 run 方法执行方法体中最后一条语句后， 并经由执行 return 语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。 没有可以强制线程终止的方法，但是有方法可以用来请求终止线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//不断检查当前线程是否被中断Runnable r = () -&gt; &#123; try &#123; while (!Thread.currentThread().islnterrupted() &amp;&amp; more work to do) &#123; do more work &#125; &#125; catch(InterruptedException e) &#123; // thread was interr叩ted during sleep or wait &#125; finally &#123; cleanup,if required &#125; // exiting the run method terminates the thread&#125;;//对InterruptedException 异常的处理//在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。void mySubTask()&#123; ... try &#123; sleep(delay); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; ...&#125;//用 throws InterruptedException 标记你的方法， 让调用者（或者， 最终的 run 方法）去捕获这一异常。void mySubTask() throws InterruptedException&#123; ... sleep(delay); ...&#125;void interrupt() //向线程发送中断请求。线程的中断状态将被设置为 true。如果目前该线程被一个 sleep调用阻塞，那么，InterruptedException 异常被抛出。 static boolean interrupted() //测试当前线程（即正在执行这一命令的线程）是否被中断。注意，这是一个静态方法。这一调用会产生副作用—它将当前线程的中断状态重置为 false。 boolean isInterrupted() //这是一个实例方法，测试线程是否被终止。不像静态的中断方法，这一调用不改变线程的中断状态。 static Thread currentThread() //返回代表当前执行线程的 Thread 对象。 三、线程状态（6种） New (新创建） Runnable (可运行） Blocked (被阻塞） Waiting (等待） Timed waiting (计时等待） Terminated (被终止） 线程状态间的转换： 1Thread.State getState() //得到这一线程的状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING或 TERMINATED 之一。 1. 新创建线程在newThread(r)之后还未运行之前，还有一些基础工作要做，这个状态称为new状态，即新创建状态。 2. 可运行线程 一旦调用 start 方法，线程就处于 runnable 状态。 然而为了让其它线程获得运行机会，运行中的线程可能被中断，线程调度的细节依赖于操作系统提供的服务(抢占式调度或协作式调度)。 现在所有的桌面以及服务器操作系统都使用抢占式调度（时间片和优先级调度），像手机这样的小型设备可能使用协作式调度（线程只有在调用 yield 方法、 或者被阻塞或等待时，线程才失去控制权。） 故在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。 3. 被阻塞线程和等待线程 当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。 线程转换为被阻塞状态或等待状态的时机： 当一个线程试图获取一个内部的对象锁而该锁被其他线程持有，则该线程进入阻塞状。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用 Object.wait 方法或 Thread.join 方法， 或者是等待 java.util.concurrent 库中的 Lock 或 Condition 时， 就会出现这种情况。注意等待和阻塞状态是不同的。 有几个方法有一个超时参数。调用它们导致线程进入计时等待（ timed waiting ) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 Thread.sleep 和 Object.wait、Threadjoin、 Lock.tryLock 以及 Condition.await 的计时版。 4. 被终止的线程线程被终止的两个原因： 因为 run 方法正常退出而自然死亡。 因为一个没有捕获的异常终止了 run 方法而意外死亡。 四、线程属性1. 线程优先级 在 Java 程序设计语言中，每一个线程有一个优先级。 默认情况下，一个线程继承它的父线程的优先级。可以用 setPriority 方法提高或降低任何一个线程的优先级。 可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。一般使用 NORM_PRIORITY （默认优先级，被定义为 5）。 线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上。 1static void yield( ) //导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。注意，这是一个静态方法。 2. 守护线程（daemon） 守护线程的唯一用途是为其他线程提供服务。 当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。 守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。 1void setDaemon( boolean isDaemon ) //标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。 3. 未捕获异常处理器 线程的 run方法不能抛出任何受查异常，不需要任何 catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。 该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类。 12345678910//设置或获取未捕获异常的默认处理器。static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler() //设置或获取未捕获异常的处理器。如果没有安装处理器，则将线程组对象作为处理器。void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandlerhandler)Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()//Thread.UncaughtExceptionHandler 接口中的唯一方法void UncaughtException(Thread t, Throwable e) //当一个线程因未捕获异常而终止， 按规定要将客户报告记录到日志中。 五、同步1. 竞争条件往往线程中的某个修改操作不是原子操作，则当线程1在计算的过程中被剥夺运行权，并在线程2修改完成同一项内容后被唤醒时，线程1对该项做的修改就会擦除线程2对该项做出的修改，此时程序就会出现错误。如果能够确保线程在失去控制之前方法运行完成，那么程序就不会因为竞争条件而产生错误。指令accounts[to] += amount;就不是一个原子操作： 将 accounts[to] 加载到寄存器。 增加 amount。 将结果写回 accounts[to]。 2. 锁对象（ReentrantLock） ReentrantLock 保护代码块的结构确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞，直到第一个线程释放锁对象。 必须在finally子句中包括解锁 unlock 操作，如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。 如果使用锁，就不能使用带资源的 try 语句。 加了锁的类的每一个对象都有自己的 ReentrantLock 锁对象。 锁是可重入的， 因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对 lock 方法的嵌套调用，当该计数为0时，线程才释放锁。 123456789101112131415161718192021222324252627282930313233343536373839//用 ReentrantLock 保护代码块的基本结构myLock.lock(); // a ReentrantLock objecttry&#123; 临界区 //临界区的代码要仔细设计，避免因为异常的抛出而跳出临界区，否则finally 子句释放锁之后会使对象可能处于一种受损状态&#125;finally&#123; myLock.unlock(); // 确保锁被释放，即使抛出异常&#125;//应用：使用一个锁来保护 Bank 类的 transfer 方法public class Bank&#123; //构建一个可以被用来保护临界区的可重入锁对象。 private Lock bankLock = new ReentrantLock(); // ReentrantLock 实现了 Lock 接口 ... public void transfer(int from, int to, int amount) &#123; //获取这个锁；如果锁同时被另一个线程拥有则发生阻塞。 bankLock.lock(); try &#123; System.out.print(Thread.currentThread()); accounts[from] -= amount; System.out.printf(\" %10.2f from %d to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\", getTotalBalance()); //transfer 方法调用 getTotalBalance 方法，这也会封锁 bankLock 对象，此时 bankLock对象的持有计数为 2。 &#125; finally &#123; //释放这个锁。 banklock.unlock(); &#125; &#125;&#125;ReentrantLock(boolean fair) //构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以， 默认情况下， 锁没有被强制为公平的。 3. 条件对象 线程进入临界区后发现需要满足某一条件之后才能执行，但由于判断条件和执行语句之间可能被其它线程打断，故为了避免错误需要使用一个条件对象来管理这些线程。 使用条件对象的await方法使当前需要某条件的线程阻塞并放弃锁。 等待获得锁的线程和调用 await 方法的线程存在本质上的不同。一旦一个线程调用 await 方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的 signalAll 方法时为止。 当调用条件对象的signalALL方法时会重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从 await 调用返回， 获得该锁并从被阻塞的地方继续执行。 如果所有其他线程被阻塞， 最后一个活动线程在解除其他线程的阻塞状态之前就调用 await 方法，那么它也被阻塞，这会导致死锁现象，并使该程序被挂起。 经验上讲，在对象的状态有利于等待线程的方向改变时调用 signalAll。 条件对象的另一个方法 signal, 是随机解除等待集中某个线程的阻塞状态。这更加有效，但存在危险。如果随机选择的线程发现自己仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用 signal, 那么系统就死锁了。 当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用 await、signalAll 或signal 方法。 锁可以拥有一个或多个相关的条件对象。 12345678910111213141516171819202122232425public class Bank&#123; private final double[] accounts = new double[n]; private Lock bankLock = new ReentrantLock(); private Condition sufficientFunds = = bankLock.newCondition(); public void transfer(int from, int to, double amount) throws InterruptedException &#123; bankLock.lock(); try &#123; while (accounts [from] &lt; amount) sufficientFunds.await(); //等待满足某条件 System.out.print(Thread.currentThread()); accounts[from] -= amount; System.out.printf(\" %10.2f from %d to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\", getTotalBalance()); sufficientFunds.signalAll(); //释放所有等待集 &#125; finally &#123; bankLock.unlock(); &#125;&#125; 4. synchronized 关键字(内部对象锁) 从 1.0 版开始，Java中的每一个对象都有一个内部锁和一个内部条件。如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。 内部对象锁只有一个相关条件。wait 方法添加一个线程到等待集中，notifyAll/notify 方法解除等待线程的阻塞状态。 将静态方法声明为 synchronized 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁，且没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。 实际应用中应尽量使用synchronized 关键字，只有在特别需要 Lock/Condition 结构提供的独有特性时，才使用 Lock/Condition。 12345678910111213141516171819202122232425262728293031323334//内部锁的基本结构,以下两种结构等价public synchronized void method()&#123; method body&#125;public void method()&#123; this.intrinsicLock.lock(); try &#123; method body &#125; finally &#123; this.intrinsicLock.unlock(); &#125; &#125;//应用class Bank&#123; private double[] accounts; public synchronized void transfer(int from，int to, int amount) throws InterruptedException &#123; while (accounts[from] &lt; amount) wait(); // 类似await accounts[from] -= amount ; accounts[to] += amount ; notifyAll();// 类似signalAll &#125; public synchronized double getTotalBalance() &#123; . . . &#125; &#125; 5. 同步阻塞通过进入一个同步阻塞也可以获得每个java对象持有的锁。 12345678910111213141516//基本结构synchronized (obj) //获得obj的锁&#123; critical section&#125;//应用public void transfer(Vector&lt;Double&gt; accounts, int from, int to, int amount) &#123; synchronized (accounts) &#123; accounts.set(from, accounts.get(from) - amount); accounts.set(to, accounts.get(to) + amount); &#125; Systen.out.print1n(. . .); &#125; 6. 监视器概念 监视器可以在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性，可用synchronized 关键字来实现。 监视器应满足如下特性： 监视器是只包含私有域的类。 每个监视器类的对象有一个相关的锁。 使用该锁对所有的方法进行加锁。换句话说，如果客户端调用 对象的某个方法, 那么对象的锁是在方法调用开始时自动获得， 并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时， 没有其他线程能访问该域。 该锁可以有任意多个相关条件。 7. Volatile 域 volatile 关键字为实例域的同步访问提供了一种免锁机制。 如果声明一个域为 volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。 Volatile 变量不能提供原子性，不能保证读取、 翻转和写入不被中断，故该变量只用于原子操作时可声明为Volatile。 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 8. final 变量还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时。 1final Map&lt;String, Double&gt; accounts = new HashKap&lt;&gt;(); //其他线程会在构造函数完成构造之后才看到这个 accounts 变量。否则不能保证其他线程看到的是 accounts 更新后的值，它们可能都只是看到 null , 而不是新构造的 HashMap。 9. 原子性123456789101112131415public static AtomicLong nextNumber = new AtomicLong(); long id = nextNumber.incrementAndGet(); //以原子方式将 AtomicLong 自增，并返回自增后的值。do &#123; oldValue = largest.get(); newValue = Math.max (oldValue , observed); &#125;while (llargest.compareAndSet(oldValue, newValue)); //如果另一个线程也在更新 largest，就可能阻止这个线程更新。这样一来，compareAndSet会返回 false, 而不会设置新值。//lambda 表达式更新变量largest.updateAndGet(x -&gt; Math .max(x, observed));largest.accumulateAndCet(observed, Math::max);//累加LongAccumulator adder = new LongAccumulator(Long::sum, 0); adder.accumulate(value); 10. 死锁 锁和条件不能解决多线程中的所有问题，在程序运行的过程中有可能所有的线程都会被阻塞，这样的状态就称为死锁，当程序进入死锁状态时程序就会被挂起。 当程序挂起时，键入 CTRL+\\, 将得到一个所有线程的列表。每一个线程有一个栈踪迹，告诉你线程被阻塞的位置。 Java 编程语言中没有任何东西可以避免或打破这种死锁现象。只能仔细设计程序，以确保不会出现死锁。 11. 线程局部变量由于在线程间共享变量有死锁的风险，且使用同步机制会产生很大的开销，故对于那些不需要共享的变量就可以使用线程局部变量为各个线程提供各自的实例。 123456//使用ThreadLocal辅助类构造SimpleDateFormat的线程局部变量public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat =ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(\"yyyy-MM-dd\"));String dateStamp = dateFormat.get().format(new Date());//使用ThreadLocalRandom类为各个线程提供一个单独的随机数生成器int random = ThreadLocalRandom.current().nextlnt(upperBound); //ThreadLocalRandom.current() 调用会返回特定于当前线程的 Random 类实例。 12. 锁测试与超时1234567891011121314151617//tryLock 方法试图申请一个锁， 在成功获得锁后返回 true, 否则，立即返回false, 而且线程可以立即离开去做其他事情。if (myLock.tryLock()) &#123; try &#123; . . . &#125; finally &#123; myLock.unlock(); &#125; &#125; else // do something else&#125;//调用 tryLock 时，使用超时参数,如果线程在等待期间被中断，将抛出InterruptedException 异常。这是一个非常有用的特性，因为允许程序打破死锁。//TimeUnit 是一 枚举类型，可以取的值包括 SECONDS、MILLISECONDS, MICROSECONDS和 NANOSECONDS//也可以调用 locklnterruptibly 方法。它就相当于一个超时设为无限的 tryLock 方法。if (myLock.tryLock(100, TimeUnit.MILLISECONDS))//在等待一个条件时， 也可以提供一个超时,//可以使用 awaitUninterruptibly 方法代替 await,这会使等待的线程被中断时继续等待下去。myCondition.await(100, TimeUnit.MILLISECONDS)) 13. 读 / 写锁如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，使用ReentrantReadWriteLock 类是十分有用的。 1234567891011121314151617181920//使用读/写锁的步骤//1. 构造一个 ReentrantReadWriteLock 对象private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();//2. 抽取读锁和写锁private Lock readLock = rwl . readLock();private Lock writeLock = rwl .writeLock();//3. 对所有的获取方法加读锁public double getTotalBalance()&#123; readLock.lock(); try &#123; . . . &#125; finally &#123; readLock.unlock(); &#125; &#125;//4. 对所有的修改方法加写锁public void transfer(. . .)&#123; writeLock.lock(); try &#123; . . . &#125; finally &#123; writeLock.unlock(); &#125; &#125; 六、阻塞队列阻塞队列是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 七、线程安全的集合1. 高效的映射、集和队列 java.util.concurrent 包提供了映射、 有序集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet 和 ConcurrentLinkedQueue。 这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。 size 方法不必在常量时间内操作,通常需要遍历来确定集合当前的大小。 2. 映射条目的原子更新1234567891011121314151617//replace操作do&#123; oldValue = map.get(word); newValue = oldValue = null ? 1 : oldValue + 1; &#125; while (!map.replace(word, oldValue, newValue)); &#125;//使用一个 ConcurrentHashMap&lt;String, AtomicLong&gt;或者使用 ConcurrentHashMap&lt;String，LongAdder&gt;map.putIfAbsent(word, new LongAdder()).increment();//调用 compute 方法map.compute(word , (k, v) -&gt; v = null ? 1: v + 1); map.computelfAbsent(word , k -&gt; new LongAdder()).increment();map.merge(word, 1L, (existingValue, newValue) -&gt; existingValue + newValue);map.merge(word, 1L, Long::sum); 3. 对并发散列映射的批操作12345678910//search操作String result = map.search(threshold, (k, v) -&gt; v &gt; 1000 ? k : null);map.forEach(threshold, (k, v) -&gt; System.out.println(k + \" -&gt; \" + v)); //只为各个映射条目提供一个消费者函数map.forEach(threshold, (k, v) -&gt; k + \" -&gt; \" + v, System.out::println); //添加一个转换器函数，这个函数要先提供， 其结果会传递到消费者map.forEach(threshold, (k, v) -&gt; v &gt; 1000 ? k + \" -&gt; \" + v : null, System.out::println); //转换器可以用作为一个过滤器，过滤结果为null的值//reduce操作，利用一个累加函数组合其输入Long sum = map.reduceValues(threshold, Long::sum); //计算所有值的总和Integer maxlength = map.reduceKeys(threshold, String::length, Integer::max); //提供一个转换器函数，计算最长的键的长度Long count = map. reduceValues(threshold, v -&gt; v &gt; 1000 ? 1L : null , Long::sum); //转换器可以作为一个过滤器，通过返回 null 来排除不想要的输入。 4. 并发集视图可以由ConcurrentHashMap的某些操作得到一个线程安全的集合。 123456//newKeySet 方法生成这个映射的键集。Set&lt;String&gt; words = ConcurrentHashMap.&lt;String&gt;newKeySet(); //keySet 方法，包含一个默认值，可以在为集增加元素时使用Set&lt;String&gt; words = map.keySet(1L);words.add(\"Java\"); //如果 \"Java\" 在 words 中不存在， 现在它会有一个值 1。 5. 写数组的拷贝 CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。 如果数组后来被修改了，迭代器仍然引用旧数组，但是，集合的数组已经被替换了。因而，旧的迭代器拥有一致的（可能过时的）视图，访问它无须任何同步开销。 6. 并行数组算法Java SE 8中，Arrays 类提供了大量并行化操作。 1234567891011121314//静态 Arrays.parallelSort 方法对一个基本类型值或对象的数组排序。String contents = new String(Files.readAllBytes(Paths.get(\"alice.txt\")), StandardCharsets.UTF_8); //将文件中的内容读入string中 String[] words = contents.split(\"[\\\\P&#123;L&#125;]+\"); // 按非字母拆分Arrays.parallelSort(words):Arrays.parallelSort(words, Comparator.comparing(String::length)); //提供一个 Comparator进行排序values.parallelSort(values, length / 2, values,length); //提供一个排序的边界//parallelSetAll 方法会用由一个函数计算得到的值填充一个数组。Arrays.parallelSetAll(values, i-&gt; i % 10); // 以 0 12 3 4 5 6 7 8 9 0 12 . . .来填充值//parallelPrefix 方法，它会用对应一个给定结合操作的前缀的累加结果替换各个数组元素。//操作并行完成，即经过log(n)步之后，这个过程结束。Arrays.parallelPrefix(values, (x, y) -&gt; x * y); //若数组为[1,2,3,4,...],执行该操作后数组将包含[1, 1x 2, 1x 2 x 3, l x 2 x 3 x 4, . . .] 7. 较早的线程安全集合 Java的初始版本中，Vector 和 Hashtable 类就提供了线程安全的动态数组和散列表的实现。 ArrayList 和 HashMap 类不是线程安全的。 任何集合类都可以通过使用同步包装器变成线程安全的。 123456789101112//同步包装器，结果集合的方法使用锁加以保护，提供了线程安全访问List&lt;E&gt; synchArrayList = Collections.synchronizedList(new ArrayList&lt;E&gt;());Map&lt;K , V&gt; synchHashMap = Collections.synchronizedMap(new HashMap&lt;K , V&gt;());//如果在另一个线程可能进行修改时要对集合进行迭代，仍然需要使用“ 客户端” 锁定：//如果使用“ foreach” 循环必须使用同样的代码， 因为循环使用了迭代器。//如果在迭代过程中，别的线程修改集合，迭代器会失效，抛出 ConcurrentModificationException 异常,因此并发的修改可以被可靠地检测出来。synchronized (synchHashMap) &#123; Iterator&lt;K&gt; iter = synchHashMap.keySet().iterator(); while (iter.hasNext());&#125; 八、Callable 与 Future123456789101112131415161718192021//Callable接口封装一个异步运行的任务public interface Callable&lt;V&gt; &#123; V call() throws Exception; &#125;//Future 保存异步计算的结果。public interface Future&lt;V&gt; &#123; V get() throws . . .; V get(long timeout, TimeUnit unit) throws . . . void cancel(boolean mayInterrupt); boolean isCancelled(); boolean isDone(); &#125;//FutureTask 包装器可将 Callable转换成 Future 和 Runnable,它同时实现二者的接口。Callable&lt;Integer&gt; myComputation = . . .;FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(myComputation);Thread t = new Thread(task); // it's a Runnablet.start();Integer result = task.get(); // it's a Future 九、执行器执行器（ Executor) 类有许多静态工厂方法用来构建线程池： 1. 线程池使用线程池的步骤： 调用 Executors 类中静态的方法 newCachedThreadPool 或 newFixedThreadPool。 调用 submit 提交 Runnable 或 Callable 对象。 如果想要取消一个任务，或如果提交 Callable 对象，那就要保存好返回的 Future对象。 当不再提交任何任务时，调用 shutdown。 12345678910ExecutorService newCachedThreadPool() //返回一个带缓存的线程池， 该池在必要的时候创建线程， 在线程空闲 60 秒之后终止线程。 ExecutorService newFixedThreadPool(int threads) //返回一个线程池， 该池中的线程数由参数指定。 ExecutorService newSingleThreadExecutor() //返回一个执行器， 它在一个单个的线程中依次执行各个任务。Future&lt;T &gt; submit(Cal1able&lt;T&gt; task) Future&lt; T &gt; submit(Runnable task, T result) Future&lt;?&gt; submit(Runnable task) //提交指定的任务去执行。 void shutdown() //关闭服务，会先完成已经提交的任务而不再接收新的任务。int getLargestPoolSize() //返回线程池在该执行器生命周期中的最大尺寸。 2. 预定执行ScheduledExecutorService 接口具有为预定执行或重复执行任务而设计的方法。 3. 控制任务组使用执行器可以控制一组相关任务： 12345678910//invokeAll 方法提交所有对象到一个 Callable 对象的集合中List&lt;Callab1e&lt;T&gt;&gt; tasks = . . .;List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks);for (Future&lt;T&gt; result : results) processFurther(result.get());//用 ExecutorCompletionService 来进行排列ExecutorCompletionService&lt;T&gt; service = new ExecutorCompletionServiceo(executor);for (Callable&lt;T&gt; task : tasks) service,submit(task);for (int i = 0; i &lt; tasks.size(); i ++) processFurther(service.take().get()); 4. Fork-Join 框架 Fork-join 框架专门用来完成计算密集型任务，如图像或视频处理，它通过将任务分解为多个子任务来执行，最后合并其结果。 Fork-join 框架使用了一种有效的智能方法称为工作密取来平衡可用线程的工作负载，每个工作线程都有一个双端队列来完成任务。 5. 可完成Future可完成future是可以组合的，利用可完成 fiiture，可以指定你希望做什么，以及希望以什么顺序执行这些工作。 12ConipletableFuture&lt;String&gt; contents = readPage(url);CompletableFuture&lt;List&lt;URL&gt;&gt; links = contents.thenApply(Parser::getlinks); 十、同步器 1. 信号量信号量作为同步原语可以被有效地实现， 并且有足够的能力解决许多常见的线程同步问题。 2. 倒计时门栓(CountDownLatch)一个倒计时门栓让一个线程集等待直到计数变为 0。倒计时门栓是一次性的。一旦计数为 0, 就不能再重用了。 3. 障栅(CyclicBarrier 类) CyclicBarrier 类实现了一个集结点称为障栅，当一个线程完成了它的那部分任务后就让它运行到障栅处。一旦所有的线程都到达了这个障栅，障栅就撤销，线程就可以继续运行。 如果任何一个在障栅上等待的线程离开了障栅，那么障栅就被破坏了，所有其他线程的 await 方法抛出 BrokenBarrierException 异常。 障栅被称为是循环的（ cyclic), 因为可以在所有等待线程被释放后被重用。 Phaser 类增加了更大的灵活性，允许改变不同阶段中参与线程的个数。 123456789101112131415161718//首先， 构造一个障栅， 并给出参与的线程数CyclicBarrier barrier = new CydicBarrier(nthreads);//每一个线程做一些工作，完成后在障栅上调用 awaitpublic void run()&#123; doWork(); bamer.await(); ...&#125;//await 方法有一个可选的超时参数：barrier.await(100, TimeUnit.MILLISECONDS);//可以提供一个可选的障栅动作（ barrier action), 当所有线程到达障栅的时候就会执行这一动作。//该动作可以收集那些单个线程的运行结果。Runnable barrierAction = . . .;CyclicBarrier barrier = new Cyc1icBarrier(nthreads, barrierAction); 4. 交换器（Exchanger）当两个线程在同一个数据缓冲区的两个实例上工作完成后，就可以使用交换器来相互交换缓冲区。 5. 同步队列（SynchronousQueue） 同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用 SynchronousQueue的 put 方法时，它会阻塞直到另一个线程调用 take 方法为止，数据仅仅沿一个方向传递。 即使 SynchronousQueue 类实现了 BlockingQueue 接口， 概念上讲，它依然不是一个队列。它没有包含任何元素，它的 size方法总是返回 0。","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Java中的集合","date":"2020-05-26T02:09:05.000Z","path":"2020/05/26/Java基础知识/Java中的集合/","text":"集合是Java中非常重要的内容。 一、Java 集合框架1. 将集合的接口与实现分离队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列。 12345678910111213141516171819202122232425262728293031323334353637383940//队列接口public interface Queue&lt;E&gt; &#123; void add(E element); E remove(); int size();&#125;//队列实现//循环队列,循环数组要比链表更高效，因此多数人优先选择循环数组。//循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。public class CircularArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private int head; private int tail; CircularArrayQueue(int capacity) &#123; ... &#125; public void add(E element) &#123; ... &#125; public E remove() &#123; ... &#125; public int size() &#123; ... &#125; private E[] elements; &#125;//链表队列public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Link head; private Link tail; LinkedListQueue() &#123; ... &#125; public void add(E element) &#123; ... &#125; public E remove() &#123; ... &#125; public int size() &#123; ... &#125; &#125;//使用接口类型存放集合的引用Queue&lt;Customer&gt; expresslane = new CircularArrayQueue&lt;&gt;(100);expressLane.add(new Customer(\"Harry\"));//只需修改接口的引用即可使用另外一种实现Queue&lt;Custoaer&gt; expressLane = new LinkedListQueue&lt;&gt;();expressLane.add(new Customer(\"Harry\")); 2. Collection 接口Java类库中集合的基本接口，集合中不允许有重复对象。 123456public interface Collection&lt;E&gt; &#123; boolean add(E element); //如果添加元素确实改变了集合就返回 true, 如果集合没有发生变化就返回 false。 Iterator&lt;E&gt; iterator(); //iterator方法用于返回一个实现了 Iterator 接口的对象。可以使用这个迭代器对象依次访问集合中的元素。 ...&#125; 3. 迭代器 迭代器是不断向前滑动的，当读取或删除一个元素后就向后滑动一个位置。 元素被访问的顺序取决于集合类型。 如果对 ArrayList 进行迭代， 迭代器将从索引 0开 始，每迭代一次，索引值加1，如果访问 HashSet 中的元素， 每个元素将会按照某种随机的次序出现。1234567891011121314151617181920212223242526272829303132//Iterator迭代器public interface Iterator&lt;E&gt; &#123; E next(); //逐个访问集合中的每个元素，在调用 next 之前调用 hasNext方法。如果迭代器对象还有多个供访问的元素， 这个方法就返回 true。 boolean hasNext(); void remove(); //remove的是上一个被next的元素，故remove之前必须调用next方法读取。 default void forEachRemaining(Consumer&lt;? super E&gt; action); &#125;//集合遍历Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();while (iter.hasNext()) &#123; String element = iter.next(); do something with element&#125;//foreach 遍历：可以与任何实现了 Iterable 接口的对象一起工作//Collection 接口扩展了 Iterable 接口。因此， 对于标准类库中的任何集合都可以使用“ foreach” 循环。public interface Iterable&lt;E&gt;&#123; Iterator&lt;E&gt; iterator();&#125;for (String element : c) &#123; do something with element&#125;//lambda表达式遍历iterator.forEachRemaining(element -&gt; do something with element); 4. 泛型实用方法 由于 Collection 与 Iterator 都是泛型接口，可以编写操作任何集合类型的实用方法。 Collection 接口中已经实现了很多默认方法供类库使用者直接调用。 1234567891011public abstract class Abstracted1ection&lt;E&gt; implements Collection&lt;E&gt;&#123; public abstract Iterator&lt;E&gt; iterator() ; public boolean contains(Object obj) &#123; for (E element : this) // calls iterator() if (element.equals(obj)) return = true; return false; &#125;&#125; 5. 集合框架中的接口集合有两个基本接口：Collection 和 Map。 123456789101112131415161718192021222324252627282930313233//Collection插入读取（使用迭代器）元素boolean add(E element)//Map插入读取元素V put(K key, V value)V get(K key)//List 是一个有序集合，可迭代器访问也可随机访问void add(int index, E element)void remove(int index) E get(int index) E set(int index, E element)//Listlterator 接口是 Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：void add(E element)//标记接口 RandomAccess 不包含任何方法，不过可以用它来测试一个特定的集合是否支持高效的随机访问。if (c instanceof RandomAccess)&#123; use random access algorithm&#125;else&#123; use sequential access algorithm&#125;//Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集（set) 的 add方法不允许增加重复的元素。//要适当地定义集的 equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。//hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。//SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。//接口 NavigableSet 和 NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法,TreeSet 和 TreeMap 类实现了这些接口。 二、具体的集合以 Map 结尾的类实现了 Map 接口,除此之外，其他类都实现了Collection 接口。 1. 链表（LinkedList） Java中的所有链表实际上都是双向链接的，LinkedList类实现了List接口。 链表是一个有序集合,有n+1个位置添加新元素。 迭代器是描述集合中位置的，所以这种依赖于位置的 add 方法（例如将元素添加到链表中间）将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。 在调用remove之前调用next，则删除的是迭代器左侧元素，若在调用remove之前调用previous，则删除的是右侧元素。 add 方法只依赖于迭代器的位置， 而 remove 方法依赖于迭代器的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041List&lt;String&gt; staff = new LinkedList&lt;&gt;(); // LinkedList implements Liststaff.add(\"Amy\"); //LinkedList.add 方法将对象添加到链表的尾部。staff.add(\"Bob\")；staff.add(\"Carl\");Iterator iter = staff.iterator();String first = iter.next();// visit first elementString second = iter.next(); //visit second elementiter.remove(); // remove last visited element//子接口ListIteratorinterface ListIterator&lt;E&gt; extends Iterator&lt;E&gt;&#123; void add(E element); //假定添加操作总会改变链表，在当前迭代器位置之前添加一个新对象。 E previous() //反向遍历链表 boolean hasPrevious()&#125;ListIterator&lt;String&gt; iter = staff.listIterator();iter.next();iter.add(\"juliet\"); //在第二个元素之前添加“Juliet”//set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。//添加、删除元素属于结构性修改，而set 方法不被视为结构性修改。ListIterator&lt;String&gt; iter = list.listIterator();String oldValue = iter.next(); // returns first elementiter.set(newValue); // sets first element to newValue//并发修改异常//解决方法：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。//检测并发修改的异常： 每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。List&lt;String&gt; list = ...ListIterator&lt;String&gt; iter1 = list.listlterator();ListIterator&lt;String&gt; iter2 = list.listlterator();iter1.next();iter1.remove();iter2.next(); // throws ConcurrentModificationException//访问某个特定元素,效率低LinkedList&lt;String&gt; list = ...;String obj = list.get(n); //每次査找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。 2. 数组列表（ArrayList）ArrayList类实现了List接口，它封装了一个动态再分配的对象数组。 3. 散列集（HashSet） 在 Java 中，散列表用链表数组实现，散列码是由对象的实例域产生的一个整数。 如果自定义类，就要负责实现这个类的 hashCode 方法，自己实现的 hashCode方法应该与 equals 方法兼容。 散列表可以用来实现Set及HashSet。 装填因子指表大小占预计元素个数的比例，若表中超过该比例的位置已经填入元素，这个表就会用双倍的表长自动地进行再散列。 如果要对散列表再散列， 就需要创建一个表长更大的表，并将所有元素插入到这个新表中，然后丢弃原来的表。 12345HashSet() //构造一个空散列表。 HashSet(Collection&lt;? extends E&gt; elements ) //构造一个散列集， 并将集合中的所有元素添加到这个散列集中。 HashSet(int initialCapacity) //构造一个空的具有指定容量（桶数）的散列集。 HashSet(int initialCapacity , float loadFactor ) //构造一个具有指定容量和装填因子（一个 0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列）的空散列集。int hashCode( ) //返回这个对象的散列码,equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCode() 必须等于 y.hashCode()。 4. 树集（TreeSet） 树集是一个有序集合，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。 排序是利用红黑树实现的，即每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。 要使用树集，必须能够比较元素。这些元素必须实现 Comparable 接口或者构造集时必须提供一个 Comparator。 从 JavaSE 6 起，TreeSet 类实现了 NavigableSet 接口。 这个接口增加了几个便于定位元素以及反向遍历的方法。 5. 队列与双端队列（Deque）Deque 接口由 ArrayDeque 和 LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。 6. 优先级队列（PriorityQueue） 优先级队列使用堆对元素进行检索，堆是一个可以自我调整的二叉树，对树执行添加（add) 和删除（remove) 操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。 无论何时调用 remove 方法，总会删除当前优先级队列中最小的元素。 三、映射映射用来存放键/值对。如果提供了键，就能够查找到值。 1. 基本映射操作 Java 类库为map接口提供了两个通用的实现：HashMap 和 TreeMap。 键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用 put 方法，第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。 1234567891011121314Map&lt;String, Employee&gt; staff = new HashMap&lt;&gt;();Employee harry = new Employee(\"Harry Hacker\");staff.put(\"987-98-9996\", harry);//检索String id = \"987-98-9996\"; Employee e = staff.get(id);// gets harry,如果在映射中没有与给定键对应的信息， get 将返回 null。Map&lt;String, Integer&gt; scores = ...;int score = scores.get(id,0); // 如果get(id)不存在则默认get(0)。//remove 方法用于从映射中删除给定键对应的元素。size 方法用于返回映射中的元素数。//lambda表达式遍历映射scores.forEach((k, v) -&gt; System.out.println(\"key=\" + k + \", value:\" + v)); 2. 更新映射项123456789counts.put(word, counts.get(word)+ 1); //当第一次添加 word 时，get 会返回 null, 因此会出现一个 NullPointerException 异常。//解决方法counts,put(word, counts.getOrDefault(word, 0)+ 1); //若word第一次添加，则利用默认值+1counts.putlfAbsent(word, 0); //只有当键原先存在时才会放入一个值。counts.put(word, counts.get(word)+ 1);counts.merge(word, 1, Integer::sum); //如果键原先不存在，将把word与1关联，否则将原值和1求和。 3. 映射视图 映射有三种视图：键集、 值集合（不是一个集） 以及键/值对集。 不能向键集视图和键值对视图中增加元素，但可以删除，若试图调用 add方法， 它会抛出一个 UnsupportedOperationException。 12345678910111213141516171819202122//三种视图Set&lt;K&gt; keySet() //keySet是实现了 Set 接口的另外某个类的对象。Collection&lt;V&gt; values()Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()//视图遍历//键视图Set&lt;String&gt; keys = map.keySet();for (String key : keys) &#123; do something with key&#125;//键值对视图for (Map.Entry&lt;String, Employee&gt; entry : staff.entrySet()) &#123; String k = entry.getKey(); Employee v = entry.getValue(); do something with k, v&#125;counts.forEach((k，v) -&gt; &#123;do somethingwith k, v &#125;); 4. 弱散列映射(WeakHashMap) WeakHashMap用来配合垃圾回收器删除无用映射对象。 WeakHashMap 使用弱引用 （ weak references) 保存键。WeakReference 对象将引用保存到另外一个对象中，在这里，就是散列键。 如果某个对象只能由 WeakReference 引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap 将周期性地检查队列，以便找出新添加的弱引用，然后由WeakHashMap 删除对应的条目。 5. 链接散列集（LinkedHashSet）与链接映射（LinkedHashMap） LinkedHashSet 和 LinkedHashMap 类用来记住插入元素项的顺序，当条目插入到表中时，就会并入到双向链表中。 LinkedHashSet 按照插入顺序来访问元素项。 LinkedHashMap 按照“最近最少使用”原则来访问元素项，每次调用 get 或put访问一个元素后，该元素就被从当前位置删除并放到链表的尾部。当在表中找不到元素项且表又已经满时，可以将迭代器加入到表中，并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。 1234567891011//构造散列映射表LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)//构造一个覆盖了removeEldestEntry方法的子类以实现自动化删除最近最少使用元素Map&lt;K, V&gt; cache = new LinkedHashMap&lt;&gt;(128, 0.75F, true) &#123; protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; 100; &#125; &#125;(); 6. 枚举集（EnumSet）与枚举映射（EnumMap） 所有的枚举类型都扩展于泛型 Enum 类。 EnumSet 是一个枚举类型元素集的高效实现，内部用位序列实现。如果对应的值在集中，则相应的位被置为 1。 EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。 1234567enum Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);EnumMap&lt;Weekday, Employee&gt; personlnCharge = new EnumMapo(Weekday.class); 7. 标识散列映射（IdentityHashMap） 类 IdentityHashMap的键的散列值不是用 hashCode 函数计算的，而是用 System.identityHashCode 方法由Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式计算的。 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals，即不同的键对象， 即使内容相同， 也被视为是不同的对象。 在实现对象遍历算法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。 四、视图与包装器映射类中的keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。 1. 轻量级集合包装器(Collections)Collections 类包含很多实用方法， 这些方法的参数和返回值都是集合，如空集、 列表、 映射等。 123456//返回一个包装了普通 Java 数组的 List 包装器。Card[] cardDeck = new Card[52];List&lt;Card&gt; cardList = Arrays.asList(cardDeck); //是一个视图对象， 带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法（例如，与迭代器相关的 add 和 remove 方法）都会抛出一个 //Unsupported OperationException 异常。List&lt;String&gt; names = Arrays.asList(\"Amy\" , \"Bob\", \"Carl \"); //返回一个实现了 List 接口的不可修改的对象List&lt;String&gt; settings = Collections.nCopies(100, \"DEFAULT\"); //创建一个包含100个字符串的List, 每个串都被设置为“DEFAULT” 2. 子范围视图可以为很多集合建立子范围视图，将任何操作应用于子范围，并且能够自动地反映整个列表的情况。 1234567891011121314151617List group2 = staff.subList(10, 20); //返回索引[10.20)之间的子范围元素视图group2.clear(); //删除子视图元素，反映到整个列表//对于有序集和映射， 可以使用排序顺序而不是元素位置建立子范围。//返回大于等于 from 且小于 to 的所有元素子集。SortedSet&lt; E&gt; subSet(E from, E to)SortedSet&lt; E&gt; headSet(E to)SortedSet&lt; E&gt; tail Set(E from)SortedMap&lt;K, V&gt; subMap(K from, K to)SortedMap&lt;K, V&gt; headMap(K to)SortedMap&lt;K, V&gt; tailMap(K from)//NavigableSet 接口赋予子范围操作更多的控制能力。NavigableSet&lt;E&gt; subSet(E from, boolean fromInclusive, E to, boolean toInclusive)NavigableSet&lt;E&gt; headSet(E to, boolean tolncIusive)Navigab1eSet&lt;E&gt; tailSet(E from, boolean fromInclusive) 3. 不可修改的视图 Collections 还有几个方法，用于产生集合的不可修改视图,这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改， 就抛出一个异常，同时这个集合将保持未修改的状态。 由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。 12345678910111213//以下方法可获得一个不可修改视图//它的 equals 方法不调用底层集合的 equals 方法。它继承了 Object 类的 equals 方法， 这个方法只是检测两个对象是否是同一个对象。Collections.unmodifiableCollection //使用底层集合的 equals 方法和 hashCode 方法。Collections.unmodifiableListCollections.unmodifiableSetCollections.unmodifiableSortedSetCollections.unmodifiableNavigableSetCollections.unmodifiableMapCollections.unmodifiableSortedMapCollections.unmodifiableNavigableMap 4. 同步视图 类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。 同步操作即在另一个线程调用另一个方法之前，刚才的方法调用必须彻底完成。 12//Collections 类的静态 synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的 MapMap&lt;String, Employee&gt; map = Collections.synchronizedMap(new HashMap&lt;String, Employee&gt;()); 5. 受查视图受查视图可以在调用add 方法时检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 ClassCastException。这样做的好处是错误可以在正确的位置得以报告。 12345678ArrayList&lt;String&gt; strings = new ArrayListo()ArrayList rawList = strings; // 仅出现警告rawList.add(new Date()); // now strings contains a Date object!//解决方法：使用受查视图List&lt;String&gt; safestrings = Collections.checkedList(strings，String,class);ArrayList rawList = safestrings;rawList.add(new Date());// 抛出异常 ClassCastException 五、算法1. 排序与混排 java中对列表的排序直接将所有元素转入一个数组，对数组进行排序，然后再将排序后的序列复制回列表。 不能将不可修改列表如unmodifiableList 列表传递给排序算法，传递的列表必须是可修改的，但不必是可以改变大小的。 如果列表支持 set 方法，则是可修改的。 如果列表支持 add 和 remove 方法， 则是可改变大小的。 1234567891011List&lt;String&gt; staff = new LinkedList&lt;&gt;();fill collectionCollections.sort(staff); //方法假定列表元素实现了 Comparable 接口staff.sort(Comparator.comparingDouble(Employee::getSalary)); //使用 List 接口的 sort方法并传入一个 Comparator 对象。staff.sort(Comparator.reverseOrder()); //按降序排列staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed()) //按工资逆序排序ArrayList&lt;Card&gt; cards = ...;Collections.shuffle(cards); //随机地混排列表中元素的顺序,如果提供的列表没有实现 RandomAccess 接口，shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。 2. 二分查找（binarySearch） 要使用二分查找，必须提供排好序的集合以及要查找的元素，且该集合必须实现List接口。 如果集合没有采用 Comparable 接口的 compareTo 方法进行排序， 就还要提供一个比较器对象。 只有采用随机访问，二分査找才有意义，若果为 binarySearch 算法提供一个链表，它将自动地变为线性查找。 12345678//返回值 &gt;=0 ,表示匹配对象的索引。//返回负值，表示没有匹配的元素。应该将这个键插人到列表索引（-i - l）的位置上，以保持列表的有序性。i = Collections.binarySearch(c, element); i = Collections.binarySearch(c, element, comparator);c.get(i); if (i &lt; 0) c.add(-i - 1, element); 3. 简单算法Collections 类中提供的各种简单算法可以增加代码的可读性。 1234Collections.replaceAll (\"C++\", \"Java\");words.removelf(w -&gt; w.length() &lt;= 3);words.replaceAll(String::toLowerCase); 4. 批操作123456789101112131415//从 coll1 中删除 coll2 中出现的所有元素。colll.removeAll(coll2);//求coll1和coll2的交集coll1.retainAll(coll2);Set&lt;String&gt; result = new HashSet&lt;&gt;(a);result.retainAll(b);//在视图上批量操作Map&lt;String, Employee&gt; staffMap = ...;Set&lt;String&gt; terminatedIDs = ...;staffMap.keySet().removeAll(terminatedIDs);relocated.addAll(staff.subList(0, 10));staff.subList(0, 10).clear(); 5. 集合与数组的转换123456789101112//把一个数组转换为集合String[] values = ...;HashSet&lt;String&gt; staff = new HashSet&lt;&gt;(Arrays.asList(values));//从集合得到数组Object[] values = staff.toArray(); //返回的数组是一个 Object[] 数组，不能使用强制类型转换//提供一个所需类型而且长度为 0 的数组String[] values = staff.toArray(new String[0]); // 返回的数组就会创建为相同的数组类型//以构造一个指定大小的数组staff.toArray(new String[staff.size()]); //这种情况不会创建新数组 6. 编写自己的算法如果编写自己的算法（实际上，是以集合作为参数的任何方法，) 应该尽可能地使用接口，而不要使用具体的实现。 1234567891011121314151617181920212223//使用接口作为参数void fillMenu(]Menu menu, Collection&lt;]MenuItem&gt; items) &#123; for (JMenuItem item : items) menu.add(item); &#125;//返回接口,在这种情况下，调用者返回的对象是一个不可修改的列表。List&lt;]MenuItem&gt; getAllItems(final JHenu menu) &#123; return new AbstractList&lt;&gt;() &#123; public JMenuItem get(int i) &#123; return menu.getltem(i); &#125; public int size() &#123; return menu.getltemCount(); &#125; &#125;; &#125; 六、遗留的集合在集合框架出现之前已经存在大量“遗留的” 容器类。这些类已经集成到集合框架中。 1. Hashtable 类 Hashtable 类与 HashMap 类的作用一样，它们拥有相同的接口。 Hashtable 和Vector类的方法是同步的，如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 HashMap。如果需要并发访问， 则要使用 ConcurrentHashMap。 2. 枚举（Enumeration）12345678910//遗留集合使用 Enumeration 接口对元素序列进行遍历。Enumeration&lt;Employee&gt; e = staff.elements();whi1e (e.HasMoreElements()) &#123; Employee e = e.nextElement(); &#125;//遗留方法，其参数是枚举类型的。List&lt;InputStream&gt; streams = ...;SequenceInputStream in = new SequencelnputStream(Collections.enumeration(streams)); 3. 属性映射（Properties）属性映射是一个类型非常特殊的映射结构,通常用于程序的特殊配置选项。 键与值都是字符串。 表可以保存到一个文件中，也可以从文件中加载。 使用一个默认的辅助表。 123456Properties() //创建一个空的属性映射。 Properties(Properties defaults) //创建一个带有一组默认值的空的属性映射。 String getProperty(String key) //获得属性的对应关系；返回与键对应的字符串。 如果在映射中不存在，返回默认表中与这个键对应的字符串。 String getProperty(String key, String defaultValue) //获得在键没有找到时具有的默认值属性；它将返回与键对应的字符串，如果在映射中不存在，就返回默认的字符串。 void load(InputStream in) //从 InputStream 加载属性映射。 void store(OutputStream out, String commentstring) //把属性映射存储到 OutputStream。 4. 栈（Stack）Stack类扩展于Vector类，Vector 类并不太令人满意，它可以让栈使用不属于栈操作的 insert 和 remove 方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶。 123E push(E item) //将 item 压入桟并返回 item。 E pop() //弹出并返回栈顶的 item。如果栈为空，请不要调用这个方法。 E peek() //返回栈顶元素，但不弹出。如果栈为空，请不要调用这个方法。 5. 位集（BitSet） BitSet 类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适)。如果需要高效地存储位序列（例如，标志）就可以使用位集。 由于位集将位包装在字节里，所以使用位集要比使用 Boolean 对象的 ArrayList 更加高效。 12345678910bucketOfBits.get(i) //如果第 i 位处于“开” 状态，就返回 true; 否则返回 false。bucketOfBits.set(i) //将第 i 位置为“开” 状态。bucketOfBits.clear(i) //将第 i 位置为“关” 状态。BitSet(int initialCapacity) //创建一个位集。 int length() //返回位集的“逻辑长度”， 即 1 加上位集的最高设置位的索引。void and(BitSet set ) //这个位集与另一个位集进行逻辑“ AND”。 void or(BitSet set ) //这个位集与另一个位集进行逻辑“ OR”。 void xor(BitSet set ) //这个位集与另一个位集进行逻辑“ X0R” 异或。 void andNot(BitSet set) //清除这个位集中对应另一个位集中设置的所有位。","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Java中的泛型程序设计","date":"2020-05-25T02:09:05.000Z","path":"2020/05/25/Java基础知识/Java中的泛型程序设计/","text":"一、定义简单泛型类 一个泛型类就是具有一个或多个类型变量的类。 类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。 类型变量使用大写形式，变量 E 表示集合的元素类型，K 和 V 分别表示表的关键字与值的类型，T 可表示任意类型。 用具体的类型替换类型变量就可以实例化泛型类型，换句话说，泛型类可看作普通类的工厂。 123456789101112131415//定义简单泛型类public class Pair&lt;T&gt; &#123; private T first; private T second; public Pair() &#123; first = null ; second = null; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; public T getFirst()&#123; return first; &#125; public T getSecond()&#123; return second; &#125; public void setFirst(T newValue) &#123; first = newValue; &#125; public void setSecond(T newValue) &#123; second = newValue; &#125; &#125;//引入多个类型变量public class Pair&lt;T, U&gt; &#123; . . . &#125; 二、泛型方法 可以定义一个带有类型参数的简单方法，称为泛型方法。 泛型方法可以定义在普通类中，也可以定义在泛型类中。 当调用一个泛型方法时,在方法名前的尖括号中放入具体的类型,有些情况下具体类型可省略。 12345678910111213141516class ArrayAlg&#123; public static &lt;T&gt; T getMiddle(T... a) //参数类型放在方法返回值前面 &#123; return a[a.length / 2]; &#125; &#125;//调用泛型方法String middle = ArrayAlg.&lt;String&gt;getMiddle(\"John\", \"Q\", \"Public\");//编译器能够用 names 的类型（即 String[ ]) 与泛型类型 T[ ]进行匹配并推断出 T 一定是 String。故在这种情况下可省略类型参数。String middle = ArrayAlg.getMiddle(\"John\", \"Q\", \"Public\");//编译器将会自动打包参数为 1 个Double 和 2 个 Integer 对象，而后寻找这些类的共同超类型为Number 和 Comparable 接口，此时会得到一个错误报告提示可以将结果赋给Number 或 Comparable 接口。//可以使用这种方式有目的地引入一个错误，并研究编译器对一个泛型方法调用最终推断出哪种类型double middle = ArrayAlg.getMiddle(3.14, 1729, 0); 三、类型变量的限定 利用关键字extends来限定类型变量，一个类型变量或通配符可以有多个限定，用&amp;分隔，而逗号用来分隔类型变量。 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。 123456789101112131415161718192021222324252627class ArrayAlg&#123; //对T进行限定：表明泛型的min方法只能被实现了 Comparable 接口的类（如 String、 LocalDate 等）的数组调用。否则会产生一个编译错误。 public static &lt;T extends Comparab1e&gt; T min(T[] a) // almost correct &#123; if (a null || a.length = 0) return null; T smallest = a[0]; for (int i = 1; i &lt; a.length; i++) if (smallest.compareTo(a[i]) &gt; 0) smallest = a[i]; return smallest; &#125; &#125;//一个类型变量或通配符可以有多个限定，&amp;隔开T extends Comparable &amp; Serializablepublic static &lt;T extends Comparable&gt; Pair&lt;T&gt; minmax(T[] a)&#123; if (a = null || a.length == 0) return null; T min = a[0]; T max = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (inin.compareTo(a[i]) &gt; 0) min = a[i]; &lt;2 if (max .coinpareTo(a[i]) &lt; 0) max = a[i]; &#125; return new Pair&lt;&gt;(min, max); &#125; 四、泛型代码和虚拟机1. 类型擦除虚拟机没有泛型类型对象—所有对象都属于普通类。Java中的泛型是用擦除实现的，即仅于编译时类型检查，在运行时擦除类型信息，这样可以避免运行时代码膨胀。 无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型。 原始类型就是擦除类型变量, 并替换为限定类型（无限定的变量用 Object 替换）后的普通类型。 原始类型用第一个限定的类型变量来替换， 如果没有给定限定就用 Object 替换。 为了提高效率，应该将标签接口（即没有方法的接口）放在边界列表的末尾。 12345678910111213141516171819//泛型类型public class Interval &lt;T extends Comparable &amp; Serializable&gt; implements Serializable //可以实现接口&#123; private T lower; private T upper; public Interval (T first, T second) &#123; if (first.compareTo(second) &lt;= 0) &#123; lower = first; upper = second; &#125; else &#123; lower = second; upper = first; &#125; &#125; &#125;//对应的原始类型public class Interval implements Serializable&#123; private Comparable lower; private Comparable upper; public Interval (Comparable first, Comparable second) &#123; . . . &#125; &#125; 2. 翻译泛型表达式 当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。 当存取一个泛型域时也要插入强制类型转换。 123456//编译器把这个方法调用翻译为两条虚拟机指令：对原始方法 Pair.getFirst 的调用; 将返回的 Object 类型强制转换为 Employee 类型。Pair&lt;Employee&gt; buddies = . .Employee buddy = buddies.getFirst(); //假设Pair 类的 first 域和 second 域都是公有的Employee buddy = buddies.first; //会在结果字节码中插人强制类型转换。 3. 翻译泛型方法 类型擦除之前认为泛型方法为一个方法族，而擦除类型之后，只剩下一个方法。 类型擦除与多态发生了冲突，要想多态正确的发挥作用，需要编译器在 Datelnterval 类中生成一个桥方法。 12345678910111213141516171819class Datelnterval extends Pair&lt;LocalDate&gt;&#123; public void setSecond(LocalDate second) &#123; if (second.compareTo(getFirst()) &gt;= 0) super.setSecond(second); &#125; //生成桥方法来保持多态 public void setSecond(Object second) &#123; setSecond((Date) second);&#125;Datelnterval interval = new Datelnterval(. . .);Pair&lt;Loca1Date&gt; pair = interval; pair.setSecond(aDate); //对于可协变返回类型的方法不能生成桥方法，因为在虚拟机中，用参数类型和返回类型确定一个方法。虚拟机能够正确处理这一情况。LocalDate getSecond() Object getSecond() 有关 Java 泛型转换的事实: 虚拟机中没有泛型，只有普通的类和方法。 所有的类型参数都用它们的限定类型替换。 桥方法被合成来保持多态。 为保持类型安全性，必要时插入强制类型转换。 4. 调用遗留代码 Java允许泛型代码和遗留代码之间能够互操作。 当利用原始类型操作泛型对象时以及由遗留的类得到一个原始类型的对象时都会产生一个警告，若在设计代码时可以确保不会发生错误，则可以使用注解@SuppressWarnings(&quot;unchecked&quot;)消除这些警告。 五、约束与局限性在使用泛型时需要考虑一些限制，大多数限制都是由类型擦除引起的。 1. 不能用基本类型实例化类型参数 不能用基本类型实例化类型参数的原因是类型擦除，擦除之后原始类型中含有Object类型的域，而 Object 不能存储基本类型的值。 这并不是一个致命的缺陷，它与Java 语言中基本类型的独立状态相一致。 2. 运行时类型查询只适用于原始类型因为虚拟机中没有泛型类型，而是总有一个特定的非泛型类型，故运行时类型查询只适用于原始类型。 1234567f(a instanceof Pair&lt;String&gt;) // 会得到一个编译器错误Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; //会得到一个警告//getClass 方法总是返回原始类型。Pair&lt;String&gt; stringPair = . .Pair&lt;Employee&gt; employeePair = . .if (stringPair.getClass() == employeePair.getClass()) //比较的结果是 true, 这是因为两次调用 getClass 都将返回 Pair.class。 3. 不能创建参数化类型的数组 因为类型擦除会让数组能够记住它的元素类型的机制失效，往参数化类型数组中添加各种类型后就能够通过数组检查，这违背了泛型设计的原则，故不能创建参数化类型的数组。 只是不允许创建这些数组，而声明类型为 Pair&lt;String&gt;[] 的变量仍是合法的,只是不能通过new Pair&lt;String&gt;[10] 初始化这个变量。 1234567891011121314//table 的类型是 Pair[] 可以把它转换为 Object[] Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]; // 不能创建参数化类型的数组Object[] objarray = table;//类型擦除使数组能够记住它的元素类型的机制失效了，即以下赋值能够通过存储检查，objarray[0] = \"Hello\"; //运行时会导致一个类型错误，违背了泛型设计的原则。objarray[0] = new Pair&lt;Employee&gt;();//可以声明通配类型的数组， 然后进行类型转换,但这样是不安全的//如果在 table[0] 中存储一个 Pair&lt;Employee&gt;, 然后对 table[0].getFirst() 调用一个 String 方法， 会得到一个 ClassCastException 异常。Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];//收集参数化类型对象的唯一安全有效的方法ArrayList:ArrayList&lt;Pair&lt;String&gt;&gt; 4. Varargs 警告 向参数个数可变的方法传递一个泛型类型的实例时，Java 虚拟机必须建立一个 Pair&lt;String&gt; 数组，这就违反了虚拟机中没有泛型的规则，但是对于这种情况只会得到一个警告而不是错误。 可增加注解@SuppressWamings(&quot;unchecked&quot;。)或@SafeVarargs来抑制这个警告，之后就可以提供泛型类型来调用这个方法了。 对于只需要读取参数数组元素的所有方法，都可以使用这两个注解。 1234567891011121314@SafeVarargspublic static &lt;T&gt; void addAll(Collections coll, T... ts) &#123; for (t : ts) coll.add(t);&#125;Col1ection&lt;Pair&lt;String&gt;&gt; table = . . .;Pair&lt;String&gt; pairl = . . .;Pair&lt;String&gt; pair2 = . .addAll(table, pairl, pair2);@SafeVarargs static &lt;E&gt; E[] array(E... array) &#123; return array;&#125;Pair&lt;String&gt;[] table = array(pairl, pair2);Object[] objarray = table;objarray[0] = new Pair&lt;Employee&gt;(); //能顺利运行而不会出现 ArrayStoreException 异常（因为数组存储只会检查擦除的类型) 但在处理 table[0] 时会在别处得到一个异常。 5. 不能实例化类型变量 不能使用像 new T(...) new T[...] 或 T.class 这样的表达式中的类型变量。 解决办法是让调用者提供一个构造器表达式或者通过反射调用 Class.newInstance 方法来构造泛型对象。 1234567891011121314151617// Errorpublic Pair() &#123; first = new T(); second = new T(); &#125;//解决方法Pair&lt;String&gt; p = Pair.makePair(String::new);public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr) &#123; return new Pair&lt;&gt;(constr.get(), constr.get()); &#125;// Errorfirst = T.class.newInstance(); //解决方法public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl) &#123; try &#123; return new Pair(cl.newInstance(), cl.newInstance()); &#125; catch (Exception ex) &#123; return null; &#125; &#125;Pair&lt;String&gt; p = Pair.makePair(String.class); 6. 不能构造泛型数组因为数组中的类型在虚拟机中会被擦除。 12345678910111213141516171819202122232425// Errorpublic static &lt;T extends Comparable〉 T[] minmax(T[] a) &#123; T[] mm = new T[2]; . . . &#125; //类型擦除会让这个方法永远构造 Comparable[2] 数组。//Errorpublic static &lt;T extends Comparable〉T[] minmax(T... a) &#123;Object[] mm = new Object[2];return (T[]) mm; // compiles with warning&#125;String[] ss = ArrayAlg.minmax(\"Tom\", \"Dick\", \"Harry\");//解决方法//用户提供一个数组构造器表达式public static &lt;T extends Comparable〉T[] minmax(IntFunction&lt;TD&gt; constr, T... a) &#123; T[] mm = constr.apply(2); &#125;String口 ss = ArrayAlg.minmax (String[]::new，\"Tom\", \"Dick\", \"Harry\");//利用反射构造public static &lt;T extends Comparable&gt;T[] minmax(T... a) &#123; T[] mm = (T[]) Array.newlnstance(a.getClass().getComponentType(), 2);&#125;//toArray方法Object[] toArray()T[] toArray(T[] result) //如果数组足够大， 就使用这个数组。 否则， 用 result 的成分类型构造一个足够大的新数组。 7. 泛型类的静态上下文中类型变量无效不能在静态域或方法中引用类型变量。因为由于类型擦除静态域的特定功能也会消失。 12345678910public class Singleton&lt;T&gt; &#123; private static T singleInstance; // Error public static T getSingleInstance() // Error &#123; if (singleinstance == null) construct new instance of T return singlelnstance; &#125; &#125; 8. 不能抛出或捕获泛型类的实例 既不能抛出也不能捕获泛型类对象。 泛型类扩展 Throwable 是不合法的。 catch 子句中不能使用类型变量。 1234567891011121314151617181920212223242526272829// Error 不能扩展Throwablepublic class Problem&lt;T&gt; extends Exception &#123; /* . . . */ &#125; //Error 不能编译public static &lt;T extends Throwable〉void doWork(Class&lt;T&gt; t) &#123; try &#123; do work &#125; catch (T e) // Error 不能捕获类型变量 &#123; Logger,global.info(...) &#125; &#125;//在异常规范中使用类型变量是允许的public static &lt;T extends Throwable&gt; void doWork(T t) throws T // OK&#123; try &#123; do work &#125; catch (Throwable realCause) &#123; t.initCause(realCause); throw t; &#125;&#125; 9. 可以消除对受查异常的检查 泛型可以消除java异常处理中必须为所有受查异常提供一个处理器的限制，可利用注解@SupressWarnings(&quot;unchecked&quot;)来实现。 通过使用泛型类、擦除和 @SuppressWarnings 注解， 就能消除 Java 类型系统的部分基本限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Block&#123; public abstract void body() throws Exception; public Thread toThread() &#123; return new Thread() &#123; public void run() //run方法不会介意受查异常Exception &#123; try &#123; body(); &#125; catch (Throwable t) &#123; //以下代码会把所有异常都转换为编译器所认为的非受查异常。 Block.&lt;RuntimeException&gt;throwAs(t); &#125; &#125; &#125;; &#125; @SuppressWamings(\"unchecked\") public static &lt;T extends Throwable&gt; void throwAs(Throwable e) throws T &#123; throw (T) e; &#125; &#125;public class Test&#123; public static void main(String[] args) &#123; new Block() &#123; public void body() throws Exception &#123; Scanner in = new Scanner(new FileC'ququx\") , \"UTF-8\"); while (in.hasNext()) System.out.println(in.next()); &#125; &#125; .toThread().start(); &#125; &#125; 10. 注意擦除后的冲突 泛型类在擦除后可能会与Object类中的方法产生冲突，解决方法是重新命名引发错误的方法。 要想支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。 1234567891011121314public class Pair&lt;T&gt; &#123; public boolean equals(T value) &#123; return first.equals(value) &amp;&amp; second.equals(value); &#125;&#125;//考虑Pair&lt;String&gt;，它有两个equals方法，这两个方法在方法擦除后会产生冲突//解决方法是重新命名equalsboolean equals(String) // 定义在Pair&lt;T&gt;中，擦除后变为boolean equals(Object)boolean equals(Object) // 继承自Object//Error，因为Manager 会实现 Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt;, 这是同一接口的不同参数化。//实现了 C0mpamble&lt;X&gt; 的类可以获得一个桥方法，对于不同类型的 X 不能有两个这样的方法。class Employee implements Comparable&lt;Employee&gt; &#123; . . . &#125;class Manager extends Employee implements Comparable&lt;Manager&gt; &#123; . . . &#125; // Errorpublic int compareTo(Object other) &#123; return compareTo((X) other); &#125; 六、泛型类型的继承规则 处于类型安全的考虑，Java规定无论 S 与 T 有什么联系，通常，Pair 与 Pair没有什么联系。 泛型类可以扩展或实现其他的泛型类。如ArrayList 类实现 List 接口。这意味着， 一个 ArrayList 可以被转换为一个 List。但是，一个 ArrayList 不是一个ArrayList 或 List。 1234567Pair&lt;Manager&gt; managerBuddies = new Pair&lt;&gt;(ceo, cfo);Pair&lt;Employee&gt; employeeBuddies = managerBuddies; // 非法employeeBuddies.setFirst(lowlyEmployee);Pair&lt;Manager&gt; managerBuddies = new Pair&lt;&gt;(ceo, cfo);Pair rawBuddies = managerBuddies; // OKrawBuddies.setFirst(new File(\". . .\")); // 只会出现编译警告 七、通配符类型1. 通配符的概念 通配符类型中，允许类型参数变化。 通配符限定与类型变量限定十分类似，而且还可以指定一个超类型限定。12345678910111213//表示任何泛型 Pair 类型， 它的类型参数是 Employee 的子类//类型 Pair&lt;Manager&gt; 和Pair&lt;Manager&gt; 是 Pair&lt;? extends Employee&gt; 的子类型//但是类型 Pair&lt;Manager&gt; 和Pair&lt;Manager&gt;之间没有任何关系public static void printBuddies(Pair&lt;? extends Employee&gt; p) //子类型限定通配符//将 getFirst 的返回值赋给一个 Employee 的引用完全合法。//但不能调用setFirst方法Pair&lt;Manager&gt; managerBuddies = new Pair&lt;&gt;(ceo, cfo);Pair&lt;? extends Employee&gt; wildcardBuddies = managerBuddies; // OKwildcardBuddies.setFirst(lowlyEmployee); // 会产生编译错误? extends Employee getFirst()void setFirst(? extends Employee) 2. 通配符的超类型限定1234567891011121314151617181920212223242526带有超类型限定的通配符可以向泛型对象写入（set方法），带有子类型限定的通配符可以从泛型对象读取（get方法）。void setFirst(? super Manager) ? super Manager getFirst()public static void minmaxBonus(Manager[] a, Pair&lt;? super Manager&gt; result) &#123; if (a.length == 0) return; Manager rain = a[0]; Manager max = a[0]; for (int i *1; i &lt; a.length; i++) &#123; if (min.getBonus() &gt; a[i].getBonus()) rain = a[i]; if (max.getBonus() &lt; a[i].getBonus()) max = a[i]; &#125; result.setFirst(min); result.setSecond(max); &#125;public static &lt;T extends Conparable&lt;? super T&gt; T min(T[] a)default boolean removeIf(Predicated&lt;? super E&gt; filter)&#123; ArrayList&lt;Employee&gt; staff = . .; Predicate&lt;Object&gt; oddHashCode = obj -&gt; obj.hashCode() %2 != 0; staff.removelf(oddHashCode):&#125; 3. 无限定通配符12345678910111213//getFirst 的返回值只能赋给一个 Object。setFirst 方法不能被调用， 甚至不能用 Object 调 用。? getFirst()void setFirst(?)//可以调用 setFirst(null)。public static boolean hasNulls(Pair&lt;?&gt; p) &#123; return p.getFirst() = null || p.getSecond() =null; &#125;//通过将 hasNulls 转换成泛型方法，可以避免使用通配符类型,public static &lt;T&gt; boolean hasNulls(Pair&lt;T&gt; p) 4. 通配符捕获123456789101112131415161718//通配符不是类型变量，因此，不能在编写代码中使用“？”作为一种类型。? t = p.getFirst(); // Error//通配符捕获public static &lt;T&gt; void swapHelper(Pair&lt;T&gt; p) &#123; T t = p.getFirst(); p.setFirst(p.getSecond()); p.setSecond(t); &#125;public static void swap(Pair&lt;?&gt; p) &#123; swapHelper(p); &#125; //参数T 捕获通配符public static void maxminBonus(Manager ] a, Pair&lt;? super Manager&gt; result) &#123; minmaxBonus(a, result); PairAlg.swap(result); // OK swapHelper captures wildcard type&#125; 八、反射和泛型1. 泛型 Class 类//反射不能获得泛型类型参数的太多信息，因为它们会被擦除。 1234567T newInstance() //返回无参数构造器构造的一个新实例。T cast(Object obj) //如果 obj 为 null 或有可能转换成类型 T， 则 返 回 obj ; 否 则 拋 出 BadCastException异常。T[ ] getEnumConstants( ) //如果 T 是枚举类型， 则返回所有值组成的数组，否则返回 null。Class&lt;? super T&gt; getSuperclass( ) //返回这个类的超类。如果 T 不是一个类或 Object 类， 则返回 null。Constructor&lt;T&gt; getConstructor(Class... parameterTypes) Constructor&lt;T&gt; getDeclaredConstructor(Class... parameterTypes) //获得公有的构造器， 或带有给定参数类型的构造器。T newlnstance(0bject... parameters) //返回用指定参数构造的新实例。 2. 使用 Class 参数进行类型匹配123456//Employee.class 是类型 Class&lt;Employee&gt; 的一个对象。makePair 方法的类型参数 T 同 Employee匹配， 并且编译器可以推断出这个方法将返回一个 Pair&lt;Employee&gt;。public static &lt;T&gt; Pai r&lt;T&gt; makePair(Class&lt;T&gt; c) throws InstantiationException, IllegalAccessException&#123;return new Pairo(c.newInstance(), c.newInstance()); &#125;makePair(Employee.class) 3. 虚拟机中的泛型类型信息可以使用反射 API 来确定： 这个泛型方法有一个叫做 T 的类型参数。这个类型参数有一个子类型限定，其自身又是一个泛型类型。这个限定类型有一个通配符参数。这个通配符参数有一个超类型限定。这个泛型方法有一个泛型数组参数。","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Java中的异常、断言和日志","date":"2020-05-23T02:09:05.000Z","path":"2020/05/23/Java基础知识/Java中的异常、断言和日志/","text":"一、处理错误1. 异常分类所有的异常都是由 Throwable 继承而来的，异常的继承层次如下： Error: 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象,因为我们对其没有任何控制能力。 Exception：由程序错误导致的异常属于 RuntimeException ; 而程序本身没有问题， 但由于像 I/O 错误这类问题导致的异常属于其他异常。 派生于RuntimeException的异常：错误的类型转换;数组访问越界;访问 null 指针。这些异常也不该声明，因为这些运行时错误完全在我们的控制之下。 不是派生于RuntimeException的异常: 试图在文件尾部后面读取数据; 试图打开一个不存在的文件; 试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在。 非受查异常：派生于Error类或 RuntimeException 类的所有异常称为非受查异常。 受查异常: 所有其它异常。编译器将核查是否为所有的受査异常提供了异常处理器。否则代码不能通过编译。 2. 声明受查异常 一个方法必须声明(throws)所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生（ RuntimeException)。 若方法在运行时真的抛出了一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理它。 如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用和更多。 如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。而是必须捕获所有受查异常。 抛出异常的情况有4种： 调用一个抛出受査异常的方法； 程序运行过程中发现错误，并且利用throw语句抛出一个受查异常； 程序出现错误，例如，a[-1]=0 会抛出一个 ArraylndexOutOfBoundsException 这样的非受查异常。 Java 虚拟机和运行时库出现的内部错误。 如果类中的一个方法声明将会抛出一个异常， 而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常， 或者这个类的任意一个子类的异常。 在 Java中，没有 throws 说明符的方法将不能抛出任何受查异常。 1234567class MyAnimation&#123; public Image loadlmage(String s) throws IOException,FileNotFoundException,EOFException &#123; ... &#125; &#125; 3. 如何抛出异常 找到一个合适的异常类。 创建这个类的一个对象。 使用throw关键字将对象抛出。 如果只是抛出异常而不在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。即一旦方法抛出了异常，这个方法就不可能返回到调用者，除非进行异常捕获。 123456789101112String readData(Scanner in) throws EOFException //声明异常&#123; while (…) &#123; if (!in.hasNext()) &#123; if (n &lt; len) throw new EOFException(); //抛出异常 &#125; &#125; return s;&#125; 4. 创建异常类123456789101112131415161718192021class FileFormatException extends IOException&#123; public FileFormatException()&#123;&#125; //定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器 public FileFormatException(String gripe) //超类 Throwable 的 toString 方法将会打印出这些详细信息， 这在调试中非常有用 &#123; super(gripe); &#125; &#125;String readData(BufferedReader in) throws FileFormatException&#123; while (…) &#123; if (!in.hasNext()) &#123; if (n &lt; len) throw new FileFornatException(); //抛出异常 &#125; &#125; return s;&#125; Throwable常用API 12345import java.lang.Throwable;Throwable( ) //构造一个新的 Throwabie 对象， 这个对象没有详细的描述信息。Throwable(String message ) //构造一个新的 throwable 对象， 这个对象带有特定的详细描述信息。习惯上，所有派生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器。String getMessage( ) //获得 Throwable 对象的详细描述信息。 二、捕获异常1. 捕获异常如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。 123456789101112131415public void read(String filename) &#123; try &#123; InputStream in = new Filei叩utStream(filename); int b; while ((b = in.read()3 != -1) &#123; process input &#125; &#125; catch (IOException exception) &#123; exception.printStackTrace(); &#125; &#125; 如果在try语句块中的任何代码抛出了一个在 catch 子句中说明的异常类,则程序将跳过 try语句块的其余代码并执行catch 子句中的处理器代码，否则将跳过 catch 子句。 如果方法中的任何代码拋出了一个在 catch 子句中没有声明的异常类型，或者仅仅是声明了可能抛出的异常，那么这个异常就会传递给调用者进行处理。 如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递。 如果想传递一个异常， 就必须在方法的首部添加一个 throws 说明符， 以便告知调用者这个方法可能会抛出异常。 通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。 2. 捕获多个异常12345678910111213141516171819202122232425262728293031//一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。try&#123; code that might throwexceptions&#125;catch (FileNotFoundException e) &#123; emergency action for missing files&#125;catch (UnknownHostException e) &#123; emergency action for unknown hosts&#125;catch (IOException e) &#123; emergency action for all other I/O problems&#125;//当捕获的异常类型彼此之间不存在子类关系且多个异常的处理动作一样时，同一个 catch 子句中可以捕获多个异常类型。try&#123; code that might throw exceptions&#125;catch (FileNotFoundException | UnknownHostException e) //捕获多个异常不仅会让你的代码看起来更简单，还会更高效。&#123; emergency action for missing files and unknown hosts //捕获多个异常时， 异常变量隐含为 final 变量。即不能在此处为e赋不同的值。&#125;catch (IOException e) &#123; emergency action for all other I/O problems&#125; 3. 再次抛出异常与异常链1234567891011121314151617181920212223242526272829303132333435363738//再次抛出异常的基本方法try&#123;access the database&#125;catch (SQLException e) &#123; throw new ServletException(\"database error: \" + e.getMessage()); &#125;//将原始异常设置为新异常的“原因”,这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。try&#123; access the database&#125;catch (SQLException e)&#123; Throwable se = new ServletException(\"database error\"); se.initCause(e); throw se;&#125;Throwable e = se.getCause(); //当捕获到异常时， 就可以使用下面这条语句重新得到原始异常//只想记录一个异常， 再将它重新抛出，而不做任何改变public void updateRecord() throws SQLException //抛出的异常比声明的异常更通用时，Java SE7之前编译器会指出这个方法可以抛出任何 Exception 而不只是 SQLException。&#123; try &#123; access the database &#125; catch (Exception e) //Java SE7之后，编译器会跟踪到 e 来自 try块。假设这个 try 块中仅有的已检査异常是 SQLException 实例，另外，假设 e 在catch 块中未改变，将外围方法声明为 throws //SQLException 就是合法的。 &#123; logger.log(level, message, e); throw e; &#125;&#125; 4. finally 子句在需要关闭资源时，通常需要使用finally子句。 12345678910111213141516171819InputStream in = new FileInputStream(. . .);try&#123; //1 //可能抛出异常的代码 //2&#125;catch(IOException e)&#123; //3 //展示异常信息 //4&#125;finally&#123; //5 in.close();&#125;//6 代码执行顺序有三种情况： 代码没有抛出异常：执行顺序为 1，2，5，6。 抛出一个在 catch 子句中捕获的异常： 当catch字句没有抛出异常将执行 1，3，4，5，6。 当catch字句抛出了一个异常，在执行完1，3，5之后异常将被抛回这个方法的调用者。 代码抛出了一个异常， 但这个异常不是由 catch 子句捕获的：在执行 1，5 后将异常抛给这个方法的调用者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//try 语句可以只有 finally 子句，而没有 catch 子句。InputStream in = . .try&#123; code that might throwexceptions&#125;finally&#123; in.close(); //不论try中是否遇到异常，该语句都将被执行&#125;//解耦合 try/catch 和 try/finally 语句块InputStrean in = . . .;//外层的try语句块仅确保报告出现的错误。try&#123; // 内层的try语句块仅确保关闭输入流。 try &#123; code that might throwexceptions &#125; finally &#123; in.close(); //若try语句中和finally语句中同时抛出异常则finally语句中的异常将会覆盖原始异常，转而抛出close方法的异常，此时需要用到带资源的try语句进行处理。 &#125; &#125;catch (IOException e) &#123; show error message&#125;//在try-catch-finally语句中使用return语句会带来的问题public static int f(int n) &#123; try &#123; int r = n * n; return r; //在方法返回前，finally 子句的内容将被执行。 &#125; finally &#123; if (n = 2) return 0; //这个返回值覆盖了原始的返回值。 &#125; &#125; 5. 带资源的 try 语句 若资源属于一个实现了 AutoCloseable 接口(close方法声明抛出Exception异常)或其子接口 Closeable 接口(close方法声明抛出IOException异常)的类，则try块退出时，会自动调用 resource.close()。 带资源的try语句会抛出原来的异常，而 close方法抛出的异常会“ 被抑制”，被抑制的异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。可以调用 getSuppressed 方法得到从 close 方法抛出并被抑制的异常列表。 带资源的 try 语句自身也可以有 catch 子句和一个 finally 子句。这些子句会在关闭资源之后执行。 1234567//不论正常退出还是存在异常，都会调用resource.close()方法，就好像使用了fianlly块。try (Scanner in = new Scanner(new FileInputStream(\"usr/share/dict/words\"), \"UTF-8\"); //可指定多个资源，不论块如何退出，in和out都会关闭而避免嵌套2个try-finally语句。 PrintWriter out = new PrintWriter(\"out.txt\"))&#123; while(in.hasNext()) out.println(in.next().toUpperCase()); &#125; 6. 分析堆栈轨迹元素堆栈轨迹是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。 123456789101112131415161718//Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述信息Throwable t = new Throwable();StringWriter out = new StringWri ter(); t.printStackTrace(new PrintWriter(out));String description = out.toString();//使用 getStackTrace 方法， 它会得到 StackTraceElement 对象的一个数组，可以在程序中分析这个对象数组。Throwable t = new Throwable();StackTraceElement[] frames = t.getStackTrace();for (StackTraceElement frame : frames) analyze frame//静态的 Thread.getAllStackTrace 方法， 它可以产生所有线程的堆栈轨迹 Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();for (Thread t : map.keySet()) &#123; StackTraceElement[] frames = map.get(t); analyze frames&#125; 三、使用异常机制的技巧 异常处理不能代替简单的测试； 不要过分地细化异常； 利用异常层次结构(应该寻找更加适当的子类或创建自己的异常类)； 不要压制异常(应该将很大概率不会抛出的异常关闭)； 早抛出：在检测错误时，“ 苛刻 ” 要比放任更好; 晚捕获：不要羞于传递异常(传递给高层要比捕获异常更加合适)。 123456789public Image loadImage(String s) &#123; try &#123; // code that threatens to throw checked exceptions &#125; catch (Exception e) //即使发生了异常也会被忽略。 &#123;&#125; // so there&#125; 四、使用断言1. 断言的概念断言(assert)机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。 123456789//均对表达式进行检测，若结果为 false, 则抛出一个 AssertionError 异常。assert 条件;assert 条件:表达式; //表达式将被传入 AssertionError 的构造器，并转换成一个消息字符串(表达式的唯一目的)，表达式的值不会被存储。assert x &gt;= 0; //断言 x 是一个非负数值assert x &gt;= 0 : x;//若希望条件也生成错误报告的一部分，就必须将它以字符串的形式传递给 AssertionError 对象。assert x &gt;= 0 : \"x &gt;= 0\"; 2. 启用和禁用断言 在默认情况下，断言被禁用。 在启用或禁用断言时不必重新编译程序，因为这是类加载器的功能，当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。 可以在某个类或整个包中使用断言。 有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。 启用和禁用所有断言的 -ea 和 -da 开关不能应用到那些没有类加载器的“系统类” 上,此时应使用 -enablesystemassertions/-esa 开关启用断言。 1234java -enableassertions MyAppjava -ea:MyClass -ea:com.mycompany.mylib... MyApp //开启 MyClass 类以及在 com.mycompany.mylib 包和它的子包中的所有类的断言。java -ea:... -da:MyClass MyApp //用选项 -disableassertions 或 -da 禁用某个特定类和包的断言 3. 使用断言完成参数检查 断言失败是致命的、不可恢复的错误，有时候会拋出一个断言错误，有时候会产生一个 null 指针异常，这完全取决于类加载器的配置。 断言检查只用于开发和测阶段。 1assert a != null; //检查参数是否非空 4. 为文档假设使用断言123456789101112if (i % 3 == 0)else if (i % 3 = 1)else // (i % 3 == 2)//为以上注释使用断言assert i &gt;= 0;if (i % 3 == 0)else if (i % 3 == 1)else&#123; assert i % 3 == 2; &#125; 12345import java.lang.ClassLoader;void setDefaultAssertionStatus( boolean b ) //对于通过类加载器加载的所有类来说， 如果没有显式地说明类或包的断言状态， 就启用或禁用断言。 void setCIassAssertionStatus(String className , boolean b ) //对于给定的类和它的内部类，启用或禁用断言。void setPackageAssertionStatus( String packageName , bool ean b ) //对于给定包和其子包中的所有类，启用或禁用断言。 void clearAssertionStatus() //移去所有类和包的显式断言状态设置， 并禁用所有通过这个类加载器加载的类的断言。 五、记录日志1. 基本日志12345//利用全局日志记录器生成简单的日志记录Logger.getClobal().info(\"File-&gt;Open menu item selected\");//在适当的地方（如 main 开始）调用将会取消所有的日志Logger.getClobal().setLevel(Level.OFF); 2. 高级日志 不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义日志记录器。 未被任何变量引用的日志记录器可能会被垃圾回收，因此需要用一个静态变量存储日志记录器的一个引用。 日志记录器名也具有层次结构,父与子之间将会共享某些属性，例如，若对父日志记录器设置了日志级别，它的子记录器也会继承这个级别。 默认的日志配置记录了 INFO 或更高级别的所有记录，如果将记录级别设计为 INFO 或者更低， 则需要修改日志处理器的配置。 应该使用 CONFIG、FINE, FINER 和 FINEST 级别来记录那些有助于诊断，但对于程序员又没有太大意义的调试信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//创建或获取记录器private static final Logger myLogger = Logger.getLogger(\"com.mycompany.myapp\");//7 个日志记录器级别SEVEREWARNINGINFOCONFIGFINEFINERFINEST//默认情况下，只记录前三个级别。 也可以设置其他的级別，还可以使用Level.ALL 开启所有级别的记录， 或者使用 Level.OFF 关闭所有级别的记录logger.setLevel(Level.FINE);//日志记录方法logger.warning(message);logger.fine(message);logger.log(Level.FINE, message);//默认的日志记录将显示包含日志调用的类名和方法名,但是,如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以调用 logp 方法获得调用类和方法的确切位置。void logp(Level l, String className, String methodName, String message)//用来跟踪执行流的方法,将生成 FINER 级别和以字符串 ENTRY 和 RETURN 开始的日志记录。void entering(String dassName , String methodName)void entering(String className , String methodName , Object param)void entering(String className , String methodName , Object[] params)void exiting(String className , String methodName)void exiting(String className , String methodName , Object result) //记录日志的常见用途是记录那些不可预料的异常。if (...) &#123; IOException exception = new IOException(\". . .\"); logger.throwing(\"com•mycompany.mylib.Reader\", \"read\", exception); //调用 throwing 可以记录一条 FINER 级别的记录和一条以 THROW 开始的信息。 throw exception; &#125;try&#123; ...&#125;catch (IOException e) &#123; Logger.getLogger(\"com.mycompany.myapp\").log(Level.WARNING , \"Reading image\", e); &#125; 3. 修改日志管理器配置 可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下，配置文件存在于：jre/lib/1ogging.properties。 也可将 java.util.logging.config.file 特性设置为配置文件的存储位置来使用另一个配置文件。 日志记录并不将消息发送到控制台上，这是处理器的任务。 在曰志管理器配置的属性设置不是系统属性，不会对日志记录器产生任何影响。 123456789//日志管理器在 VM 启动过程中初始化，这在 main 执行之前完成System.setProperty(\"java.util.logging.config.file\",file); //在main中调用该方法后也会调用 `LogManager.readConfiguration()` 来重新初始化曰志管理器。java -Djava.util.logging.config.file=configFile MainClass //使用另一个配置文件启动应用程序.level=INFO //编辑配置文件，修改默认的日志记录级别com.mycompany.myapp.level=FINE //指定自己的日志记录级别java.util.logging.ConsoleHandler.level=FINE //设置处理器级别以在控制台上看到 FINE 级别的消息 4. 本地化 本地化的应用程序包含资源包中的本地特定信息,资源包由各个地区的映射集合组成，日志消息本地化后让全球的用户都可以阅读它。。 每个资源包都有一个名字，要想将映射添加到一个资源包中，需要为每个地区创建一个文件(例如com/mycompany/logmessages_en.properties)，这些文件都是纯文本文件。 可以将这些文件与应用程序的类文件放在一起， 以便 ResourceBundle 类自动地对它们进行定位。 1234567891011121314151617//资源包中的映射readingFile=Achtung! Datei wird eingelesenrenamingFile=Datei wird umbenannt...//请求日志记录器时指定一个资源包Logger logger = Logger.getLogger(loggerName , \"com.mycompany.logmessages\");//为日志消息指定资源包的关键字logger.info(\"readingFile\");//若需要在本地化的消息中增加一些参数， 因此，消息应该包括占位符&#123;0&#125;、&#123;1&#125;Reading file &#123;0&#125;.Achtung! Datei &#123;0&#125; wird eingelesen.//调用下面的一个方法向占位符传递具体的值logger.log(Level.INFO, \"readingFile\", fileName);logger.log(Level.INFO, \"renamingFile\", new Object[] &#123; oldName , newName &#125;); 5. 处理器 默认情况下日志记录器将记录发送到 ConsoleHandler 中， 并由它输出到 System.err流中。 其他情况下，日志记录器还会将记录发送到父处理器中，而最终的处理器（命名为“ ”,所有日志记录器的父类）有一个 ConsoleHandler。 对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值。 123456789101112131415//日志管理器配置文件设置的默认控制台处理器的日志记录级别java.util.logging.ConsoleHandler.level =INFO//修改配置文件中的默认日志记录级别和处理器级别来改变处理器的默认设置Logger logger = Logger.getLogger(\"com.mycompany.myapp\");logger.setLevel(Level.FINE); logger.setUseParentHandlers(false); //原始日志记录器将会把所有等于或高于 INFO 级別的记录发送到控制台,为了避免看到重复记录，应该将useParentHandlers 属性设置为 false。Handler handler = new ConsoleHandler();handler.setLevel(Level.FINE); logger.addHandler(handler);//直接将记录发送到默认文件的处理器，即用户主目录的 javan.log 文件中， n 是文件名的唯一编号。也可发送到其他地方，但需要添加其它的处理器，如FileHandler(特定文件)、SocketHandler(特定主机)。//默认情况下， 记录被格式化为 XMLFileHandler handler = new FileHandler(); logger.addHandler(handler); 6. 过滤器 默认情况下，过滤器根据日志记录的级别进行过滤。每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤。 也可自定义过滤器，并调用setFilter 方法将一个过滤器安装到一个日志记录器或处理器中，注意一时刻最多只能有一个过滤器。 12//通过实现 Filter 接口并定义下列方法来自定义过滤器。boolean isLoggable(LogRecord record) //可以利用自己喜欢的标准，对日志记录进行分析，返回 true 表示这些记录应该包含在日志中。 7. 格式化器对日志记录自定义格式。 123456789//扩展 Formatter 类并覆盖下面这个方法实现自定义日志记录的格式String format(LogRecord record) //根据自己的愿望对记录中的信息进行格式化，并返冋结果字符串。String formatMessage(LogRecord record) //这个方法对记录中的部分消息进行格式化、 参数替换和本地化应用操作，可在format方法中调用//要覆盖下面两个方法，实现在已格式化的记录的前后加上一个头部和尾部String getHead (Handler h)String getTail (Handler h)//最后，调用 setFormatter 方法将格式化器安装到处理器中。 六、调试技巧 可以调用合适的方法打印或记录任意变量的值； 在每一个类中放置一个单独的 main方法对每一个类进行单元测试； 使用JUnit单元测试框架，详见http://junit.org 使用日志代理截获方法调用， 并进行日志记录，然后调用超类中的方法。 利用 Throwable 类提供的 printStackTace 方法。 —般来说，堆栈轨迹显示在 System.err 上。也可以利用 printStackTrace(PrintWriter s)方法将它发送到一个文件中，还可将其捕获到一个字符串中。 将一个程序中的错误信息保存在一个文件中。 不让非捕获异常的堆栈轨迹出现在 System.err 中。 用 -verbose 标志启动 Java 虚拟机观察类的加载过程有助于诊断由于类路径引发的问题。 -Xlint 选项告诉编译器对一些普遍容易出现的代码逻辑问题进行检査。 java 虚拟机增加了对 Java 应用程序进行监控和管理的支持，例如jconsole 图形工具，对于像应用程序服务器这样大型的、 长时间运行的 Java 程序来说特别重要。 使用 jmap 实用工具获得一个堆的转储并进行探查，其中显示了堆中的每个对象。 使用 -Xprof 标志运行 Java 虚拟机，就会运行一个基本的剖析器来跟踪那些代码中经常被调用的方法。剖析信息将发送给 System.out。输出结果中还会显示哪些方法是由即时编译器编译的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647System.out.println(\"x=\" + x);Logger.getClobal().info(\"nx=\" + x);//日志代理Random generator = newRandom() &#123; public double nextDouble() //当调用 nextDouble 方法时， 就会产生一个日志消息。 &#123; double result = super.nextDouble() &#123; Logger.getClobal().info(\"nextDouble: \" + result); return result; &#125; &#125;&#125;;Thread.duapStack(); //无须捕获异常，在代码的任何位置插入下面这条语句就可以获得堆栈轨迹//将对战轨迹捕获到一个字符串中StringWriter out = new StringWriter();new Throwable().printStackTrace(new PrintWriter(out));String description = out.toString();//将一个程序中的错误信息保存在一个文件中。java MyProgram 2&gt; errors.txt //捕获错误流java MyProgram 1&gt; errors.txt 2&gt;&amp;1 //在同一个文件中同时捕获 System.en•和 System.out//改变非捕获异常的处理器Thread.setDefaultUncaughtExceptionHandler( new Thread.UncaughtExceptionHandler() &#123; public void uncaughtException(Thread t, Throwable e) &#123; save information in logfile &#125;; &#125;);//对代码的简单逻辑进行检查javac -Xlint:fallthrough//显示虚拟机性能的统计结果jconsole processID//转储堆中的内容进行探查jmap -dump:format=b, file=dumpFileName processIDjhat dumpFileName//通过浏览器进人丨oCalhOSt:7000, 将会运行一个网络应用程序，借此探查转储对象时堆的内容。","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Java中的接口、lambda 表达式与内部类","date":"2020-05-21T02:09:05.000Z","path":"2020/05/21/Java基础知识/Java中的接口、lambda 表达式与内部类/","text":"一、接口1. 接口概念接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义，即必须实现接口中定义的所有方法。一个类可以实现（implement)—个或多个接口，并在需要接口的地方,随时使用实现了相应接口的对象。 接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字public。不过，在实现接口时，必须把方法声明为 public;否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。 接口中的域将被自动设为 public static final。接口绝不能含有实例域。java SE8之后，接口可以定义和实现静态方法(public static)以及默认方法(default)。 Java是一种强类型语言：在调用方法的时候，编译器将会检查这个方法是否存在。 12345678910111213141516171819202122232425262728293031323334353637383940414243//Comparable 接口public interface Comparable&#123;s ////实现该接口的类必须实现此方法 int compareTo(Object other); //实现该方法附加要求：在调用X.compareTo(y)的时候，这个方法必须确实比较两个对象的内容，并返回比较的结果。当x小于y时，返回一个负数；当x等于 时，返回0； //否则返回一个正数。 &#125;class Employee implements Comparable&#123; public int compareTo(Object otherObject) &#123; Employee other = (Employee) otherObject; //需要进行强制类型转换，不推荐 return Double.compare(salary, other.salary); &#125;&#125;//在 JavaSE 5.0 中，Comparable 接口已经改进为泛型类型。public interface Comparable&lt;T&gt; &#123; int compareTo(T other); &#125;class Employee implements Comparable&lt;Employee&gt; //推荐方式&#123; public int compareTo(Employee other) &#123; return Double.compare(salary, other.salary); //x &lt; y 时，Double.compare(x, y) 调用会返回 -1 ; 如果 x &gt; y 则返回 1。 &#125;&#125;//Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求对象所属的类必须实现了 Comparable 接口，因为要向 sort 方法提供对象的比较方式。 Employee[] staff = new Employee[3];staff[0] = new Employee (\"Harry Hacker\" , 35000);staff[1] = new Employee (\"Carl Cracker\" , 75000);staff[2] = new Employee (\"Tony Tester\" , 38000);Arrays.sort(staff) ;static void sort( Object[] a ) //使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了Comparable 接口的类， 并且元素之间必须是可比较的。int compareTo(T other) //用这个对象与 other 进行比较。如果这个对象小于 other 则返回负值； 如果相等则返回0；否则返回正值。static int compare(int x , int y) //如果 x &lt; y 返回一个负整数；如果 x 和 y 相等，则返回 0; 否则返回一个负整数。static int compare(double x , double y) //如果 x &lt; y 返回一个负数；如果 x 和 y 相等则返回 0; 否则返回一个负数 与 equals 方法一样，compareTo方法在继承过程中有可能会出现子类父类对象混合比较的问题。修改方式和equals一样，有两种不同情况，即根据子类语义是否改变来决定是用getClass方法还是instanceof方法检查类型是否一致。 12345678class Manager extends Employee&#123; public int compareTo(Employee other) &#123; if (getClass() != other.getClass()) throw new ClassCastException(); //若子类语义发生改变 ... &#125;&#125; 2. 接口的特性 接口不是类，尤其不能使用 new 运算符实例化一个接口,但可以声明接口的变量，接口变量必须引用实现了接口的类对象。 与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。 接口可以只定义常量而不定义方法，但这样应用接口似乎有点偏离了接口概念的初衷，最好不要这样使用它。 1234567891011121314151617181920//接口的声明和引用Comparable x;x = new Employee(...);if (anObject instanceof Comparable) &#123; . . . &#125; //可以使用instance 检查一个对象是否实现了某个特定的接口//接口的继承或扩展public interface Moveable&#123; void move(double x, double y); &#125;public interface Powered extends Moveable&#123; double milesPerGallon(); double SPEED.LIHIT = 95; //接口不能包含实例域或静态方法，但却可以包含常量 //接口中的域将被自动设为 public static final。&#125;class Employee implements Cloneable, Comparable //类可以实现多个接口，却只能拥有一个超类 3. 接口与抽象类接口与抽象类的区别在于一个类可以实现多个接口，而一个类只能扩展一个抽象类，Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂，效率也会降低。而接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。 4. 静态方法在 Java SE 8 中，允许在接口中增加静态方法，但是认为这有违于将接口作为抽象规范的初衷，通常的做法都是将静态方法放在伴随类中，例如java标准库中出现的Collection/Collections 或 Path/Paths等成对的接口和实用工具类。 12345678//可以为 Path 接口增加静态方法，如此伴随类paths就不再必要了public interface Path&#123; public static Path get(String first, String... more) &#123; return FileSystems.getDefault().getPath(first, more); &#125;&#125; 5. 默认方法可以为接口方法提供一个默认实现。必须用 default 修饰符标记，默认方法可以调用任何其他方法，实现该接口的类继承该方法且无需覆盖默认方法。有些情况下，默认方法可能很有用。 1234567891011121314151617181920//Collection 接口可以定义一个默认方法isEmpty，这样实现 Collection 的程序员就不用操心实现 isEmpty 方法了。public interface Collection&#123; int size(); // An abstract method default boolean isEmpty() &#123; return size() = 0; &#125;&#125;//没有太大用处， 因为 Comparable 的每一个实际实现都要覆盖这个方法。public interface Comparable&lt;T&gt;&#123; default int compareTo(T other) &#123; return 0; //所有元素都相等 &#125;&#125;public class Bag implements Collection 默认方法的一个重要用法是“接口演化”,假设之后为Collection接口又增加了一个 stream 非默认方法，那么 Bag 类将不能编译，即为接口增加一个非默认方法不能保证“源代码兼容”。不过， 假设不重新编译这个类，而只是使用原先的一个包含这个类的 JAR 文件。这个类仍能正常加载，程序仍然可以正常构造 Bag 实例，不会出现编译错误(即为接口增加方法可以保证“二进制兼容”)，不过如果程序在运行时在一个 Bag 实例上调用 stream方法，就会出现一个 AbstractMethodError。 将方法实现为一个默认方法就可以正常编译Bag类，另外如果没有重新编译而直接加载这个类， 并在一个 Bag 实例上调用 stream 方法， 将调用 Collection.stream 方法。 6. 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，java解决该冲突的规则为： 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。即”类优先”规则。 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。 若两个接口都没有为共享方法提供默认实现，则不会存在冲突。由于“java的类优先规则”，千万不要让一个接口中的默认方法重新定义 Object 类中的某个方法，因为这样的方法绝对无法超越 Object.toString 或 Objects.equals。 二、接口示例1. 接口与回调回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。 1234567891011121314ActionListener listener = new TimePrinter();Timer t = new Timer(10000, listener); //定时器需要知道调用哪一个方法，并要求传递的对象所属的类实现了java.awt.event 包的 ActionListener 接口。t.start();class TimePrinter implements ActionListener&#123; public void actionPerformed(ActionEvent event) &#123; System.out.println(\"At the tone, the time is \" + new Date()); Toolkit.getDefaultToolkit().beep(); //发出一声铃响。 &#125; &#125;Timer(int interval , ActionListener listener) //构造一个定时器， 每隔 interval 毫秒通告 listener—次 2. Comparator 接口利用Arrays.sort的数组和比较器(comparator)版本可以改变String类的比较规则，其中比较器是实现了 Comparator 接口的类的实例。 123456789101112131415public interface Comparators&#123; int compare(T first, T second); &#125;class LengthComparator implements Comparator&lt;String&gt; &#123; public int compare(String first, String second) &#123; return first.length() - second.length(); &#125; &#125;String[] friends = &#123; \"Peter\", \"Paul\", \"Mary\" &#125;;Arrays,sort(friends, new LengthComparator()); 3. 对象克隆(Cloneable 接口) 这个接口从超类Object类中继承了一个安全的 clone 方法，它没有指定clone 方法。只是作为一个标记接口，指示类设计者了解克隆过程。 clone 方法是 Object 的一个 protected 方法，只能由其子类对象克隆其自己，即子类的方法中只能调用其所属类的clone方法，而不能调用其它子类对象的clone方法。 默认的克隆操作是浅拷贝，并没有克隆对象中引用的其他对象，这样一来，原对象和克隆的对象仍然会共享一些域信息。 如果原对象和浅克隆对象共享的子对象是不可变的(或子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用)，那么这种共享就是安全的。 不过，通常子对象都是可变的，必须重新定义 clone 方法来建立一个深拷贝，同时克隆所有子对象。 即使 clone 的默认（浅拷贝）实现能够满足要求， 还是需要实现 Cloneable 接口， 将 clone重新定义为 public，再调用 super.clone(),否则会生成一个受査异常CloneNotSupportedException。 子类只能调用受保护的 clone 方法来克隆它自己的对象。 必须重新定义 clone 为 public 才能允许所有方法克隆对象。 123456789101112131415161718class Employee implements Cloneable&#123; //如果在一个对象上调用 clone, 但这个对象的类并没有实现 Cloneable 接口，Object 类 的 clone 方法就会拋出异常 public Employee clone() throws CloneNotSupportedException &#123; // call Object.clone() Employee cloned = (Employee) super.clone() ; // clone mutable fields cloned.hireDay = (Date) hireDay.clone(); return cloned; &#125;&#125;//所有数组类型都有一个 public 的 clone 方法， 而不是 protected: 可以用这个方法建立一个新数组， 包含原数组所有元素的副本。int[] luckyNumbers = &#123; 2, 3, 5, 7, 11, 13 &#125;;int[] cloned = luckyNumbers.done();cloned[5] = 12; // 不会改变luckyNumbers[5] 三、lambda 表达式1. 为什么引入 lambda 表达式 lambda 表达式是一个可传递的代码块，该代码块可传递到某个对象，可以在以后执行一次或多次，实现回调，类似以上ActionListener 的 actionPerformed方法。Java 是一种面向对象语言，不能直接传递代码段，必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码，利用lambda表达式可以让这种形式的代码块表达的更加简洁。 2. lambda 表达式的语法带参数变量的表达式就被称为 lambda 表达式，lambda 表达式就是一个代码块， 以及必须传入代码的变量规范。 12345678910111213141516171819//参数， 箭头（-&gt;) 以及一个表达式。无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是会由上下文推导得出。(String first, String second) -&gt; first.length() - second.length() //可以在需要 int 类型结果的上下文中使用。//代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 &#123;&#125;中，并包含显式的 return语句。(String first, String second) -&gt; &#123; if (first.length() &lt; second.length()) return -1; else if (first.length() &gt; second.length()) return 1; else return 0; &#125;//lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样() -&gt; &#123; for (int i = 100;i &gt;= 0;i-- ) System.out.println(i);&#125;//如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); //编译器可以推导出 first 和 second 必然是字符串，因为这个 lambda 表达式将赋给一个字符串比较器。//如果方法只有一个参数， 而且这个参数的类型可以推导得出，那么甚至还可以省略小括号ActionListener listener = event -&gt; System.out.println(\"The time is \" + new Date()\"); 12345678910//labmda表达式的应用Arrays.sort(planets, (first, second) -&gt; first.length() - second .length());Timer t = new Timer(1000, event -&gt; System.out.println (\"The time is \" + new Date()));ActionListener listener = event -&gt; &#123; System.out.println(text); Toolkit.getDefaultToolkitO.beep();&#125;;new Timer(delay, listener).start(); 如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，这是不合法的。 3. 函数式接口 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式，这种接口称为函数式接口。 最好把 lambda 表达式看作是一个函数，而不是一个对象， 另外要接受 lambda 表达式可以传递到函数式接口。 在 Java 中，对 lambda 表达式所能做的也只是能转换为函数式接口。java保持了接口概念而没有增加函数类型。 1234567891011121314151617//此包中定义了很多非常通用的函数式接口。import java.util.function;//在底层， Arrays.sort 方法会接收实现了 Comparator&lt;String&gt; 的某个类的对象。在这个对象上调用 compare 方法会执行这个 lambda 表达式的体。Arrays.sort (words, (first, second) -&gt; first.length() - second.length()) ;//接口BiFunction&lt;T, U, R&gt; 描述了参数类型为 T 和 U 而且返回类型为 R 的函数。可以将lambda表达式保存在该类型的变量中。BiFunction&lt;String, String, Integer&gt; comp = (first, second) -&gt; first.length() - second.length();//接口 Predicatepublic interface Predicate&lt;T&gt; &#123; boolean test(T t); // Additional default and static methods //可以有其它非抽象方法，但抽象方法只能有一个。&#125;//ArrayList 类有一个 removeIf 方法， 它的参数就是一个 Predicate。这个接口专门用来传递lambda 表达式。list.removeIf(e -&gt; e == null); //从一个数组列表删除所有 null 值。 4. 方法引用 有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作，故可直接将该方法的表达式传递到此处，该表达式称为方法引用，要用:: 操作符分隔方法名与对象或类名。 类似于 lambda 表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。 如果有多个同名的重载方法， 编译器就会尝试从上下文中找出你指的那一个方法。 可以在方法引用中使用 this 参数，使用super也是合法的。 12345678910111213//方法引用的格式有三种//方法引用等价于提供方法参数的 lambda 表达式。object::instanceMethod Class::staticMethodClass::instanceMethod//方法引用的应用Timer t = new Timer(1000, System.out::println); //System.out::println 等价于 lambda 表达式 x -&gt; System.out.println(x)Math::pow; //等价于（x，y) -&gt; Math.pow(x, y)。Arrays.sort(strings，String::conpareToIgnoreCase) //String::conpareToIgnoreCase等同于 (x, y) -&gt; x.compareToIgnoreCase(y)this::equals //等同于 x -&gt; this.equals(x)。super::instanceMethod 5. 构造器引用 构造器引用与方法引用很类似，只不过方法名为 new,编译器会根据上下文调用某个确定的构造器。 可以用数组类型建立构造器引用。 Java 有一个限制，无法构造泛型类型 T 的数组。 1234567ArrayList&lt;String&gt; names = ...;Stream&lt;Person&gt; stream = names.stream().map(Person::new);List&lt;Person&gt; people = stream.collect(Collectors.toList());int[]::new //等价于 lambda 表达式 x -&gt; new int[x]Person[] people = stream.toArray(Person[]::new); 6. 变量作用域 lambda 表达式由3部分组成：一个代码块；参数；自由变量的值，指非参数而且不在代码中定义的变量。 自由变量被lambda表达式捕获：表示 lambda 表达式的数据结构必须存储自由变量的值。可以把一个 lambda 表达式转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中。 在 Java 中，lambda 表达式就是闭包。 要确保所捕获的变量是最终变量，在 lambda 表达式中，只能引用值不会改变的变量(不论是在lambda中改变还是在外部改变)，否则并发执行多个动作时就会不安全。 lambda 表达式的体与嵌套块有相同的作用域。在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。 在一个 lambda 表达式中使用 this 关键字时， 是指创建这个 lambda 表达式的方法的 this参数。 1234567891011121314151617181920212223public static void repeatMessage(String text, int delay) &#123; ActionListener listener = event -&gt; &#123; System.out.println(text); //在这里，text 总是指示同一个 String 对象，所以捕获这个变量是合法的。 Toolkit.getDefaultToolkit().beep(); &#125;; new Timer(delay, listener).start();&#125;Path first = Paths.get(\"usr/bin\");Couparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); //Errorpublic class Application&#123; public void init() &#123; ActionListener listener * event -&gt; &#123; System.out.print n(this.toString()); //this.toString() 会调用 Application 对象的 toString方法 &#125; &#125;&#125; 7. 处理lambda表达式使用 lambda 表达式的重点是延迟执行，需要延迟执行的原因如下： 在一个单独的线程中运行代码；多次运行代码；在算法的适当位置运行代码（例如， 排序中的比较操作；）发生某种情况时执行代码（如， 点击了一个按钮， 数据到达， 等等；）只在必要时才运行代码。 1234567891011121314151617public static void repeat(int n, Runnable action) &#123; for (int i = 0; i &lt; n; i++) action.run(); //调用 action.run() 时会执行这个 lambda 表达式的主体&#125;public interface IntConsumer&#123; void accept(int value); &#125;public static void repeat(int n, IntConsumer action) &#123; for (int i = 0; i &lt; n; i++) action.accept(i); //告诉这个动作它出现在哪一次迭代中&#125;//大多数标准函数式接口都提供了非抽象方法来生成或合并函数。Predicate.isEqual(a); //等同于 a::equalsPredicate.isEqual(a).or(Predicate.isEqual(b)); //等同于 x -&gt; a.equals(x) || b.equals(x) 如果使用注解@FunctionalInterface标记一个自己设计的接口，该接口只有一个抽象方法，则若无意中增加了另一个非抽象方法， 编译器会产生一个错误消息。另外 javadoc 页里会指出你的接口是一个函数式接口。 8. 再谈 ComparatorComparator 接口包含很多方便的静态方法来创建比较器。 这些方法可以用于 lambda 表达式或方法引用。静态 comparing 方法取一个“键提取器” 函数，它将类型 T 映射为一个可比较的类型。(如 String)。对要比较的对象应用这个函数， 然后对返回的键完成比较。 123456789Arrays.sort(people,Comparator.comparing(Person::getName)); //按名字对这些对象排序Arrays.sort(people,Comparator.comparing(Person::getlastName).thenConiparing(Person::getFirstName)); //如果两个人的姓相同， 就会使用第二个比较器。Arrays.sort(people, Comparator.comparing(Person::getName, (s, t) -&gt; Integer.compare(s.length(), t.length()))); //根据人名长度完成排序//comparing 和 thenComparing 方法都有变体形式，可以避免 int、 long 或 double 值的装箱。Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length())); Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder()))); //使用nullsFirst 和 nullsLast 适配器可使在遇到 null 值时不会抛出异常naturalOrder().reversed(); //让比较器逆序比较 四、内部类使用内部类的主要原因： 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。 内部类可以对同一个包中的其他类隐藏起来。 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。 1. 使用内部类访问对象状态 内部类位于外部类的内部，但不是每个外部类对象都有一个内部类对象的实例域，内部类对象是由外部类的方法构造的。 内部类既可以访问自身的数据域，也可以直接访问创建它的外围类对象的所有成员(包括private成员和静态成员)。即使用内部类可以不必提供仅用于访问其他类的访问器。 外部类只能通过创建成员内部类的对象，再通过指向这个对象的引用来访问。 只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。若内部类声明为私有的，则只有外部类的方法才能够构造内部类对象。 内部类能够访问外部类成员的原因是内部类的对象总有一个隐式引用，它指向了创建它的外部类对象，这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。因为 TimePrinter 类没有定义构造器，所以编译器为这个类生成了一个默认的构造器。 123456789101112131415161718192021222324252627class TalkingClock&#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) &#123; this.interval = interval; this.beep = beep; &#125; public void start() &#123; ActionListener listener = new TimePrinter(); //当在 start 方法中创建了 TimePrinter 对象后，编译器就会将 this 引用传递给当前的语音时钟的构造器: //ActionListener listener = new TimePrinter(this); Timer t = new Timer(interval, listener); t.start(); &#125; public class TimePrinter implements ActionListener &#123; public void actionPerformed(ActionEvent event) //因为 TimePrinter 类没有定义构造器，所以编译器为这个类生成了一个默认的构造器： &#123; //public TimePrinter(TalkingGock clock)&#123;outer = clock;&#125; System.out.println(\"At the tone, the time is \" + new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); //if(beep)等价于outer.beep outer 不是 Java 的关键字,只是用它说明内部类中的机制 &#125; &#125;&#125; 2. 内部类的特殊语法规则123456789101112131415161718//使用外围类引用的正规语法OuterClass.thispublic void actionPerformed(ActionEvent event) &#123; if(TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep(); &#125;//明确地编写内部对象的构造器语法规则outerObject.new InnerClass(construction parameters)ActionListener listener = this.new TimePrinter(); //this 限定词是多余的,不过，可以通过显式地命名将外围类引用设置为其他的对象。TalkingClock jabberer = new TalkingClock(1000, true);TalkingClock.TimePrinter listener = jabberer.new TimePrinter();//在外围类的作用域之外，可以这样引用内部类：OuterClass.InnerClass 内部类中声明的所有静态域都必须是 final,因为对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是 final,它可能就不是唯一的。 内部类不能有 static 方法。 3. 内部类是否有用、必要和安全当使用了内部类的时候，编译器做了这样一件事：它在外围类添加了一个静态方法 static boolean access$0(外部类);内部类方法将调用这个函数。这个是有风险的，因为任何人都可以通过access$0方法很容易的读取到外围类的私有域。黑客可以使用十六进制编辑器轻松创建一个用虚拟机指令调用这个函数的类文件。即如果内部类访问了私有数据域，就有可能通过附加在外围类所在的包中的其他类访问它们，应慎用。 4. 局部内部类 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。局部类有一个优势， 即对外部世界可以完全地隐藏起来。 局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。 1234567891011121314public void start() &#123; class TimePrinter implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println(\"At the tone, the time is \" + new Date()); if(beep) Toolkit.getDefaultToolkit.beep(); &#125; &#125; ActionListener listener = new TimePrinter(); Timer t = new Timer(interval, listener); t.start(); &#125; 5. 由外部方法访问变量//局部类不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须事实上为 final，一旦赋值就绝不会改变。 123456789101112131415public void start(int interval, boolean beep)&#123; class TimePrinter implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println(\"At the tone, the tiie is \" + new Date()); if(beep) Toolkit.getDefaultToolkit.beep(); &#125; &#125; ActionListener listener = new TimePrinter(); Timer t = new Timer(interval, listener); t.start(); //将调用actionPerformed方法，此时局部变量beep已经被销毁，因此编译器会在局部类内部自动生成一个beep的拷贝final boolean val$beep;当创建一个对象的时候，beep 就会 //被传递给构造器，并存储在 val$beep 域中。&#125; 6. 匿名内部类 如果只创建这个类的一个对象，就不必命名了，称为匿名内部类。 匿名内部类没有类名故不能有构造器，而是将构造器参数传递给超类构造器。且在内部类实现接口的时候，不能有任何构造参数。 使用匿名内部类的解决方案比较简短、更切实际、更易于理解。 使用匿名内部类可以实现事件监听器和其他回调，但不如lambda表达式简洁。 12345678910111213141516171819202122public void start(int interval, boolean beep) &#123; ActionListener listener = new ActionListener() //创建一个实现 ActionListener 接口的类的新对象，需要实现的方法 actionPerformed 定义在括号内。 &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println(\"At the tone, the time is \" + new Date())； if (beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125;; Timer t = new Timer(interval, listener); t.start(); &#125;//通用语法new SuperType(construction parameters) &#123; inner class methods and data //SuperType 可以是接口也可以是类。若是接口则必须实现它，若是类，则内部类就要扩展它。&#125;Person queen = new Person(\"Mary\"); // 一个Person对象Person count = new Person(\"Dracula\") &#123; . . . &#125;;// 一个扩展了Person类的内部类对象 双括号初始化技巧 123456//如果不再需要这个数组列表，最好让它作为一个匿名列表。invite(new ArrayList&lt;String&gt;() &#123;&#123; add(\"Harry\"); add(\"Tony\"); &#125;&#125;); //外层括号建立了 ArrayList 的一个匿名子类。内层括号则是一个对象构造块//生成日志或调试消息时， 通常希望包含当前类的类名//静态方法没有 this，在静态方法中获取所在类的类名方式如下：new Object()&#123;&#125;.getClass().getEnclosingClass(); //new Object()&#123;&#125; 会建立 Object 的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类。 7. 静态内部类 静态内部类使用static关键字声明，就不会对外部类对象产生引用，使用静态内部类通常只是为了把一个类隐藏在另外一个类的内部。 只有内部类可以声明为 static。 静态内部类对象是在静态方法中构造的。 与常规内部类不同，静态内部类可以有静态域和方法。 声明在接口中的内部类自动成为 static 和 public 类。 1234567891011121314151617181920212223242526class ArrayAlg&#123; public static class Pair &#123; private double first; private double second; public Pair(double f, double s) &#123; first = f; second = s; &#125; public static Pair minmax(doublet[] values) //ArrayAlg.Pair p = ArrayAlg.minmax(d); &#123; double min = Double.POSITIVE_NFINITY; double max = Double.NEGATIVE_INFINITY; for (double v : values) &#123; if (min &gt; v) min = v; if (max &lt; v) max = v; &#125; return new Pair(min, max); &#125; &#125;&#125; 五、代理1. 何时使用代理 代理类可以实现指定的接口，可以在运行时创建全新的类。这样就可以在编译时获得一个表示接口对象的确切类型。 不能在运行时定义指定接口和Object类中的全部方法，而是要提供一个调用处理器。调用处理器是实现了 InvocationHandler 接口的类对象。 无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用，并向其传递Method 对象和原始的调用参数。 调用处理器必须给出处理调用的方式。 1Object invoke(Object proxy, Method method, Object[] args) //实现调用处理器接口中的方法 2. 创建代理对象创建代理对象需要使用Proxy 类的 newProxylnstance 方法，它包含三个参数 一个类加载器，用 null 可表示使用默认的类加载器。 一个 Class 对象数组， 每个元素都是需要实现的接口。 一个调用处理器。 使用代理可机制可解决的问题，例： 路由对远程服务器的方法调用。 在程序运行期间，将用户接口事件与动作关联起来。 为调试， 跟踪方法调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TraceHandler implements InvocationHandler&#123; private Object target; public TraceHandler(Object t) &#123; target = t; public Object invoke (Object proxy, Method m, Object[] args) throws Throwable &#123; // 打印方法名和参数 System.out.print(target); //打印隐式参数 System,out.print(\".\" + m.getName() + \"(\"); //打印方法名 if (args != null) &#123; //打印显式参数 for (int i = 0; i &lt; args.length; i++) &#123; System,out.print(args[i]); if (i &lt; args.length - 1) System.out.print(\", \"); &#125; &#125; System,out.println(\")\"); // 调用真正的方法 return m.invoke(target, args); &#125;&#125;//构造用于跟踪方法调用的代理对象Object value = ...InvocationHandler handler = new TraceHandler(value) ; // 为一个或多个接口构造代理Class[] interfaces = new Class[] &#123;Comparable.class&#125;;Object proxy = Proxy.newProxylnstance(null , interfaces, handler); //无论何时用 proxy 调用某个方法， 这个方法的名字和参数就会打印出来，之后再用 value 调用它。//应用：使用代理对象对二分查找过程进行跟踪。Object[] elements = new Object[1000]; for (int i = 0; i &lt; elements.length; i ++) &#123; Integer value = i + 1; //Integer 类实现了 Comparable 接口。代理对象属于在运行时定义的类（它有一个名字， 如 $ProxyO) 这个类也实现了Comparable 接口,且会调用代理对象处理器的invoke方法。 InvocationHandler handler = new TraceHandler(value); Object proxy = Proxy.newProxyInstance(null, new Class[]&#123; Comparable.class &#125;,handler); elements[i] = proxy //数组代理&#125;Integer key = new Random().nextlnt(elements.length) + 1; int result = Arrays.binarySearch(elements, key) ; //查找元素,由于数组中填充了代理对象， 所以 compareTo 调用了 TraceHander 类中的 invoke 方法。这个方法打印出了方法名和参数，之后用包装好的 //Integer 对象调用 compareTo。if (result &gt;= 0) System.out.println(elements[result]); //打印元素//打印结果500.compareTo(288) 2SO.compareTo(288)375.compareTo(288)312. compareTo(288)281.compareTo(288)296.compareTo(288)288.compareTo(288)288.toString() //即使不属于 Comparable 接口，toString 方法也被代理，实际上有相当一部分的Object 方法都被代理。 Integer 类实际上实现了Comparable&lt;Integer&gt;。然而，在运行时，所有的泛型类都被取消，代理将它们构造为原 Comparable 类的类对象。 3. 代理类的特性 代理类是在程序运行过程中创建的，一旦被创建，就变成了常规类。 所有的代理类都扩展于 Proxy 类。一个代理类只有一个实例域———调用处理器，它定义在 Proxy 的超类中。 为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。 所有的代理类都覆盖了 Object 类中的方法 toString、 equals 和 hashCode。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的 invoke，Object 类中的其他方法（如 clone和 getClass) 没有被重新定义。 没有定义代理类的名字，Sun 虚拟机中的 Proxy类将生成一个以字符串 $Proxy 开头的类名。 对于特定的类加载器和预设的一组接口来说，只能有一个代理类。 代理类一定是 public 和 final。 12345678import java.lang.reflect.InvocationHandler//如果使用同一个类加载器和接口数组调用两次 newProxylustance方法的话， 那么只能够得到同一个类的两个对象Class proxyClass = Proxy.getProxyClass(null, interfaces); //可以利用 getProxyClass方法获得这个类Object invoke(Object proxy,Method method,Object[] args) //定义了代理对象调用方法时希望执行的动作。static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;...interfaces) //返回实现指定接口的代理类。static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler) //构造实现指定接口的代理类的一个新实例。所有方法会调用给定处理器对象的 invoke 方法。static boolean isProxyClass(Class&lt;?&gt; cl) //如果 cl 是一个代理类则返回 true。","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Codeup和PAT刷题记录——算法初步","date":"2020-05-20T08:45:22.000Z","path":"2020/05/20/算法笔记/算法初步/","text":"记录刷题过程中遇到的问题和技巧。 一、技巧总结1.排序1.1 简单选择排序总共进行n趟操作，每趟选出A[i，n]中最小的元素与A[i]交换。 123456789101112void selectSort()&#123; for(int i=1;i&lt;=n;i++)&#123; int k=i; for(int j=i;j&lt;=n;j++)&#123; if(A[j]&lt;A[k]) k=j; &#125; int temp=A[i]; A[i]=A[k]; A[k]=temp; &#125;&#125; 1.2 直接插入排序总共进行n-1趟，每趟将A[i]插入A[i-1,1]中合适位置。 12345678910void insertSort()&#123; for(int i=2;i&lt;=n;i++)&#123; int temp=A[i]; for(int j=i;j&gt;1;j--)&#123; if(temp&lt;A[j]) A[j]=A[j-1]; &#125; A[j]=temp; &#125;&#125; 1.3 C++标准模板库中的sort()由于c语言中的qsort函数涉及很多指针操作，且std中的sort()在实现中规避了经典快速排序中可能出现的导致实际时间复杂度退化到O(n2)的极端情况。使用C++头文件需要添加std的命名空间： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数cmp(非必填，默认递增排序)) //注意序列中的元素一定要有可比性才可以不写cmp函数，否则需指定cmp比较规则，例如结构体。//基本数据类型数组的排序 int double ...int A[6]=&#123;&#125;;bool cmp(int a, int b) &#123;return a&gt;b;&#125;sort(A,A+4,cmp); //将A[0]-A[3]从大到小排序//结构体的排序struct Node&#123; int x,y; char name[10];&#125;ssd[10];bool cmp(node a, node b)&#123; //若x不等，按x从大到小排序，否则按y从小到大排序。 if(a.x!=b.x) return a.x&gt;b.x; else return a.y &lt; b.y&#125;strcmp(a.name,b.name)&lt;0; //表示a.name字典序小于b.name的字典序。&lt;font color=Crmison&gt;注意！strcmp返回值不一定是-1或+1,故==-1写法错误。&lt;/font&gt;sort(ssd,ssd+3,cmp);//容器的排序vector&lt;int&gt; vi;vi.push_back(3);....//初始化bool cmp(int a, int b) &#123;return a&gt;b;&#125; //vector中类型为int型sort(vi.begin,vi.end,cmp);string str[3]=&#123;\"bbbb\",\"cc\",\"aaa\"&#125;;str[0]&gt;str[1]; //true,c++中string之间可直接比较大小。bool cmp(string str1,string str2)&#123;return str1.length &lt; str2.length;&#125; //按字符串长度递增排序sort(str,str+3);sort(str,str+3,cmp); 1.4 排名的实现分数不同排名不同，分数相同排名相同但占用一个排位：先排序：思路1：将排名这一项添加到结构体中进行记录，若当前个体分数等于上一个个体则排名等于上一个个体排名，否则当前个体排名等于数组下标+1。思路2：不记录进结构体，直接输出排名。 2. 散列2.1 散列的定义有些算法题消耗时间很长，需要利用空间换时间的策略，如将输入的数字作为数组下标来统计这个数出现的次数，而输入的数不一定为整数，且有可能出现冲突，即输入多个相同的数，这时就需要用到散列的策略。定义：将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素。可使用C++标准模板库中的map或reordered_mp直接使用整数hash的功能。散列常应用在查找某个字符串或数字是否出现或出现的次数。 2.2 整数散列其中直接定址法、平方取中法、除留余数法为散列方法；线性探查法(开放定址法)、平方探查法(开放定址法)、链地址法(拉链法)为解决冲突的方法。 2.2.1 直接定址法H(key)=keyH(key)=a*key+b 2.2.2 平方取中法取key的平方的中间若干位作为hash值，很少用。 2.2.3 除留余数法为最常用方法。H(key)=key%mod该方法可将一个较大的数变为可行的数组下标。表长TSize必须不小于mod，否则越界，一般取TSize=mod，且mod取素数可有效避免冲突。 2.2.4 线性探查法若H(key)位置被占用，则检查H(key)+1，H(key)+2,…，直到找到一个没被占用的位置，若超过了表长则回到表的首位继续循环查找。此方法容易出现扎堆现象，即表中连续若干个位置都被使用，一定程度上会降低效率。 2.2.5 平方探查法 该方法可避免扎堆现象。 若H(key)位置被占用，则检查H(key)+12，H(key)-12,H(key)+22,H(key)-22…，直到找到一个没被占用的位置，也可只进行正向平方探查。 若超过了表长则计算(H(key)+k2)%mod。 若H(key)-k2&lt;0,则计算((H(key)-k2)%TSize+TSize)%TSize;相当于将H(key)-k2不断加上TSize直到出现第一个非负数。 可证明，若k在[0，TSize)范围内都无法找到位置，那么当k&gt;=TSize时也一定无法找到位置。 2.2.6 链地址法（拉链法）设定一个数组链表，Link[0]-Link[mod-1],用Link[h]将所有H(key)=h的key链接起来。注意！以上方法一般都无需自己实现，除非必须模拟这些算法或提升效率，否则都可以直接使用标准模板库中的map函数来直接使用hash功能，C++11以后可以用unordered_map，速度更快。 2.3 字符串hash初步利用其它进制转换为10进制的策略，仅限字符串长度不是很长的情况。 若字符串均由大写字母构成：将26个大写字母视为26进制，转换为10进制。 若出现了小写字母，则将A-Z作为0—25,将a-z作为26-51(例如a-‘a’+26)，共52进制，转换为10进制。 若出现了数字，则可按照小写字母的处理方法增大进制数至62。 若能保证字符串末尾是数字则可将末尾的数字直接拼接上去。 ASCII码的hash值可用 字符-‘\\0’ 计算，因为’\\0’的ASCII码值为0。 3. 递归3.1 分治分治法三个步骤： 分解：将原问题分解为若干与原问题拥有相同或相似结构的子问题。子问题应当互相独立、没有交叉，否则不能使用分治法。 解决：递归求解所有子问题。 合并：将子问题的解合并为原问题的解。当子问题个数为1时，称为减治，如求n!,大于1则称为分治，如求Fibonacci数列。分治法既可以用递归手段也可用非递归手段去实现。 3.2 递归递归很适合用来实现分治思想。 3.2.1 递归的三要素出自https://www.zhihu.com/question/31412436/answer/683820765?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=697560822683041792&amp;utm_content=sec的讲解 明确函数想要做的事情(函数功能)。 寻找递归结束条件，避免程序一直调用自己，进入无底洞(递归边界)。需要找出当参数为什么时，递归结束，即能直接知道函数的结果，结束后需要返回或输出结果。 找出函数的等价关系式(递归式、递归调用)。最难也是最关键的一步。需要不断缩小参数的范围，且缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。这些条件一旦漏掉可能会导致死循环。 3.2.2 求n! 第一步，明确函数的功能1234//求n的阶乘int f(int n)&#123;&#125; 第二步，寻找递归结束条件123456//由于0！=1，不妨将f(0)=1作为递归边界int f(int n)&#123; if(n==0)&#123; return 1; &#125;&#125; 第三步，找出函数的等价关系式1234567//f(n)这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1)*n。int f(int n)&#123; if(n==0)&#123; return 1; &#125; else return f(n-1)*n;&#125; 3.2.3 求Fibonacci数列的第n项 第一步，明确函数的功能1234//求Fibonacci的第n项，1、1、2、3、5、8、13、21、34....int f(int n)&#123;&#125; 第二步，寻找递归结束条件123456//显然f(1)=f(2)=1,故可设置递归边界为n&lt;=2。int f(int n)&#123; if(n&lt;=2)&#123; return 1; &#125;&#125; 第三步，找出函数的等价关系式1234567//观察数列可轻易得到等价关系为f(n)=f(n-1)+f(n-2),int f(int n)&#123; if(n&lt;=2)&#123; return 1; &#125; return f(n-1) + f(n-2);&#125; 3.2.3 小青蛙跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 第一步，明确函数的功能1234//求青蛙跳上一个n级的台阶总共有多少种跳法int f(int n)&#123;&#125; 第二步，寻找递归结束条件123456//直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少。显然f(n)=1int f(int n)&#123; if(n&lt;=2)&#123; return n; &#125;&#125; 第三步，找出函数的等价关系式12345678910//每次跳的时候，小青蛙有两种跳法。即跳一个台阶或跳两个台阶。//第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。//第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。//所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。int f(int n)&#123; if(n&lt;=2)&#123; return n; &#125; ruturn f(n-1) + f(n-2);&#125; 3.2.4 反转单链表例如链表为：1-&gt;2-&gt;3-&gt;4。反转后为 4-&gt;3-&gt;2-&gt;1链表节点定义如下：1234class Node&#123; int date; Node next;&#125; 第一步，明确函数的功能1234//反转单链表，其中 head 表示链表的头节点。Node reverseList(Node head)&#123;&#125; 第二步，寻找递归结束条件123456//直接把链表压缩到只有一个节点和空表分析，若为空表或只有头节点存在则直接返回head节点。int reverseList(int n)&#123; if(head == null || head.next == null)&#123; return head; &#125;&#125; 第三步，找出函数的等价关系式 首先缩小范围分析，对2-&gt;3-&gt;4反转得到4-&gt;3-&gt;2并将递归的结果用一个新节点newList保存起来。1 这个节点我们并没有去碰它，所以1的 next 节点仍然是连接着2。 接下来只需要把节点 2 的 next 指向 1，然后把 1 的 next 指向 null即完成了反转。1234567891011121314151617int reverseList(int n)&#123; // 1.递归结束条件 if (head == null || head.next == null) &#123; return head; &#125; // 递归反转 子链表 Node newList = reverseList2(head.next); // 改变 1，2节点的指向。 // 通过 head.next获取节点2 Node t1 = head.next; // 让 2 的 next 指向 2 t1.next = head; // 1 的 next 指向 null. head.next = null; // 把调整之后的链表返回。 return newList;&#125; 3.2.5 递增输出n个数的全排列 第一步，明确函数的功能12345678//按从小到大输出1-n的全排列，即为每一位填入一个从1-n枚举的不重复的数字//P为当前排列，hashTable记录整数x是否已经在当前排列中，即P中const int maxn=11;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123;&#125; 第二步，寻找递归结束条件1234567891011//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列const int maxn=11;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; for(int i=1;i&lt;=n;i++) ptintf(\"%d\",P[i]); printf(\"\\n\"); return; &#125;&#125; 第三步，找出函数的等价关系式 首先处理index节点，枚举1-n，将第一个还未填入P中的值x填入P[index]中，并记录hashTable[x]=true。 接下来只需要处理下一个位置，即generateP(index+1); 当处理完p[index]=x的子问题后，还原hashTable[x]=false;123456789101112131415161718192021//输出从1-n的全排列，从index开始填const int maxn=11;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; for(int i=1;i&lt;=n;i++) ptintf(\"%d\",P[i]); printf(\"\\n\"); return; &#125; //枚举1-n，将x填入P[index]位置。 for(int x=index;x&lt;=n;x++)&#123; if(hashTable[x]==false)&#123; P[index]=x; hashTable[x]=true; generateP(index+1); hashTable[x]=false; &#125; &#125; &#125; 3.2.6 n皇后问题 第一步，明确函数的功能12345678//在一个n*n棋盘上放置n个皇后使其两两均不在同一行、同一列、同一条对角线上，求合法方案数。//考虑每行和没每列均只能放置一个皇后，问题归结为求全排列中的合法放置方案数，即求全排列中两两不在同一对角线的方案并统计。int count = 0;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123;&#125; 第二步，寻找递归结束条件1234567891011121314//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列//判断当前方案是否合法有两种方式，暴力法和回溯法//暴力法：在每一次递归边界遍历任两个皇后，判断是否在同一条对角线//回溯法：每次处理第index位时，遍历之前的皇后检查是否有冲突，若有冲突，则无需继续处理之后的位置，直接返回上一层即可。//回溯法比暴力法效率要高。int count = 0;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; //能到达递归边界的方案一定是合法方案 count++; return; &#125;&#125; 第三步，找出函数的等价关系式12345678910111213141516171819202122232425262728int count = 0;int n,P[maxn];bool hashTable[maxn]=&#123;false&#125;;void generateP(int index)&#123; if(index == n+1)&#123; //能到达递归边界的方案一定是合法方案 count++; return; &#125; //枚举1-n，将x填入P[index]位置。 for(int x=1;x&lt;=n;x++)&#123; if(hashTable[x]==false)&#123; bool flag = true; //true表示不会冲突 for(int pre=1;pre&lt;index;pre++)&#123; // if(abs(index-pre)==abs(x-P[pre]))&#123; flag=false; break; &#125; &#125; if(flag)&#123; P[index]=x; hashTable[x]=true; generateP(index+1); hashTable[x]=false; &#125; &#125; &#125; &#125; 3.2.7 递归的优化 记录重复计算的子问题递归有时候是会产生大量重复计算的，例如求Fibonacci的第n项，例如f(5)=f(4)+f(3)，而f(4)会重复计算f(3)，优化时可保存下来已经被计算过的子问题即arr[n]=f(n),若未计算过，则置arr[n]=-1。在递归时判断一下是否计算过，若计算过则直接取出结果即可，否则再进行递归计算。 1234567891011121314int f(int n)&#123; if(n &lt;= 2)&#123; return n; &#125; //先判断有没计算过 if(arr[n] != -1)&#123; //计算过，直接返回 return arr[n]; &#125;else&#123; // 没有计算过，递归计算,并且把结果保存到 arr数组里 arr[n] = f(n-1) + f(n-2); return arr[n]; &#125;&#125; 考虑是否可以递推实现递归往往都是自上往下递归的，直到递归到最底，再一层一层把值返回。但是当n比较大的时候栈空间可能会不够。这时候可以考虑自底向上的做法，这种做法被称为递推。例如Fibonacci数列的例子。 1234567891011121314public int f(int n) &#123; if(n &lt;= 2) return n; int f1 = 1; int f2 = 2; int sum = 0; for (int i = 3; i &lt;= n; i++) &#123; sum = f1 + f2; f1 = f2; f2 = sum; &#125; return sum; &#125; 4. 贪心4.1 简单贪心总是考虑当前状态下局部最优解，来使全局的结果达到最优。 4.2 开区间不相交问题题目描述给出n个开区间(x,y)，计算最多可以选择多少个区间，使得这些开区间两两没有交集。输入输入第一行为n表示n个开区间，第二行n个开区间对(x,y)。输出输出1行为方案个数。样例输入42 4 1 3 3 5 6 7样例输出3思路 按左端点从大到小排序，若左端点相同则按右端点从小到大排序 lastX记录上一个被选区间的左端点。 若当前区间的右端点在上一个区间左端点的左边(&lt;=)则方案数+1 4.3 闭区间选点问题题目描述给出n个闭区间[x,y]，计算最少需要确定多少个点，使得这些闭区中都至少存在一个点。输入输入第一行为n表示n个开区间，第二行n个闭区间对[x,y]。输出输出1行为方案个数。样例输入31 4 2 6 5 7样例输出2思路 按左端点从大到小排序，若左端点相同则按右端点从小到大排序 lastX记录上一个被选区间的左端点。 若当前区间的右端点在上一个区间左端点的左边(&lt;)则方案数+1 二、经典题目2.1 问题 B: 分组统计题目描述先输入一组数，然后输入其分组，按照分组统计出现次数并输出，参见样例。输入输入第一行表示样例数m，对于每个样例，第一行为数的个数n，接下来两行分别有n个数，第一行有n个数，第二行的n个数分别对应上一行每个数的分组，n不超过100。输出输出m行，格式参见样例，按从小到大排。样例输入173 2 3 8 8 2 31 2 3 2 1 3 1样例输出1={2=0,3=2,8=1}2={2=1,3=0,8=1}3={2=1,3=1,8=0}思路 利用一个二维矩阵A[i][j]记录数字j在组别i中出现的次数 flagS[j]和flagG[i]分别记录数字j和组别i是否出现，这里容易出错 找出最大组别编号和最大数字，若组号i和数字j均存在，则输出result[i][j] 易错点:组号i小于n，但样例数大小j范围未知，二维数组的第二维应初始化大一些，否则容易错误50%12345678910111213141516171819202122232425262728293031323334353637383940414243int main()&#123; int m,n; while(scanf(\"%d\",&amp;m)!=EOF)&#123; while(m--)&#123; scanf(\"%d\",&amp;n); //在循环内部定义数组就无须初始化为0了 int sample[110]=&#123;&#125;,flagS[2010]=&#123;&#125;,group[110]=&#123;&#125;,flagG[110]=&#123;&#125;; int maxs=0,maxg=0; //找出最大样例和最大组别，方便输出。 for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",sample+i); if(sample[i]&gt;maxs) maxs=sample[i]; flagS[sample[i]]=1; &#125; int result[110][2010]=&#123;&#125;; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",group+i); if(group[i]&gt;maxg) maxg=group[i]; flagG[group[i]]=1; //记录统计结果 result[group[i]][sample[i]]++; &#125; //输出统计结果 for(int i=0;i&lt;=maxg;i++)&#123; if(flagG[i]==1)&#123; printf(\"%d=&#123;\",i); for(int j=0;j&lt;=maxs;j++)&#123; if(flagS[j]==1)&#123; printf(\"%d=%d\",j,result[i][j]); if(j&lt;maxs) printf(\",\"); &#125; &#125; printf(\"&#125;\\n\"); &#125; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"}]},{"title":"Java中的继承","date":"2020-05-01T05:55:39.000Z","path":"2020/05/01/Java基础知识/Java中的继承/","text":"一、类、超类和子类1. 定义子类已存在的类称为超类、基类或父类; 新类称为子类、派生类或孩子类。在设计类时，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中。 12345678910111213141516171819202122232425262728293031323334353637public class Manager extends Employee //在 Java 中， 所有的继承都是公有继承&#123; //定义子类特有数据域 private double bonus; //定义子类特有方法 public void setBonus(double bonus) &#123; //属于 Employee 类的对象不能使用该方法，但Manager 类自动地继承了超类 Employee 中的方法。 this.bonus = bonus; &#125; //覆盖超类方法 public double getSalary() &#123; double baseSalary = super.getSalary(); //子类不能直接访问超类的私有域，应通过关键字super调用超类的域访问器来访问。 return baseSalary + bonus; &#125; public Manager(String name, double salary, int year, int month, int day) &#123; //如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。 //如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器， 则 Java 编译器将报告错误。 //调用构造器的语句只能作为另一个构造器的第一条语句出现。 super(name, salary, year, month, day); //通过 super调用超类构造器实现对超类私有域进行初始化 bonus = 0; &#125;&#125;Manager boss = new Manager(\"Carl Cracker\" , 80000, 1987, 12 , 15);boss.setBonus(5000);Employee[] staff = new Employee[3];staff[0] = boss; //变量 staff[0] 与 boss 引用同一个对象。但编译器将 staff[0]看成 Employee 对象。故staff[0]不能调用子类特有方法setBonus()staff[1] = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);staff[2] = new Employee(\"Tony Tester\" , 40000, 1990, 3, 15);for(Employee e : staff) //e 既可以引用 Employee 类型的对象，也可以引用 Manager 类型的对象。 System.out.println(e.getName() + \" \" + e.getSalary()); //虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。 super关键字与this引用不同，它不是一个对象引用，它表示的是当前对象的当前类的父类对象。 在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。 在覆盖方法时， 一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。称该方法具有可协变的返回类型 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。 子类对象引用调用的方法始终都是实例化的子类中的重写方法，只有明确调用了super.xxx关键词或者是子类中没有该方法时，才会去调用父类相同的同名方法。 多态：一个对象变量可以指示多种实际类型的现象被称为多态。动态绑定：在运行时能够自动地选择调用哪个方法的现象称为动态绑定。静态绑定：如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定。 2. 继承层次继承层次：由一个公共超类派生出来的所有类的集合被称为继承层次。继承链：从某个特定的类到其祖先的路径被称为该类的继承链。Java 不支持多继承(extends)。 3. 多态 即超类变量既可以引用一个超类对象， 也可以引用一个超类的任何一个子类的对象。 不能将一个超类的引用赋给子类变量。 1234567//在 Java 中，子类数组的引用可以转换成超类数组的引用， 而不需要采用强制类型转换。Manager[] managers = new Manager[10];Employee[] staff = managers; // OK//所有数组都要牢记创建它们的元素类型， 并负责监督仅将类型兼容的引用存储到数组中。//这里使用 new managers[10] 创建的数组是一个经理数组。如果试图存储一个 Employee 类型的引用就会引发 ArrayStoreException 异常。staff[0] = new Employee(\"Harry Hacker\", . . .); //ArrayStoreException 异常 4. 理解方法调用x.f(param)调用过程： 编译器査看对象的声明类型和方法名。编译器将会一一列举所有x所声明类中名为f的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）。 编译器进行重载解析。以获得需要调用的方法名字和参数类型。 编译器采用静态绑定或动态绑定方式生成一条调用f(param)的指令。 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。若没有则在其超类中寻找。 虚拟机预先为每个类创建了一个方法表, 其中列出了所有方法(包括继承的方法)的签名和实际调用的方法。这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。 5. 阻止继承：final 类和方法不允许扩展的类被称为 final 类。 1234567//如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。public final class Executive extends Manager&#123; public final String getName()&#123; //final方法不能被覆盖 return name; &#125;&#125; 6. 强制类型转换将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检査。但是只有引用子类变量的超类引用可以被强制类型转换为子类引用。一般只有在会使用到 Manager 中特有的方法时才需要进行类型转换。 1234567891011//只能在继承层次内进行类型转换。 //在将超类转换成子类之前，应该使用instanceof进行检查。Manager boss = (Manager)staff[0]; //okManager boss = (Manager)staff[1]; // Error //若未捕获ClassCastException 异常，程序就会终止执行。if(staff[1] instanceof Manager) &#123; boss = (Manager)staff[1];&#125;x instanceof C //若x为null则不会产生异常只是返回false。 7. 抽象类抽象类一般作为派生其他类的基类，而不作为想使用的特定的实例类。通常它只包含一些通用的属性和方法，而这些通用方法往往只是一个定义不需要具体的实现。 123456789101112131415161718192021//利用abstract关键字修饰方法就无需实现该方法//包含一个或多个抽象方法的类本身必须被声明为抽象的。//抽象类的子类也可以为抽象类//类即使不含抽象方法，也可以将类声明为抽象类。public abstract class Person&#123; private String name; public Person(String name)&#123; this.name = name; &#125; public abstract String getDescription(); //抽象类不能有函数体 public String getName()&#123; return name; &#125;&#125;//抽象类不能被实例化。可以定义一个抽象类的对象变量，但是不能构造抽象类对象，它只能引用非抽象子类的对象。Person p = new Student(\"Vinee Vu\" , \"Economics\"); 8. 受保护访问 由于类中的私有域对所有其他类包括子类都是不可见的，因此若子类的方法想访问超类的某个域或方法，可将超类中的方法或域声明为protected。但子类方法中只能访问属于该类的对象的protected方法而不能访问其它子类对象的受保护方法。 不过子类中的方法只能够访问子类对象中继承的超类的受保护域，而不能访问超类对象中的这个域，如此可避免滥用受保护机制。 在实际应用中，要谨慎使用 protected 属性。因为有可能会违背OOP提倡的数据封装原则。 受保护的方法更具有实际意义。它对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。 9. 控制可见性的4个访问修饰符private:仅对本类可见。public:对所有类可见。protected:对本包和所有子类可见。默认：对本包可见。其中只有public和默认可用于修饰类。 二、Object是所有类的超类 可以使用 Object 类型的变量引用任何类型的对象。 在 Java 中，只有基本类型不是对象。 所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。 123456Object obj = new Employee(\"Harry Hacker\", 35000);Employee e = (Employee)obj ;Employee[] staff = new Employee[10];obj = staff; // OKobj = new int[10]; // OK 1. equals方法是基类Object中的一个可覆盖方法，在基类中，该方法与==运算符等价，比较的都是对象的内存地址， 可在子类中覆盖改写该方法。 1234567891011121314151617181920212223242526272829public class Employee&#123; //equals方法改写原则 public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; //若引用同一个对象则返回true,实际是比较两个对象的默认hashcode是否相等 if (otherObject == null) return false; //若显示参数为null则返回false //比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测。 //如果所有的子类都拥有统一的语义，就使用 instanceof 检测。 //if (!(otherObject instanceof ClassName)) return false; if (getClass() != otherObject.getClass()) return false; //若两个对象所属的类不同则返回false，getClass 方法将返回一个对象所属的类 //比较两个相同类的不为null的对象的数据域是否相等 Employee other = (Employee)otherObject; //如果两个参数都为 null， Objects.equals(a，b) 调用将返回 true; 如果其中一个参数为 null ,则返回 false ; 否则， 如果两个参数都不为 null，则调用 a.equals(b) // //使用 =比较基本类型域，使用 equals 比较对象域。 return Objects.equals(name,other.name) &amp;&amp; salary == other.salary &amp;&amp; Object.equals(hireDay,other.hireDay);&#125;public class Manager extends Employee&#123; public boolean equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; //在子类中定义 equals 方法时，首先调用超类的 equals,若检测失败对象就不可能相等。 Manager other = (Manager)otherObject; return bonus == other.bonus; &#125; &#125; 2. 相等测试与继承设计equals方法的原则：自反性：对于任何非空引用 x, x.equals(x) 应该返回 true。对称性：对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true , x.equals(y) 也应该返回 true。传递性：对于任何引用 x、y 和 z, 如果 x.equals(y) 返回 true， y.equals(z) 返回 true, x.equals(z) 也应该返回 true。一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。对于任意非空引用 x, x.equals(null) 应该返回 false。 12static boolean equals(type[]a , type[] b) //如果两个数组长度相同， 并且在对应的位置上数据元素也均相同static boolean equals(Object a, Object b) //如果a和b都为null，返回true;如果只有其中之一为 null，则返回false;否则返回a.equals(b)。 3. hashCode方法由于 hashCode方法定义在 Object 类中， 因此每个对象都有一个默认的散列码，其值为对象的存储地址。 12345678910111213141516171819//String的散列码是由内容导出的int hash = 0;for (int i = 0; i &lt; length0；i++) hash = 31 * hash + charAt(i);//StringBuilder 类中没有定义hashCode 方法//在重写hashcode方法时可以调用 Objects.hash并提供多个参数，这个方法会对各个参数调用 Objects.hashCode，并组合这些散列值。public int hashCode()&#123; return Objects,hash(name, salary, hireDay); &#125;static int hash(Object . .. objects) //返回一个散列码，由提供的所有对象的散列码组合而得到。static int hashCode(Object a ) //如果 a 为 null 返回 0， 否则返回 a.hashCode()static int hashCode((int11ong|short|byte|double|f1oat|char|boolean) value) //返回给定值的散列码。static int hashCode(type[] a ) //计算数组 a 的散列码。这个散列码由数组元素的散列码组合得到。 java规定如果重新定义 equals方法，就必须重新定义 hashCode 方法。因为Hashcode是用于散列数据的快速存取的，如利用 HashSet/HashMap/HashTable类来存储数据时，都是根据存储对象的hashcode值来判断是否相同。如果我们对一个对象重写了 equals方法，意思是只要对象的成员变量的值相等那么equals就返回true，但不重写hashcode方法，那么我们再new一个新的对象的时候，当原对象.equals(新对象)等于true的时候，两者的hashcode值是不相等的。由此产生了理解上的不一致，比如在存储散列集合（如Set类）的时候，将会存储了两个一样的对象，导致混淆，因此，也就必须重写hashcode方法,且Equals与hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( )就必须与 y.hashCode( ) 具有相同的值。 4. toString方法Object 类定义了 toString 方法， 用来打印输出对象所属的类名和散列码即类名@散列码。toString方法是一种非常有用的调试工具。在标准类库中，许多类都定义了 toString方 法， 以便用户能够获得一些有关对象状态的必要信息。因此java建议为自定义的每一个类增加 toString 方法。 12345678910111213141516171819202122232425262728293031323334System.out.println(System.out); //因为 PrintStream 类的设计者没有覆盖 toString方法故得到java.io.PrintStream@2f6684的结果。public String toString()&#123; return getClass().getName() //getClaSS( ).getName( ) 获得类名的字符串 + \"[name=\" + name + \",salary=\" + salary + \",hireDay=\" + hireDay + \"]\"; &#125;public class Manager extends Employee&#123; public String toString() &#123; return super.toString() + \"[bonus=\" + bonus + \"]\"; &#125; &#125;Point p = new Point(10, 20); String message = \"The current position is \" + p; //此处编译器会自动的调用p.toString()方法，以便获得这个对象的字符串描述。\"\"+x; //可替代x.toString()的调用，与 toString 不同的是，如果 x 是基本类型，这条语句照样能够执行。int[] luckyNumbers = &#123; 2, 3, 5, 7, 11, 13 &#125; ; String s = \"\" + luckyNumbers; //[I@la46e30（前缀 [I 表明是一个整型数组）。String s = Arrays.toString(luckyNumbers); //[2,3,5,7,11,13]Arrays.deepToString; //打印多维数组Class getSuperclass( ); //以 Class 对象的形式返回这个类的超类信息。 三、泛型数组列表ArrayList ArrayList 是一个采用类型参数的泛型类,它在添加或删除元素时， 具有自动调节数组容量的功能。&lt;&gt;中的类型不能是基本数据类型。 元素在集合中有序，指的是元素插入过程中记录了元素的插入顺序。1. 创建ArrayList12345678910111213141516ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;(); //构造一个空数组列表ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); //可以结合new操作符使用“菱形”语法,编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，编译器会检査这个变量、 参数或 //方法的泛型类型，然后将这个类型放在&lt;&gt;中。//在 Java SE 5.0 以后的版本中， 没有后缀 &lt;...&gt; 仍然可以使用ArrayList, 它将被认为是一个删去了类型参數的“ 原始” 类型。//添加对象staff.add(new Employee(\"Harry Hacker\", ...)); //在数组列表的尾端添加一个元素，如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。staff.ensureCapacity(l00); //可以指定数组大小，则在100次调用add之间不用重新分配空间。ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(l00); //可以把初始容量传递给 ArrayList 构造器。表明它拥有保存100个元素的潜力，重新分配空间的话会超过100staff.size(); //返回数组列表中包含的实际元素数目void trimToSize( ) //将数组列表的存储容量削减到当前尺寸。垃圾回收器将回收多余的存储空间。应该在确认不会添加任何元素时，再调用该方法否则添加元素时需要花时间再次移动存储块。 2. 访问数组列表元素1234567891011121314151617181920staff.set(i, harry); //设置第i个元素，只有i小于或等于数组列表中当前实际元素个数时才可以调用。Employee e = staff.get(i); //获得数组列表的元素//灵活扩展数组ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();while (. . .) &#123; x = . .; list.add(x); &#125;//方便访问数组X[] a = new X[list.size()];list.toArray(a); staff.add(i,e); //在数组列表的中间插入元素Employee e = staff.remove(i); //从数组列表中间删除一个元素。for (Employee e : staff) //可以使用“ foreach” 循环遍历数组列表： 3. 类型化与原始数组列表的兼容性12345678910public class EmployeeDB&#123; public void update(ArrayList list) &#123; . . . &#125; public ArrayList find(String query) &#123; . . . &#125; &#125;ArrayList&lt;Employee〉staff = . . .; //可以将一个类型化的数组列表传递给 update 方法,无需任何类型转换，但是这样不安全employeeDB.update(staff); //也可以将 staff 对象传递给 update 方法。@SuppressWarnings(\"unchecked\") ArrayList&lt;Employee&gt; result = employeeDB.find(query); //将一个原始 ArrayList 赋给一个类型化 ArrayList 会得到一个警告。一旦能确保不会造成严重的后果，可以用@SuppressWamings(\"unchecked\") 标注来标记这个变量能够接受类型转换。 四、对象包装器与自动装箱 包装器：所有的基本类型都有一个与之对应的类，称为包装器。Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean (前 6 个类派生于公共的超类 Number)。对象包装器是不可变的，不可改变其值，还是final的，不可定义其子类。 自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到固定的对象中。此时若用==比较两个值相同的包装器对象则一定为true。 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。 1234567891011121314151617181920212223242526272829303132333435ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //效率远低于int[],仅在构造小型集合时使用它。list.add(3); //自动装箱；会自动变换为list.add(Integer.valueOf(3));int n = list.get(i); //自动拆箱；会自动翻译成 int n = list.get(i).intValue();//算术表达式中也能自动装箱和拆箱Integer n = 3;n++; //编译器会自动地插入一条对象拆箱的指令， 然后进行自增计算， 最后再将结果装箱。Integer a = 1000;Integer b = 1000;if (a == b) //一般为false，而java中若将经常出现的值包装到同一个对象中，这种比较就有可能成立。为了避免这种不确定性，一般在两个包装器对象比较时调用 equals 方法。Integer n = null; //可以引用nullSystem.out.println(2 * n); //会抛出一个 NullPointerException 异常Integer n = 1;Double x = 2.0;System.out.println(true ? n : x); //输出1.0；如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱，提升为 double, 再装箱为 Double。int x = Integer.parseInt(s); //将字符串转换成整型。public static void triple(IntHolder x) //org.omg.CORBA 包中定义的持有者类型， 包括 IntHolder、BooleanHolder 等，都包含一个公有域值，可以改变x的值。&#123; x.value = 3 * x.value; &#125;static String toString(int i ) //以一个新 String 对象的形式返回给定数值 i 的十进制表示。 static String toString(int i ,int radix ) //返回数值 i 的基于给定 radix 参数进制的表示。static int parseInt(String s,int radix)Static Integer valueOf(String s, int radix)Number parse(String s) //返回数字值，假设给定的 String 表示了一个数值。 五、参数数量可变的方法也称为变参方法。 123456789101112131415161718192021//printf方法的定义public class PrintStream&#123; public PrintStream printf(String fmt , Object... args) //... 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除 fmt参数之外）。Object…参数类型与 Object[]完全一样。 &#123; //如果调用者提供的是整型数组或者其他基本类型的值，自动装箱功能将把它们转换成对象。 return format(fmt, args); //现在将扫描 fmt 字符串， 并将第 i 个格式说明符与 args[i] 的值匹配起来。 &#125; &#125;System.out.printf(\"%d %s\", new Object[] &#123; new Integer(n), \"widgets\" &#125; ); //编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上，并在必要的时候进行自动装箱.//自定义变参方法:计算若干个数值的最大值。public static double max (double... values) &#123; double largest = Double.NECATIVEJNFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest; &#125;double m = max(3.1, 40.4, -5);public static void main(String... args) 允许将一个数组传递给可变参数方法的最后一个参数,因此，可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。 六、枚举类所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。 1234567891011121314151617181920public enum Size &#123; SMALL , MEDIUM, LARGE, EXTRAJARGE &#125;; //实际上定义了一个类刚好有4个实例，由于Enum中equlas方法直接用==实现，故在比较两个枚举变量值时直接使用==即可//可以在枚举类型中添加一些构造器、 方法和域。public enum Size&#123; SMALL(\"S\"), MEDIUM(\"M\"), LARGE(\"L\"), EXTRA_LARGE(\"XL\"); private String abbreviation; private Size(String abbreviation) &#123; this,abbreviation = abbreviation; &#125; public String getAbbreviation() &#123; return abbreviation; &#125; &#125;Size.SMALL.toString(); //返回字符串\"SMALL\"。Size s = Enum.valueOf(Size,class, \"SMALL\"); //将 s 设置成 Size.SMALLSize[] values = Size.values(); //返回一个包含全部枚举值的数组。int ordinal () //返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。int compareTo( E other ) //如果枚举常量出现在 Other 之前， 则返回一个负值；如果 this=other，则返回 0; 否则，返回正值。枚举常量的出现次序在 enum 声明中给出。 七、反射能够分析类能力的程序称为反射，反射库提供了一个非常丰富且精心设计的工具集，使用它的主要人员是工具构造者，而不是应用程序员。反射的功能： 在运行时分析类的能力。 在运行时查看对象，例如，编写一个 toString 方法供所有类使用。 实现通用的数组操作代码。 利用 Method 对象， 这个对象很像C++中的函数指针。 1. Class类Class类中保存着Java 运行时系统始终为所有对象维护的一个被称为运行时的类型标识，虚拟机利用运行时类型信息选择相应的方法执行。通过Class类可以访问这些信息。一个Class对象将表示一个特定类的属性。Class 类实际上是一个泛型类。例如， Employee.class 的类型是 Class&lt;Employee&gt;,但是它将已经抽象的概念更加复杂化了。在大多数实际问题中， 可以忽略类型参数， 而使用原始的 Class 类。 1234567891011121314151617181920212223242526Employee e;Class cl = e.getClass(); //返回一个 Class 类型的实例。System.out.println(e.getClass().getName() + \" \" + e.getName()); //Class的 getName返回类的名字。返回 Employee Harry Hacker或Manager Harry HackerRandom generator = new Random():Class cl = generator.getClass();String name = cl.getName(); // \"java.util .Random\"。如果类在一个包里，包的名字也作为类名的一部分String className = \"java.util.Random\";Class cl = Class.forName(className); //获得类名对应的 Class 对象。 //这个方法只有在 dassName 是类名或接口名时才能够执行。否则将抛出一个 checked exception(已检查异常），在使用时必须提供一个异常处理器。Class dl = Random.class; // if you import java.utilClass cl 2 = int.class; //一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。Class cl 3 = Double[].class; //通过T.class获得Class对象。Double[ ] class.getName( ) //返回 [Ijava.lang.Double;int[ ].class.getName( ) //返回 [I if (e.getClass() == Employee.class) //可以使用==比较两个Class对象e.getClass().newInstance(); //来动态地创建一个与类e具有相同类型的实例String s = \"java.util.Random\";Object m = Class.forName(s).newInstance(); 2. 捕获异常若程序中没有提供捕获异常的处理器对异常情况进行处理，程序在运行时发生异常就会终止执行，并在控制台上打印一条信息给出异常类型。已检查异常：编译器将会检查是否为调用了抛出已检查异常方法的相关代码提供了异常处理器，否则将不能通过编译。未检查异常：编译器不要求强制处置的异常，虽然你有可能出现错误，但是我不会在编译的时候检查，需要自己精心编写代码来避免。例如访问 null 引用等。 123456789try&#123; String name = . . .; Class cl = Class.forName(name); //如果类名不存在， 则将跳过 try 块中的剩余代码，程序直接进人 catch 子句，否则跳过catch子句的处理器代码。&#125;catch (Exception e) &#123; e.printStackTrace(); //利用Throwable 类（Exception类的超类）的 printStackTrace 方法打印出栈的轨迹。&#125; 3. 利用反射分析类的能力在 java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、方法和构造器。 123456789101112131415161718import java.lang.Class;Field getField(String name ) //返回指定名称的公有域Field[] getDeclaredFields() //返回类中声明的给定名称的域， 或者包含声明的全部域的数组。//如果类中没有域， 或者 Class 对象描述的是基本类型或数组类型， 这些方法将返回一个长度为 0 的数组。Field[] getFields() //getFields 方法将返回一个包含 Field 对象的数组， 这些对象记录了这个类或其超类的公有域。Filed[] getDeclaredFie1ds() //getDeclaredField 方法也将返回包含 Field 对象的数组， 这些对象记录了这个类的全部域。//返回包含 Method 对象的数组//getMethods 将返回所有的公有方法， 包括从超类继承来的公有方法；//getDeclaredMethods 返回这个类或接口的全部方法， 但不包括由超类继承了的方法。Method[] getMethods()Method[] getDeclareMethods()//返回包含 Constructor 对象的数组Constructor[] getConstructors() //返回公有构造器Constructor[] getDeclaredConstructors() //返回所有构造器 12345678910111213141516171819202122232425import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Constructor;Class getDeclaringClass( ) //返冋一个用于描述类中定义的构造器、 方法或域的 Class 对象。Class[] getExceptionTypes ( ) //( 在 Constructor 和 Method 类中）返回一个用于描述方法抛出的异常类型的 Class 对象数组。int getModifiers( ) //返回一个用于描述构造器、 方法或域的修饰符的整型数值。使用 Modifier 类中的这个方法可以分析这个返回值。用不同的位开关描述 public 和 static 这样的修饰符使用状况String getName( ) //返冋一个用于描述构造器、 方法或域名的字符串。Class[] getParameterTypes ( ) //( 在 Constructor 和 Method 类 中）返回一个用于描述参数类型的 Class 对象数组。 Class getReturnType( ) //( 在 Method 类中）返回一个用于描述返H类型的 Class 对象。static String toString(int modifiers ) //返回对应 modifiers 中设置的修饰符的字符串表示。//这些方法将检测方法名中对应的修饰符在 modifiers 值中的位，即方法和构造器是否是public、 private 或 final。static boolean isAbstract(int modifiers )static boolean isFinal (int modifiers )static boolean islnterface(int modifiers )static boolean isNative(int modifiers )static boolean isPrivate(int modifiers )static boolean isProtected(int modifiers )static boolean isPublic(int modifiers )static boolean isStatic(int modifiers )static boolean isStrict(int modifiers )static boolean isSynchronized(int modifiers )static boolean isVolati1e(int modifiers ) 4. 在运行时使用反射分析对象 在编写程序时， 如果知道想要査看的域名和类型，查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域,从而进一步查看运行时数据域的实际内容。 反射机制的默认行为受限于 Java 的访问控制。除非拥有访问权限，否则Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。可利用需要调用 Field、 Method 或Constructor 对象的 setAccessible 方法来覆盖访问控制。 当调用get方法获得域值时参数为基本数据类型，则反射机制将会自动地将这个域值打包到相应的对象包装器中。也可以调用Field 类中的 getDouble 等方法。12345678910111213141516Employee harry = new Employee(\"Harry Hacker\", 35000, 10, 1, 1989);Class cl = harry.getClass; Field f = cl .getDeclaredField(\"name\"); f.setAtcessible(true); //覆盖访问控制Object v = f.get(harry); //获得name域运行时的具体值为\"Harry Hacker\"f.set(obj,value); //将 obj 对象的 f 域设置成新值public String toString() &#123; return new ObjectAnalyzer().toString(this); //利用ObjectAnalyzer类的toString方法可为每个自定义类重写一个通用的toString方法，很方便。将打印类的所有信息，包括运行时的具体域值。&#125;boolean isAccessible( ) //返回反射对象的可访问标志的值。static void setAccessible(AccessibleObject[] array,boolean flag) //是一种设置对象数组可访问标志的快捷方法。 5. 使用反射编写泛型数组代码将一个 Employee[]临时地转换成 Object[] 数组， 然后再把它转换回来是可以的，但一从开始就是 Object[] 的数组却永远不能转换成 Employee[] 数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。 1234567891011121314151617181920212223//注意，这个 CopyOf 方法可以用来扩展任意类型的数组， 而不仅是对象数组。//应该将 goodCopyOf 的参数声明为 Object 类型，而不要声明为对象型数组（Object[])。整型数组类型 int[] 可以被转换成 Object，但不能转换成对象数组。public static Object goodCopyOf(Object a, int newLength) &#123; Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength): System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; &#125;static Object get(Object array,int index) //( xxx 是 boolean、byte、 char、 double、 float、 int、 long、 short 之中的一种基本类型。)static xxx getXxx(Object array,int index) //这些方法将返回存储在给定位置上的给定数组的内容。static void set(Object array,int index,Object newValue) //( xxx 是 boolean、 byte、char、double、float、 int、 long、 short 之中的一种基本类型。)static setXxx(Object array,int index,xxx newValue) //这些方法将一个新值存储到给定位置上的给定数组中。static int getLength(Object array) //返回数组的长度。static Object newInstance(Class componentType,int length)static Object newInstance(Class componentType,int[] lengths) //返回一个具有给定类型、给定维数的新数组。 6. 利用反射调用任意方法利用反射中的Method类的invoke方法可以回调任意对象的任意方法。 1234567891011Object invoke(Object obj, Object... args) //第一个参数是隐式参数， 其余的对象提供了显式参数，对于静态方法，第一个参数可以被忽略， 即可以将它设置为 null。 //如果返回类型是基本类型， invoke 方法会返回其包装器类型。必须相应地完成类型转换。Method getMethod(String name, Class... parameterTypes) //利用Class类中的getMethod方法获得Method对象 //也可以通过调用 getDeclareMethods 方法， 然后对返回的 Method 对象数组进行查找， 直到发现想要的方法为止。Method ml = Employee.class.getMethod(\"getName\");Method m2 = Employee.class.getMethod(\"raiseSalary\", double.class);String n = (String) ml.invoke(harry); double s = (Double) m2.invoke(harry);f.invoke(null, x); //有可能存在若干个相同名字的方法，鉴于此，还必须提供想要的方法的参数类型。 反射的优缺点： 反射对于编写系统程序来说极其实用，但是通常不适于编写应用程序。 如果在调用方法的时候提供了一个错误的参数，那么 invoke 方法将会抛出一个异常； 且使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。 反射是很脆弱的，即编译器很难帮助人们发现程序中的错误， 因此只有在运行时才发现错误并导致异常。 因此建议仅在必要的时候才使用 Method 对象，而最好使用接口以及 Java SE8 中 的 lambda 表达式，它们的代码的执行速度更快，更易于维护。 八、继承的设计技巧 将公共操作和域放在超类； 不要使用受保护的域； 使用继承实现严格“ is-a” 关系，即超类中不能存在子类不需要的域； 除非所有继承的方法都有意义，否则不要使用继承； 在覆盖方法时，不要改变预期的行为； 使用多态(具有动态邦迪机制)，而非类型信息； 不要过多地使用反射。","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Java中的对象与类","date":"2020-04-29T01:45:33.000Z","path":"2020/04/29/Java基础知识/Java中的对象与类/","text":"Java 是完全面向对象(OOP)的，而面向对象更加适用于解决规模较大的问题。 一、类和对象1. 类类：类是构造对象的模板或蓝图，由类构造对象的过程称为创建类的实例。封装: 从形式上看，封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。实例域：对象中的数据。方法：操纵数据的过程。状态：对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。并不是所有的类都具有面向对象特征，例如Math类只封装了功能，它不需要也不必隐藏数据。 2. 对象三个主要特征： 对象的行为（behavior)—可以对对象施加哪些操作，或可以对对象施加哪些方法。 对象的状态（state )—对象状态的改变必须通过调用方法实现，否则会破坏封装性。 对象标识（identity )—每个对象都有一个唯一的身份。 对象与对象变量的区别： 12345678Date deadline; //变量deadline不是一个对象， 实际上也没有引用对象,因此还不能将任何 Date 方法应用于这个变量上。deadline = new Date(); //一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 //表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 deadline 中。Date birthday = new Date();deadline = birthday; deadline = null; //显式地将对象变量设置为 null,表明这个对象变量目前没有引用任何对象。该对象不能使用任何方法。 //局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。 3. 类之间的关系 依赖（“uses-a”）:一个类的方法操纵另一个类的对象，即一个类依赖于另一个类。又称为耦合度，实际开发中应让这种耦合最小。 聚合（“has-a”） :类 A 的对象包含类 B 的对象。 继承（“is-a”）:用于表示特殊与一般关系。如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。 表示关系的UML符号： 二、使用预定义类1. Java类库中的LocalDate类12345678910111213Local Date.now(); //使用类中的静态工厂方法LocalDate.of(1999, 12, 31); //提供年、 月和日来构造对应一个特定日期的对象：LocalDate newYearsEve = Local Date.of(1999, 12, 31); //将构造的对象保存在一个对象变量中供再次使用。LocalDate aThousandDaysLater = newYearsEve.plusDays(1000); //得到距当前对象指定天数的一个新日期对象。LocalDate minusDays(int n) //生成当前日期之后或之前 n 天的日期。int getYear( ) int getMonthValue( ) int getDayOfMonth( ) //得到当前日期的年、 月和日。DayOfWeek getDayOfWeek; //得到当前日期是星期几， 作为 DayOfWeek 类的一个实例返回。 调用 getValue 来得到1 ~ 7 之间的一个数， 表示这是星期几， 1 表示星期一， 7 表示星期日。 2. CregorianCalendar类12345CregorianCalendar someDay = new CregorianCalendar(1999, 11, 31);someDay.add(Calendar.DAY_0F_M0NTH, 1000); //更改器方法year = someDay.get(Calendar.YEAR); //访问器方法month = someDay.get(Calendar.MONTH)+ 1; day = someDay.get(Ca1endar.DAY_0F_M0NTH); 三、用户自定义类123456789101112131415161718192021222324252627282930313233343536373839404142class Employee&#123; //私有数据域 private String name; private double salary; private Local Date hireDay;//构造器与类同名//构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的，否则会产生编译错误。//每个类可以有一个以上的构造器//构造器可以有 0 个、1 个或多个参数，没有返回值 public Employee (String n , double s, int year, int month , int day) &#123; name = n; salary = s; hireDay = Local Date,of(year, month, day); //注意， 不要在构造器中定义与实例域重名的局部变量。否则实例域会被覆盖从而使构造器失效。 &#125;//域访问器public String getName()&#123; return name;&#125;public double getSalary()&#123; return salary;&#125;public Local Date getHireDay() //注意不要编写返回引用可变对象的访问器方法。否则会破坏封装性，由第三方改变类中的私有状态。该方法就违反了这个设计原则&#123; //如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone )。 //return hireDay; return (Date)hireDay.clone();&#125;//域更改器public void raiseSalary(double byPercent) //raiseSalary 方法有两个参数。 第一个参数称为隐式参数， 是出现在方法名前的Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。 &#123; double raise = this.salary * byPercent / 100; //关键字 this 表示隐式参数 salary += raise; &#125;&#125; 1. 多个源文件的使用在开发中习惯于将每一个类存在一个单独的源文件中，这时既可以显式编译也可以隐式编译。当 Java 编译器发现 EmployeeTest.java 使用 Employee 类时会查找名为 Employee.class 的文件。如果没有找到这个文件， 就会自动地搜索 Employee.java, 然后，对它进行编译。如果 Employee,java 版本较已有的 Employee.class 文件版本新，Java 编译器就会自动地重新编译这个文件。 2. 封装封装一个类一般提供下面三项内容： 私有的数据域； 公有的域访问器方法； 一个公有的域更改器方法。 3. 基于类的访问权限类中的方法可以访问所属类对象的私有特性, 而不仅限于访问隐式参数的私有特性。 1234567class Employee&#123; ... public boolean equals(Employee other) &#123; return name.equals(other.name); &#125; &#125; 4. 私有方法绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。有些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密， 或者需要一个特别的协议以及一个特别的调用次序。在 Java 中，为了实现一个私有的方法， 只需将关键字 public 改为 private 即可。只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方法是公有的， 就不能将其删去，因为其他的代码很可能依赖它。 5. final 实例域12345678910class Employee&#123; //final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类）。 private final String name; //必须确保在每一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。 //对于可变的类， 使用 final 修饰符可能会对读者造成混乱 //final 关键字只是表示存储在 evaluations 变量中的对象引用不会再指示其他 StringBuilder对象。不过这个对象可以更改。 private final StringBuiIcier evaluations; &#125; 四、静态域与静态方法1. 静态域12345class Employee&#123; private static int nextld = 1; //如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。 private int id; &#125; 2. 静态常量静态变量使用得比较少，但静态常量却使用得比较多。静态常量可以被设置为public，因为final常量不允许被修改。 123456789public class Math&#123; public static final double PI = 3.14159265358979323846; &#125;public class System&#123; public static final PrintStream out = . . .; &#125; 3. 静态方法使用静态方法的两种情况： 一 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow)。 一个方法只需要访问类的静态域。 12345678910//静态方法不能访问实例域， 因为它不能操作对象。但是，静态方法可以访问自身类中的静态域//可以认为静态方法是没有 this 参数的方法。//可以使用对象调用静态方法但没必要。因为静态方法与对象实例域毫无关系。public static int getNextId()&#123; return nextId; // returns static field &#125;//使用类名调用该方法int n = Employee.getNextld(); 如果一个域是静态的基本数据类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化的值就是null。static关键字不能应用于局部变量，因此它只能作用于域。 4. 工厂方法工厂方法是静态方法的另一种常见用途，类似 LocalDate 和 NumberFormat 的类使用静态工厂方法来构造对象。 12345NumberFormat currencyFormatter = NumberFormat.getCurrencylnstance();NumberFormat percentFormatter = NumberFormat.getPercentlnstance()；double x = 0.1;System.out.println(currencyFormatter.format(x)); // prints $O.10System.out.println(percentFomatter.format(x)); // prints 10% 使用工厂方法的两个原因： 无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例和百分比实例采用不用的名字。 当使用构造器时，无法改变所构造的对象类型。而 Factory 方法将返回一个 DecimalFormat类对象，这是 NumberFormat 的子类。 5. main方法 main方法也是一种静态方法，不能操作所在类的实例域。静态的main 方法将执行并创建程序所需要的对象。 每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。可独立的对类进行测试。 五、方法参数 按值调用：表示方法接收的是调用者提供的值，即形参为实参的一个拷贝，对形参的修改不能改变实参的值。 按引用调用：表示方法接收的是调用者提供的变量地址。 Java 总是采用按值调用，方法不能修改传递给它的任何参数变量的内容。 1234567891011121314151617181920public static void tripieValue(double x) // doesn't work&#123; x = 3 * x; &#125;double percent = 10; tripieValue(percent); //一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。public static void tripleSalary (Employee x) // works&#123; x.raiseSa1ary(200); &#125;harry = new Employee(. . .);tripleSalary(harry); //一个方法可以改变一个对象参数的状态。public static void swap(Employee x , Employee y) // doesn't work&#123; Employee temp = x; x = y; y = temp; //一个方法不能让对象参数引用一个新的对象。&#125; 六、对象构造1. 重载 方法签名：要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名。返回类型不是方法签名的一部分。 重载：多个方法有相同的名字、 不同的参数，便产生了重载。不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。 重载解析:通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误。 2. 默认域初始化 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。 域与局部变量不同，必须明确地初始化方法中的局部变量。 3. 无参数的构造器 如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。 如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。此时必须显式提供一个不带参数的构造器才可以将所有的实例域设置为默认值。 4. 显式域初始化12345678910111213141516171819202122232425262728293031323334353637383940class Employee&#123; //初始值为常量值，用在当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时。 //在执行构造器之前，先执行赋值操作。 private String name =\"\"; //初始值不一定是常量值 private static int nextId; //静态域在类加载时即被加载且未被赋初值的会被赋予默认值。 private int id = assignId(); private static int assignId() &#123; int r = nextId; nextId++; return r; &#125; //使用初始化块 //在一个类的声明中，可以包含多个代码块 //首先运行初始化块，然后才运行构造器的主体部分。 //不常见 &#123; id = nextld; nextld++; &#125; //在类第一次加载的时候， 将会进行静态域的初始化 //所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。 static &#123; Random generator = new Random(); nextld = generator.nextInt(lOOOO); &#125; //从 Java SE 7 以后，java 程序首先会检查是否有一个 main 方法。 static &#123; System.out.println(\"Hel1o, World\"); &#125;&#125; 域初始化的顺序很复杂，调用构造器的具体处理步骤： 初始化父类中的静态成员变量和静态代码块 ； 初始化子类中的静态成员变量和静态代码块 ； 初始化父类的普通成员变量和代码块，再执行父类的构造方法； 初始化子类的普通成员变量和代码块，再执行子类的构造方法； 5. 参数名123456789public Employee(String aNaie, double aSalary) &#123; name = aName ; salary = aSalary; &#125;public Employee(String naie, double salary) &#123; this.name = name; this,sal ary = salary; &#125; 6. 利用this调用同一个类中的另一个构造器12345//可有效减少代码重复public Employee(double s) &#123; // calls Employee(String, double) this(\"Employee #\" + nextld, s); nextld++; &#125; 七、包使用包的主要原因是确保类名的唯一性，而不会产生冲突。 1. 类的导入一个类可以使用所属包中的所有类， 以及其他包中的公有类。 12345678910111213141516171819java.time.LocalDate today = java.tine.LocalDate.now(); //繁琐//import 语句应该位于源文件的顶部(但位于 package 语句的后面)。//只能使用星号（*) 导入一个包， 而不能使用 import java.* 或import java.*.* 导入以 java 为前缀的所有包。import java.util.*;LocalDate today = Local Date.now();//此时若在程序直接使用 Date 类的时候， 就会出现一个编译错误，因为二者均包含Date类import java.util.*;import java.sql.*;//可明确指出使用哪个包中的Dateimport java.util.*;import java.sql.*;import java.util.Date;//若两个Date均需要使用应添加上完整包名java.util.Date deadline = new java.util.Date();java.sql.Date today = new java.sql.Date(...); 2. 静态导入123import static java.lang.System.*;out.println(\"Goodbye, World!\"); // System.outexit(0); //System.exit 3. 将类放入包中如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包(没有名字)中。 123456789package com.horstmann.corejava;public class Employee&#123;&#125;//编译javac PackageTest.javajavac com/horstmann/corejava/Employee.java 编译器在编译源文件的时候不检查目录结构。如果源文件不在指定package中且不依赖于其他包， 就不会出现编译错误。但是， 最终的程序将无法运行，因为虚拟机找不到类。 4. 包作用域 标记为 public 的部分可以被任意的类使用； 标记为 private 的部分只能被定义它们的类使用。 如果没有指定 public 或 private , 这个部分（类、方法或变量）可以被同一个包中的所有方法访问。 八、类路径类路径是所有包含类文件的路径的集合。类路径包含三种情况： 基目录 /home/user/classdir 或 c:\\classes 当前目录 (.); JAR 文件 /home/user/archives/archive.jar 或c:\\archives\\archive.jar 类路径所列出的目录和归档文件是搜寻类的起始点。 1. 虚拟机搜寻类文件的过程 首先要查看存储在 jre/lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。 若找不到相应类文件，再查看类路径。 /home/user/classdir/com/horstmann/corejava/Employee.classcom/horstmann/corejava/Employee.class 从当前目录开始com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar 2. 编译器搜寻类文件的过程 如果引用了一个类，而没有指出这个类所在的包， 那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。 如果找到了一个以上的类， 就会产生编译错误。 编译器还要查看源文件是否比类文件新，如果是这样的话，那么源文件就会被自动地重新编译。 3. 设置类路径1234567//采用 -classpath (或 -cp) 选项指定类路径java -classpath /home/user/dassdir: .:/home/user/archives/archive.jar HyProgjava -classpath c:\\classdir; .;c:\\archives\\archive.jar MyProg//设置 CLASSPATH 环境变量export CLASSPATH=/home/user/classdir:.:/ home/user/archives/archive.jar //Bourne Again shell ( bash)set CLASSPATH=c:\\classdir;.;c:\\archives\\archive.jar //Windows shell 九、文档注释利用JDK中的javadoc命令工具，可以由源文件生成一个 HTML 注释(/** */)文档。文档注释与源代码在同一个文件中，在修改源代码的同时， 重新运行 javadoc 就可以轻而易举地保持两者的一致性。 1. 注释的插入javadoc抽取信息生成文档的位置如下，也应当在这些位置编写注释： 包 公有类与接口 公有的和受保护的构造器及方法 公有的和受保护的域 文档注释的格式： 12345/*** 自由格式文本：标记如@author或 @param等* 第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽取出来形成概要页。* 在自由格式文本中，可以使用 HTML 修饰符，如&lt;em&gt;&lt;/em&gt;等*/ 2. 类注释类注释必须放在 import 语句之后，类定义之前。 3. 方法注释每一个方法注释必须放在所描述的方法之前。可以使用以下标记：@param:对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。@return:这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。©throws:这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。 4. 域注释只需要对公有域（通常指的是静态常量）建立文档。 5. 通用注释用于类文档的注释中。 12345678910/**@author 姓名@version 文本@since 文本@deprecated 文本@see 引用 @see com.horstraann.corejava.Employee#raiseSalary(double) @see &lt;a href=\"m«w.horstmann . com/corejava. htinl \"&gt;The Core ]ava home page&lt;/a&gt; Isee \"Core Java 2 volume 2n&#123;@link package.class#feature label &#125;*/ 6. 包与概述注释要想产生包注释，就需要在每一个包目录中添加一个单独的文件。有两种方式添加： 提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;—&lt;/body&gt; 之间的所有文本都会被抽取出来。 提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** 和 */ 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。 还可以为所有的源文件提供一个概述性的注释。名为overview,html 的文件中，这个文件位于包含所有源文件的父目录中。标记&lt;body&gt;—&lt;/body&gt;间的所有文本将被抽取出来。 7. 注释的抽取详见http://docs.oracle.com/javase/8/docs/guides/javadoc 123456789101112//docDirectory为HTML文件的存放目录1. 切换到包含想要生成文档的源文件目录。2. javadoc -d docDirectory nameOfPackage //如果省略了 -d docDirectory 选项， 那 HTML 文件就会被提取到当前目录下。3. javadoc -d docDirectory nameOfPackage1 nameOfPackage2 . . .4. javadoc -d docDirectory *.java //文件在默认包中//可以使用 -author 和 -version 选项在文档中包含@author 和@version 标记（默认情况下，这些标记会被省略)。//使用-link为标准类添加超链接javadoc -link http://docs.oracle.eom/:javase/8/docs/api *.java //所有的标准类库类都会自动地链接到 Oracle 网站的文档。//使用 -linksource 选项，则每个源文件被转换为 HTML (不对代码着色，但包含行编号) 并且每个类和方法名将转变为指向源代码的超链接。 十、类设计技巧 一定要保证数据私有 一定要对数据初始化 不要在类中使用过多的基本类型 不是所有的域都需要独立的域访问器和域更改器 将职责过多的类进行分解 类名和方法名要能够体现它们的职责 优先使用不可变的类","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Java基本语法","date":"2020-04-28T04:05:33.000Z","path":"2020/04/28/Java基础知识/Java基本语法/","text":"一、Java应用程序的结构1. 程序的组成123456public class FirstSample&#123; public static void main(String[] args) &#123; //要运行java程序，必须有一个main方法，public和static的位置可以互换，但其它部分位置固定 System.out.println(\"We will not use 'Hello, World!\"'); &#125; &#125; java区分大小写； public关键字为访问修饰符，用于控制程序的其他部分对这段代码的访问级別； 关键字 class 表明 Java 程序中的全部内容都包含在类中； class 后面紧跟类名，名字必须以字母开头，后面可以跟字母和数字的任意组合，采用驼峰命名法，不能使用java保留字； 源代码的文件名必须与public类的名字相同，并用 .java 作为扩展名。源文件可以包含多个类定义，但最多只能包含一个public类定义。可以没有public类定义，此时文件名可随意。 成功编译后会得到一个包含这个类字节码的文件。Java 编译器将字节码文件自动地命名为 ClassName. class, 并与源文件存储在同一个目录下。 运行已编译的程序时，Java 虚拟机将从指定类中的 main 方法开始执行,故在类的源文件中必须包含一个 main方法。 在 Java SE 1.4 及以后的版本中强制 main方法是 public 的。 Java 中的 main 方法必须是静态static的。 在 Java 中，每个句子必须用分号结束。特别需要说明，回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。 2. 注释123456789//单行注释/*比较长的一段话，注意不能嵌套*//***多行注释，可自动生成文档。***/ 二、8种基本数据类型4种整型，2种浮点型，1种用于表示 Unicode 编码的字符单元的字符类型 char和 1 种用于表示真值的 boolean 类型。 1. 整型 int：109以内； long：1010——1018，数值有一个后缀L或l； 二进制从Java7开始，要加上前缀0b或0B；八进制加前缀0(容易混淆数值，不推荐)；十六进制加前缀0x或0X； 从Java7开始还可以为数字字面量加下划线让程序更易读，Java编译器会去除这些下划线。如1_000_000或0b1111_0100_0010_0200_0000。 Java中所有的数值类型所占据的字节数量与平台无关，而C和C++会随着平台改变而改变。 注意!Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。 2. 浮点型2.1 两种浮点类型 float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。 也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。 绝大部分应用程序都采用 double 类型。在很多情况下，float 类型的精度很难满足需求。 可以使用十六进制表示浮点数值。例如，0.125=2—3可以表示成 0xl.0p-3。在十六进制表示法中， 使用 p 表示指数， 而不是 e。 注意， 尾数采用十六进制，指数采用十进制。指数的基数是 2。 2.2 浮点型的计算 所有的浮点数值计算都遵循 IEEE 754 规范。 三个特殊浮点值表示溢出和出错情况： 正无穷大(常量 Double.POSITIVE_INFINITY或Flocat.POSITIVE_INFINITY) 负无穷大(Double.NEGATIVE_INFINITY或Float.NEGATIVE_INFINITY) NaN(非数值，Double.NaN或Float.NaN):注意！所有非数值都认为是不相同的。 12if (x = Double.NaN) // is never true 错误判断方法if (Double.isNaN(x)) // check whether x is \"not a number\" 正确判断方法 浮点数值采用二进制系统表示，故无法精确表示1/10，如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal类 3. Unicode编码与字符编码表设计 Unicode 编码的目的是将世界不同地区的不同编码标准如美国的 ASCII、 西欧语言中的ISO 8859-1 俄罗斯的 KOI-8、 中国的 GB 18030 和 BIG-5 等统一起来，起初Unicode是固定的16位，而经过一段时间的发展，Unicode 字符超过了 65 536 个，其主要原因是增加了大量的汉语、 日语和韩语中的表意文字。为了解决这个问题，设计了不同的变长编码方式，如UTF-8和UTF-16，要理解这两种编码方式，必须首先理解Unicode码点等含义。码点：是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中，码点采用 U+十六进制 书写,Unicode 的码点可以分成 17 个代码级别，从U+10000 到 U+10FFFF。基本的多语言级别：码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；辅助字符级别：其余的 16个级别的码点从 U+10000 到 U+10FFFF , 其中包括一些辅助字符。 3.1 UTF-16字符编码表UTF-16 编码采用不同长度(2字节和4字节)的编码表示所有 Unicode 码点。在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元; 而辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的 2048 字节内， 通常被称为替代区域，其中 U+D800 ~ U+DBFF 用于第一个代码单元，U+DC00 ~ U+DFFF 用于第二个代码单元，而这些替代区域Unicode规定不对应与任何字符。这样设计十分巧妙，我们可以从中迅速地知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。参见https://zh.wikipedia.org/wiki/UTF-16#从U+0000至U+D7FF以及从U+E000至U+FFFF的码位UTF-16编码算法： 码位减去 0x10000，得到的值的范围为20比特长的 0…0xFFFFF。 高位的10比特的值（值的范围为 0…0x3FF）被加上 0xD800 得到第一个码元或称作高位代理，值的范围是 0xD800…0xDBFF。由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理。 低位的10比特的值（值的范围也是 0…0x3FF）被加上 0xDC00 得到第二个码元或称作低位代理，现在值的范围是 0xDC00…0xDFFF。由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理。 UTF-16编码示例： 3.2 UTF-8字符编码表UTF-8编码也采用不同字节编码所有Unicode码点(1字节-6字节)参见https://zhuanlan.zhihu.com/p/72254734UTF-16编码规则表：UTF-16编码示例：汉字「吕」的 Unicode 编码是 U+5415，对应二进制为 0101010000010101，总共有 15 位。因为两字节最多表示 11 位，三字节最多表示 16 位，所以使用三字节编码。对应二进制拆成（从低位到高位）三部分，分别是 0101, 010000, 010101，再拼上编码前缀得到 11100101, 10010000, 10010101，对应十六进制为 0xe5, 0x90, 0x95，这就是汉字「吕」的 UTF-8 编码。 4. char类型 char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。 char 类型的字面量值要用单引号括起来。 char 类型的值可以用转义序列\\u和十六进制值表示，其范围从 \\u0000 到 \\uffff。 除了转义序列 \\u 之外， 还有一些用于表示特殊字符的转义序列： 所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\\02122’ 或 “Hello\\n”。转义序列 \\u还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以。 Unicode 转义序列会在解析代码之前得到处理。123456public static void main(String\\u005B\\ u00SD args); //\\u005B 和 \\u005D 是 [ 和 ] 的编码。\"\\u0022+\\u0022\"; //\"\"+\"\" 即空串// \\u00A0 is a newline //\\u00A0为换行符，故会产生一个语法错误// Look inside c:\\users //也会产生一个语法错误， 因为 \\u 后面并未跟着 4 个十六进制数。 5. boolean类型boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件。要注意！整型值和布尔值之间不能进行相互转换。 三、变量1. 变量的声明 变量名必须是一个以字母开头并由字母或数字构成的序列。 需要注意，与大多数程序设计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括 ‘A’ ~ ‘Z’、 ‘a’ ~ ‘z’、或在某种语言中表示字母的任何 Unicode 字符。 但 V 和 ‘©’这样的符号不能出现在变量名中，空格也不行。可以使用 Character 类的isJavaldentifierStart 和 isJavaldentifierPart 方法来检查哪些 Unicode 字符属于 Java 中的“ 字母”。 另外， 不能使用 Java 保留字作为变量名。 12345int i,j; //不提倡int a;int b; //提倡，可读性强Box box;Box aBox; 2. 变量的初始化12345int vacationDays; //声明一个变量之后，必须用赋值语句对变量进行显式初始化,否则不能使用vacationDays=12; //可以将变量的声明和初始化放在同一行中。//在 Java 中可以将声明放在代码中的任何地方,但应尽可能地靠近变量第一次使用的地方。int vacationDays = 12; //在 Java 中， 不区分变量的声明与定义。 3. 常量12345final double CM_PER_INCH = 2.54; //关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。//类常量的定义位于 main 方法的外部。public static final double CM_PER_INCH = 2.54; //使用关键字 static final 可设置一个类常量,可使其在一个类中的多个方法中使用 //如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量，ClassName.常量名。 const 是 Java 保留的关键字，但目前并没有使用。 四、运算符+ - * / %加、减、乘、除、取余数 需要注意， 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。 在默认情况下， 虚拟机设计者允许对中间计算结果采用扩展的精度。但是， 对于使用 strictfp 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。 如果将一个类标记为strictfp, 这个类中的所有方法都要使用严格的浮点计算。1public static strictfp void main(String[] args) 1. 数学函数与数学常量123456789101112131415161718192021222324252627282930313233343536import static java.lang.Math.*; //静态导入Math包后，就不需要使用 Math.方法名 来调用了//解决负整数取余数问题的方法,n%2=-1，若n为负整数floorMod(position+adjustment,12); //（对于负除数，floorMod 会得到负数结果，不过这种情况在实际中很少出现。//三角函数方法static double sin(double a ) ： 返回角的三角正弦static double cos(double a) ： 返回角的三角余弦static double tan(double a) ： 返回角的三角正切static double asin(double a) : 返回角的反正弦static double acos(double a) : 返回角的反余弦static double atan(double a) ： 返回角的反正切static double toRadians(double a) : 将角转换为弧度static doueble toDegrees(double a) : 将弧度转化为角//指数函数方法static double exp(double a) : 用于获取e的a次方；static double log(double a) : 即lna;static double log10(double a) : 即log10a;static double sqrt(double a ):用于取a的平方根；static double cbrt(double a) : 用于取a的立方根；static double pow(double a, double b) : 用于求a的b次方；//取整函数方法static double ceil(double a)：返回大于等于a的整数值，返回值类型为double；static double floor(double a) : 返回小于等于a的整数值，返回值类型为double；static double rint(double a) : 返回与a最接近的整数值，返回值类型为double；（如果两个同为整数且同样接近，选取偶数值的那个）static double random( ):返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。//四舍五入函数static long round(double a ): 其值等于Math.floor(a + 0.5)，返回值类型为long;static int round(float a ): 其值等于Math.floor(a + 0.5)，返回值类型为int;//求绝对值运算和最值运算，这里的类型就是double，float，int和long类型static 类型 abs(类型); 返回对应类型的绝对值static 类型 max(类型1,类型2); 返回对应类型的最大值static 类型 min(类型1,类型2); 返回对应类型的最小值 2. 数值类型之间的合法自动转换其中6个实心箭头，表示无信息丢失的转换；有 3 个虚箭头，表示可能有精度损失的转换。当进行二元操作时，会将两个操作数自动转换为同一种类型，再进行计算，转换规则为： 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 否则， 两个操作数都将被转换为 int 类型。 3. 强制类型转换cast当存在信息丢失的可能时，需要进行强制类型转换才可以，比如long—&gt;int,强制类型转换会进行截断。 12(目标类型)变量; //不要在 boolean 类型与任何数值类型之间进行强制类型转换， 这样可以防止发生错误。b?1:0; //极少情况下使用 4. 结合赋值运算符+= -= *= /= %=%:取模运算，结果的符号和被除数符号一致 12int x;x += 3.5; //等价 (int)(x+3.5) 运算符得到一个值， 其类型与左侧操作数的类型不同，就会发生强制类型转换。 5. 自增与自减运算符12345int n=12;n++; //由于这些运算符会改变变量的值，所以它们的操作数不能是数值。n-- //不推荐使用++,容易产生bug。++n;--n; 6. 关系运算符和boolean运算符 关系运算符：== != &lt; &gt; &lt;= &gt;= boolean运算符:&amp;&amp; || ! ?: 7. 位运算符&amp; | ^(异或) ~ &lt;&lt;(左移) &gt;&gt;(右移) 利用 &amp; 并结合使用适当的 2 的幂， 可以把其他位掩掉， 而只保留其中的某一位。 &gt;&gt;&gt; 运算符会用 0 填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。 移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作数模 64 )。 C/C++中&gt;&gt;对于负数生成的结果可能会依赖于具体的实现。Java 则消除了这种不确定性。 123(n &amp; (1 &lt;&lt; 3)) &gt;&gt; 3;1&lt;&lt;35; //等价8或者1&lt;&lt;3 8. 括号与运算符的优先级 9. 枚举类型用于变量的取值只在一个有限的集合内的情况。 12enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;; //定义枚举类型Size s = Size.MEDIUM; //声明变量，只能存储Size中给定的枚举值或null值，null 表示这个变量没有设置任何值。 五、字符串 Java 字符串就是 Unicode 字符序列。Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。每个用双引号括起来的字符串都是 String类的一个实例。String 类对象为不可变字符串，不能修改字符串中的任一字符，但是可以修改整个字符串变量，让它引用另外一个字符串。字符串存放在一个公共存储池(堆)中，字符串变量指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同的字符。即：编译器可以让字符串共享。Java 将自动地进行垃圾回收。 如果修改字符串变量后之前的字符串所占的一块内存不再使用了， 系统最终会将其回收。 1. String中的各种字符串操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849String greeting = \"Hello\";String expletive = \"Expletive\";//子串 substring方法String s = greeting.substring(0, 3); //\"Hel\"//拼接 +String message = expletive + greeting; //当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串（任何一个 Java 对象都可以转换成字符串）。nt age = 13;String rating = \"PC\" + age; //PG13System.out.println(\"The answer is \" + answer);//join方法：把多个字符串放在一起， 用一个定界符分隔String all = String.join(\" / \", \"S\", \"M\", \"L\", \"XL\"); //\"S / H / L / XL\"//修改字符串变量，达到修改字符的效果greeting = greeting.substring(0, 3) + \"p!\"; //共享享带来的高效率远远胜过于提取、 拼接字符串所带来的低效率。因为对字符串进行的操作往往只是比较。//检测字符串是否相等s.equals(t); \"Hello\".equals(greeting);\"Hello\".equalsIgnoreCase(\"hel1o\"); //判断是否相等而不区分大小写if (greeting.compareTo(\"Hel1o\") == 0)//检测字符串是否放置在同一个位置上greeting == \"Hello\"; //可能正确也可能错误，因为实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。int n = greeting.length(); //返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。int cpCount = greeting.codePointCount(0, greeting.length()); //得到实际的长度，即码点数量s.charAt(n); //返回位置 n 的代码单元int index = greeting.offsetByCodePoints(0, i); //得到第 i 个码点int cp = greeting.codePointAt(index); //遍历字符串的码点int[] codePoints = str.codePointsO.toArray();//把一个码点数组转换为一个字符串String str = new String(codePoints, 0, codePoints.length);//返回一个新字符串。 这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。String toLowerCase( )String toUpperCase( )//返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。String trim( )//返回一个新字符串。这个字符串用 newString 代替原始字符串中所有的 oldString。可以用 String 或 StringBuilder 对象作为 CharSequence 参数。String replace( CharSequence oldString,CharSequence newString) Java 中的 String类包含了 50 多个方法。详参https://docs.oracle.com/javase/8/docs/api/ 2. 空串与null串123456String e = \"\"; // 空串,它是长度为0的字符串，有自己的内容(空)String str=null; //这表示目前没有任何对象与该变量关联if (str == null) //检查一个字符串是否为 nullif (str != null &amp;&amp; str.length() != 0) //检查一个字符串既不是 null 也不为空串，注意！首先要检查 str 不为 null。因为如果在一个 mill 值上调用方法， 会出现错误。 3. 使用StringBuilder类构建字符串1234StringBuilder builder = new StringBuilder();builder.append(ch); // appends a single characterbui1der.append(str); // appends a stringString completedString = builder.toString(); StringBuffer是StringBuilder的前身，其效率稍有些低， 但允许采用多线程的方式执行添加或删除字符的操作。 如果所有字符串在一个单线程中编辑 （通常都是这样)，则应该用 StringBuilder 替代它。 六、输入输出1. 读取输入1234567891011121314151617181920212223242526import java.util.*; //当使用的类不是定义在基本java.lang 包中时，一定要使用import指示字将相应的包加载进来。//构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。Scanner in = new Scanner(System.in);//使用 Scanner 类的各种方法实现输入String name = in.nextLine(); //nextLine()可读入空白符String firstName = in.next(); //以空白符结束int age = in.nextlnt(); //读取一个整数double num = nextDouble(); //读取一个浮点数boolean hasNext( ) //检测输人中是否还有其他单词。//检测是否还有表示整数或浮点数的下一个字符序列。boolean hasNextInt()boolean hasNextDouble()//用Console类从控制台读取密码Console cons = System.console();String username = cons.readLine(\"User name: \")；char[] passwd = cons.readPassword(\"Password:\"); //为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素//显示字符串 prompt 并且读取用户输入，直到输入行结束。args 参数可以用来提供输人格式。有关这部分内容将在下一节中介绍。static char[] readPassword(String prompt, Object...args)static String readLine(String prompt, Object...args) 采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有能够读取一个单词或一个数值的方法。 2. 格式化输出123456double x = 10000.0 / 3.0;System.out.print(x);System.out.printf(\"%8.2f\", x); //Java SE5.0沿用了C中的printf方法用于对输出进行各种格式控制//使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出String message = String.format(\"Hello, %s. Next year, you'll be %d\", name , age); 还可以在printf中给出控制格式化输出的各种标志:printf方法中日期与时间的格式化选项，格式包括两个字母， 以 t 开始， 以表中的任意字母结束： 12345System.out.printf(\"%tc\", new Date()); //打印当前完整的日期和时间//使用格式化的参数索引System.out.printf(\"l$s %2$tB %2$te, %2$tY\", \"Due date:\", new DateQ); //%1$表示对第1个参数格式化， Due date: February 9, 2015System.out .printf(\"%s %tB %&lt;te, %&lt;tY\", \"Due date:\", new DateO); //&lt; 示前而格式说明中的参数将被再次使用 以上有关printf方法中日期与时间的格式化选项已过时，新代码应使用java.time 包中的方法。printf格式说明符的语法图：许多格式化规则是本地环境特有的。例如，在德国，组分隔符是句号而不是逗号，Monday 被格式化为 Montag,java可以控制控制应用的国际化行为。 3. 文件输入与输出1234567//若读取文件时不设置字符编码，则会使用运行该java程序的默认编码，若在不同的机器上运行可能会有不同的表现//可使用Scannner的任意方法对文件进行读取Scanner in = new Scanner(Paths.get(\"myfile.txt\"), \"UTF-8\"); //如果文件名中包含反斜杠符号，需要在每个反斜杠之前再加一个额外的反斜杠：“ c:\\\\mydirectory\\\\myfile.txt ”//写入文件//可以像输出到 System.out—样使用 print、 println 以及 printf命令。PrintWriter out = new PrintWriter(\"myfile.txt\", \"UTF-8\"); 如果用一个不存在的文件构造一个Scanner,或者用一个不能被创建的文件名构造一个PrintWriter,那么就会发生异常。Java 编译器认为这些异常比“被零除”异常更严重。 七、控制流程1. 块作用域 块，即复合语句，是由一对大括号括起来的若干条简单的 Java 语句。 一个块可以嵌套在另一个块中。 但是，不能在嵌套的两个块中声明同名的变量，否则无法通过编译。 123456&#123; int n; &#123; int k; &#125;&#125; 2. 条件语句123456789101112131415if(condition)&#123;...&#125;if(condition)&#123; ...&#125;else&#123; ...&#125;if(condition1)&#123; ...&#125;else if(condition2)&#123; ...&#125;else if(condition3)&#123; ...&#125; 3. 循环12345678910111213while(condition)&#123; ...&#125;do&#123; ...&#125;while(condition);for (int i = 1; i &lt;= 10; i++)&#123; ...&#125;for (double x = 0; x != 10; x += 0 .1) //由于浮点数的舍入误差，该循环永远不可能结束 4. switch语句12345678910111213141516171819202122232425switch (choice) &#123; //case标签范围：类型为 char、byte、 short 或 int 的常量表达式。 case 1: //枚举常量。 ... //从 Java SE 7开始， case 标签还可以是字符串字面量。 break; case 2: ... break; case 3: ... break; case 4: ... break; default: ... break; &#125;Size sz = . . .;switch (sz) &#123; case SMALL: // 无需使用Size.SMALL ... break; ...&#125; 5. 中断控制流程语句12345678910111213141516171819202122232425262728//不带标签的break语句，用于跳出当前循环while(c)&#123; ... break;&#125;//带标签的break语句，用于跳出多重嵌套的循环语句,也可以应用到任何语句中。//标签必须放在希望跳出的最外层循环之前， 并且必须紧跟一个冒号。read_data:while(...)&#123; for(...)&#123; ... break read_data; &#125;&#125;label:&#123; ... if(condition) break label; ...&#125;//continue语句跳过本次循环剩余部分，进入下一次循环for(...)&#123; ... break;&#125; 八、大数值Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算，类提供的方法参见java文档https://docs.oracle.com/javase/8/docs/api/。 12345import java.math.*Biglnteger a = Biglnteger.valueOf(100); //将普通的数值转换为大数值Biglnteger c = a.add(b); // c = a + bBiglnteger d = c.multiply(b.add(Biglnteger.valueOf(2))); // d = c * (b + 2) 大数值不能使用 + 和 * 与 C++ 不同， Java 没有提供运算符重载功能。 程序员无法重定义 + 和 * 运算符，虽然为字符串的连接重栽了+ 运算符，但没有重载其他的运算符。 九、数组1. 数组的创建/初始化/匿名数组123456789101112int[] a = new int[100]; //也可用int a[];声明数组，但是不推荐，创建一个数字数组则所有元素会被初始化为0boolean[] b = new boolean[100]; //元素初始化为 falseString[] names = new String[10]; //对象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。int actualSize = . . .;Employee[] staff = new Employee[actualSize]; //Java允许在运行时确定数组的大小。a.length; //获取数组中元素个数int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13 &#125;; //创建数组的同时进行初始化small Primes = new int[] &#123; 17, 19, 23, 29, 31, 37 &#125;; //匿名数组初始化，可以在不创建新变量的情况下重新初始化一个数组new elementType[0]; //创建一个长度为 0 的数组,与null不同。 如果经常需要在运行过程中扩展数组的大小， 应该使用数组列表（array list)。 2. 数组的for each循环1234for (int element : a) System.out.println(element);System.out.println(Arrays.toString(a)); //以[2,3,5,7,11,13]方式打印数组 3. 数组拷贝1234567int[] luckyNumbers = smallPrimes; //将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组luckyNumbers[5] = 12; //如果数组元素是数值型，那么多余的元素将被赋值为 0 ; //如果数组元素是布尔型，则将赋值为 false。//相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length*2); //将一个数组的所有值拷贝到一个新的数组中去,第二个参数为新数组大小，该方法常用来增加数组大小 java中没有指针运算，不能通过 a+1 得到数组的下一个元素。[]被预定义为检查数组边界。 4. 命令行参数main函数中的String[] args表明main 方法将接收一个字符串数组， 也就是命令行参数。 12345678public class Message&#123; public static void main(String[] args) &#123; ... &#125;&#125;//在命令行输入命令可读入内容到args数组中,程序名并没有存储在 args 数组中java Message -g cruel world //args[0]:\"-g\" args[l]:\"cruel\" args[2]:\"cruel\" \"world\" 4. 数组排序123456789101112131415import java.util.Arrays;static String toString(type[] a) //类型为 int、long、short、 char、 byte、boolean、float 或 double 的数组。static type copyOf(type[]a, int length)static type copyOfRange(type[]a , int start, int end)static void sort(type[] a) //采用优化的快速排序算法对数组进行排序。static int binarySearch(type[]a , type v) //采用二分搜索算法查找值 vstatic int binarySearch(type[]a, int start, int end, type v) //类型为 int、 long、 short、 char、 byte、 boolean 、 float 或 double 的有序数组。static void fill(type[]a , type v) //将数组的所有数据元素值设置为 Vstatic boolean equals(type[]a, type[]b) //如果两个数组大小相同， 并且下标相同的元素都对应相等， 返回 true。 5. 多维数组12345678910111213141516//创建double[][] balances = new double[100][100];int[][] magicSquare = &#123; &#123;16, 3, 2, 13&#125;， &#123;5, 10, 11, 8&#125;, (9, 6, 7, 12&#125;, &#123;4, 15, 14, 1&#125; &#125;;//遍历for (double[] row : a) for (double value : row) .......//快速打印System.out.println(Arrays.deepToString(a)); //输出[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]//交换二维数组中的两行double[] temp = balances[i];balances[i] = balances[i + 1];balances[i + 1] = temp; 6. 不规则数组12345//首先分配一个具有所含行数的数组int[][] odds = new int[NMAX + 1][];//接下来，分配这些行for (int n = 0; n &lt;= NMAX ; n++) odds[n] = new int[n + 1];","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"Codeup和PAT刷题记录——入门模拟","date":"2020-04-24T08:45:22.000Z","path":"2020/04/24/算法笔记/入门模拟/","text":"记录刷题过程中遇到的问题和技巧。 一、技巧总结1. 简单模拟①将字符型数字转换为整型数字：例如&#39;8&#39;-&#39;0&#39;。②当 -109&lt;a,b&lt;109,或者-231&lt;a,b&lt;231，a+b仍为Int型,但当区间带等号时a,b,c都应当定义为long long型变量。 2. 图形输出③整数n/2避免使用round函数来进行四舍五入： 12if(n%2==0) n=n/2;else n=n/2+1; ②使用指定字符输出图形实质上是确定每一行输出的不同字符数与行数之间的数学计算关系。 3. 日期处理①日期处理问题往往需要使用数组存储与日期如平年和闰年的月份、月份和星期的英文字符串等 12345678910//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！month[m][0]存储平年每个月天数，month[m][1]存储闰年每个月天数 int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//存储月份英文名称和罗马数字的关系char monthToNum[13][20]=&#123;\" \",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\", \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;;//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ char numToWeek[8][20]=&#123;\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"&#125;; ②判断是否为闰年的函数写法 12//判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125; ③查找任意年y的某个月m的天数写法 1month[m][isLeapTear(y)]; ④提取int型变量中的任意几位：例如提取20130102中的YYYY、MM、DD。 1y1=date1/10000,m1=date1%10000/100,d1=date1%10000%100; ⑤计算任意两个日期间差值可分别计算它们与公元1年1月1日的差值然后再计算两个差值的差值。⑥计算某个日期的星期数可首先计算与公元1年1月1日天数差值，再对差值取余即为星期数的下标。 4. 进制转换①P进制数x转换为十进制数y，利用while循环 12345while(x!=0)&#123; y=y+(x%10)*product; x/=10; product*=P;&#125; ②十进制数y转换为Q进制数z[num-1,0],利用“除基取余法”和do while循环，防止y=0而没有输出 1234do&#123; z[num++]=y%Q; y/=Q;&#125;while(y!=0); ②注意当数组z为字符数组时，在末尾应手动添加’\\0’，否则容易出错。③当十进制整数超出整型可存储的范围时，用字符数组来存储处理比较方便，来模拟十进制整数的运算过程。 5. 字符串处理①边输入边处理被空格分隔的字符串有两种方式 12while((c=getchar())!='\\n')&#123;...&#125;while(scanf(\"%s\",s[num++])!=EOF); ②一定要注意scanf(“%c”)和gets(s)之间要用getchar()吸收换行符，否则很容易出错。③若题设条件未给出输入字符串格式，则应考虑带空格的输入。此时应用gets(s)进行输入。 二、经典题目1. 比较交换3个实数值，并按序输出题目描述从键盘输入3个实数a, b, c，通过比较交换，将最小值存储在变量a中，最大值存储在变量c中，中间值存储在变量b中，并按照从小到大的顺序输出这三个数a, b, c。末尾输出换行。输入输入以空格分隔的三个实数输出按照从小到大的顺序输出这三个实数，中间以空格分隔，最小值在前，最大值在后。小数点后保留2位小数。注意末尾的换行。样例输入3 7 1样例输出1.00 3.00 7.00 思路冒泡法。 12345678910111213#include&lt;stdio.h&gt;int main()&#123; double a,b,c,temp; scanf(\"%lf%lf%lf\",&amp;a,&amp;b,&amp;c); //冒泡法 if(a&gt;b)temp=a,a=b,b=temp; if(b&gt;c)temp=b,b=c,c=temp; if(a&gt;b)temp=a,a=b,b=temp; printf(\"%.2f %.2f %.2f\\n\",a,b,c); return 0;&#125; 2. 三个整数求最大值题目描述有3个整数a, b, c，由键盘输入，输出其中最大的数。输入以空格分割的三个整数。输出三个数中的最大值，末尾换行。样例输入1 3 2样例输出3思路比较 1234567891011#include&lt;stdio.h&gt;int main()&#123; int a,b,c,max; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); max=a&gt;b?a:b; max=max&gt;c?max:c; printf(\"%d\\n\",max); return 0;&#125; 3. 矩阵输出题目描述输出以下4*5的矩阵 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20要求使用循环实现，注意每行输出5个数字，每个数字占3个字符的宽度，右对齐。输入无输出每行输出5个数字，每个数字占3个字符的宽度，右对齐。样例输入无样例输出 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20思路 i保存每一行的输出值，a为每行的累加值， i=i+a; 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int i=1,a=1; while(a&lt;=4)&#123; printf(\"%3d\",i); //依次输出元素 if(i%5==0)&#123; printf(\"\\n\"),a++,i=a; continue; //若每行元素达到5个，则换行且重置a和i的值，并跳出本次循环。 &#125; i+=a; &#125; return 0;&#125; 4. 杨辉三角题目描述按要求输入如下格式的杨辉三角11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1最多输出10层输入输入只包含一个正整数n，表示将要输出的杨辉三角的层数。输出对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开样例输入5样例输出11 11 2 11 3 3 11 4 6 4 1思路i控制输出的行数，j控制每行元素个数，j&lt;=i,a[j]保存上一行的元素，b[j]根据a[j]计算本行的元素值并输出； ① 首先输出每行的第一个元素b[1]；② 然后控制j=2,j&lt;i,输出每行中间元素b[j]=a[j-1]+a[j]；③ 最后输出每行最后一个元素b[j]=a[j],并换行；④ 更新a[j]，回到步骤① 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,i,j,a[15]=&#123;0,1,1,1,1,1,1,1,1,1,1&#125;,b[15]; b[1]=a[1]; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++)&#123; printf(\"%d \",b[1]); //输出每一行第一个元素 for(j=2;j&lt;i;j++)&#123; //输出每行中间的元素 b[j]=a[j-1]+a[j]; printf(\"%d \",b[j]); &#125; if(j&gt;i)&#123; printf(\"\\n\"); continue; &#125; b[j]=a[j]; //输出每一行最后一个元素 printf(\"%d\\n\",b[j]); for(j=2;j&lt;i;j++) a[j]=b[j]; //更新a[j] &#125; return 0;&#125; 5. Shortest Distance (20)题目描述The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.输入Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.输出For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.样例输入5 1 2 4 14 931 32 54 1样例输出3107思路本题中的距离不能暴力求解，否则极易出现超时错误！ ①输入距离d的同时利用circle累加距离，并同时利用数组dist[i+1]=circle记录出口i到出口1的距离，输入结束后circle即为计算的周长。②计算任意出口a,b间的顺时针距离d1，利用d1=abs(dist[b]-dist[a])。③计算任意出口a,b间的逆时针距离d2，利用d2=circle-d1。④输出d1和d2中较小的那一个距离。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; //Codeup中的C++编译器不支持cmath中的abs函数int main()&#123; int N,M,a,b,d; //出口个数N、区间[a,b]的个数M，以及出口间距离d while(scanf(\"%d\",&amp;N)!=EOF)&#123; int circle=0,dist[100010]=&#123;0&#125;; //周长及各出口离起始出口的距离 for(int i=1;i&lt;=N;i++)&#123; scanf(\"%d\",&amp;d); circle+=d; //计算周长 dist[i+1]=circle; //计算各出口距离出口1的距离 &#125; scanf(\"%d\",&amp;M); while(M--)&#123; int d1,d2; //正向反向距离 scanf(\"%d%d\",&amp;a,&amp;b); d1=abs(dist[b]-dist[a]); //计算正向距离 d2=circle-d1; //反向距离=周长-正向距离 if(d1&gt;d2) printf(\"%d\\n\",d2); else printf(\"%d\\n\",d1); &#125; &#125; return 0;&#125; 6. 日期差值题目描述有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。 输入有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD 输出每组数据输出一行，即日期差值 样例输入2013010120130105样例输出5思路 ①首先求出每个日期到公元1年1月1日的天数days1和days2，则days2-days1+1即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125;//计算任意日期距离公元1年1月1日的天数 int daysFromFirstYear(int y,int m,int d)&#123; int days=0,i=1,j=1,k=1; //累加年 for(;i&lt;y;i++)&#123; if(isLeapYear(i)) days+=366; else days+=365; &#125; //累加月 for(;j&lt;m;j++)&#123; if(isLeapYear(i)) days+=month[j][1]; else days+=month[j][0]; &#125; //累加日 days+=(d-k+1); return days;&#125; int main()&#123; int y1,m1,d1,y2,m2,d2; int date1,date2; while(scanf(\"%d\\n%d\",&amp;date1,&amp;date2)!=EOF)&#123; if(date1&gt;date2)&#123; int temp=date1; date1=date2; date2=temp; &#125; y1=date1/10000,m1=date1%10000/100,d1=date1%10000%100; y2=date2/10000,m2=date2%10000/100,d2=date2%10000%100; int days1,days2; days1=daysFromFirstYear(y1,m1,d1); days2=daysFromFirstYear(y2,m2,d2); printf(\"%d\\n\",days2-days1+1); &#125; return 0;&#125; 7. Day of Week题目描述We now use the Gregorian style of dating in Russia. The leap years are years with number divisible by 4 but not divisible by 100, or divisible by 400.For example, years 2004, 2180 and 2400 are leap. Years 2004, 2181 and 2300 are not leap.Your task is to write a program which will compute the day of week corresponding to a given date in the nearest past or in the future using today’s agreement about dating. 输入There is one single line contains the day number d, month name M and year number y(1000≤y≤3000). The month name is the corresponding English name starting from the capital letter. 输出Output a single line with the English name of the day of week corresponding to the date, starting from the capital letter. All other letters must be in lower case. 样例输入21 December 20125 January 2013样例输出FridaySaturday思路 ①存储闰年平年天数int month[13][2]、英文月份char monthToNum[13][20]以及英文星期char numToWeek[8][20]，注意!格里高利纪元中公元1年1月1日为星期一;②计算给定日期距离1年1月1日天数days;③numToWeek[days%7]即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt; //存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;, &#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//存储月份英文名称和罗马数字的关系char monthToNum[13][20]=&#123;\" \",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\", \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;;//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ char numToWeek[8][20]=&#123;\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"&#125;; //判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125;//计算任意日期距离公元1年1月1日的天数 int daysFromFirstYear(int y,int m,int d)&#123; int days=0,i=1,j=1,k=1; //累加年 for(;i&lt;y;i++)&#123; if(isLeapYear(i)) days+=366; else days+=365; &#125; //累加月 for(;j&lt;m;j++)&#123; if(isLeapYear(i)) days+=month[j][1]; else days+=month[j][0]; &#125; //累加日 days+=(d-k+1); return days;&#125; int main()&#123; int d,m,y; char mon[20]; while(scanf(\"%d%s%d\",&amp;d,mon,&amp;y)!=EOF)&#123; //获取英文月份的罗马数字 for(int i=1;i&lt;=12;i++)&#123; if(strcmp(monthToNum[i],mon)==0)&#123; m=i; break; &#125; &#125; int days=daysFromFirstYear(y,m,d); printf(\"%s\\n\",numToWeek[days%7]); &#125; return 0;&#125; 8. 进制转换题目描述将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。 输入多组数据，每行为一个长度不超过30位的十进制非负整数。（注意是10进制数字的个数可能有30个，而非30bits的整数） 输出每行输出对应的二进制数。 样例输入9852111126样例输出11110110011101001110001100110思路 ①输入超过整型可存储范围，使用字符数组模拟除法过程和判断是否为0过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt; //模拟十进制除法，返回余数 char divideBy2(char number[],char result[])&#123; int num=0,sum=0; for(int i=0;i&lt;strlen(number);i++)&#123; int temp=number[i]-'0'; sum=sum*10+temp; result[num++]=sum/2+'0'; sum=sum%2; &#125; result[num]='\\0'; return sum+'0';&#125;//判断字符串转为十进制是否为0 bool isZero(char number[])&#123; int i; for(i=0;i&lt;strlen(number);i++)&#123; if(number[i]!='0') return false; &#125; if(i==strlen(number)) return true;&#125; //输入超过整型可存储范围，使用字符数组模拟除法过程 int main()&#123; char number[35]; char result[100]; char left[100]; //定义商和余数 while(scanf(\"%s\",number)!=EOF)&#123; int num=0; do&#123; left[num++]=divideBy2(number,result); strcpy(number,result); &#125;while(!isZero(number)); for(int i=num-1;i&gt;=0;i--) printf(\"%c\",left[i]); printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"}]},{"title":"算法复杂度和黑盒测试","date":"2020-04-23T15:29:52.000Z","path":"2020/04/23/算法笔记/算法复杂度和黑盒测试/","text":"引言了解算法复杂度很重要，我们在编写算法时常常要注意算法复杂度以避免出现程序运行超时的结果，此外，了解常用OJ的黑盒测试方法也有助于编写正确高效的算法。本篇简单介绍了三种算法复杂度和黑盒测试的代码写法，并简单罗列了OJ在判定时出现的一些结果，以便找到出错原因。 一、算法复杂度1. 时间复杂度时间复杂度是算法执行基本运算(如加减乘除)的次数所处的等级，是评判算法时间效率的有效标准，较高的时间复杂度会让评测系统返回“运行超时”，对一般的OJ系统来说，一秒能承受的运算次数大概是107至108。 讲时间复杂度是不带系数的，称为时间复杂度常数，例如基本运算次数为cn,cn2，则时间复杂度分别为O(n)，O(n2)。 高等级的幂次会覆盖低等级的幂次，因此O(3n2+n+2)=O(n2)。 当某些算法实现较为复杂时，其常数会比较大，这时即使时间复杂度相同其性能也会有较大差距。 不同级别时间复杂度比较：O(1)&lt;O(logn)&lt;O(n)&lt;O(n2)。 2. 空间复杂度空间复杂度和时间复杂度的写法相同，表示算法需要消耗的最大数据空间。一般来说空间都是足够使用的，只要不开好几个107以上的数组，故一般会使用以空间换时间的算法策略。 3. 编码复杂度编码复杂度是一个定性的概念，没有一个量化标准，就是指代码的冗长程度。如果使用了冗长的算法思想则编码复杂度就会很大。 二、黑盒测试OJ后台会准备若干组数据(一般是放在一个文件里)让程序运行，并将运行结果在字符串意义上进行比较，若完全相同，则称通过了本题的黑盒测试，否则返回不同判定结果，根据黑盒测试对每组数据单独测试还是一次性全部测试，分为单点和多点测试。 1. 单点测试PAT采取的是单点测试，它会对每组数据都给出相应的测评结果，并且每组数据都有得分值，题目总得分等于通过数据得分值之和。所以它仅要求编写的程序能一次运行一组数据，采用普通写法。 2. 多点测试大部分OJ如Codeup等都是采用多点测试，它要求编写的程序能够一次性运行所有的数据，并要求所有输出结果都必须完全正确才算通过测试，故需要用到循环结构。多点测试能够考验算法编写的严谨性。题目一般会有3种输入格式，需要采取不同的输入方式。 三种输入类型 123456789101112131415//循环输入直到文件末尾while(scanf(\"%d\",&amp;n)!=EOF)&#123; ...//scanf返回值为成功读入的参数个数，当读取文件到达末尾时才会读取失败，此时返回-1，C语言中用EOF(End Of File)代替-1。 //在运行框输入数据时并不会触发EOF，需要手动输入&lt;Ctrl+Z&gt;键，再按&lt;Enter&gt;键触发。&#125;while(scanf(\"%s\",str)!=EOF)&#123;...&#125;while(gets(str)!=NULL)&#123;...&#125;//输入直到满足某个条件时退出while(scanf(\"%d%d\",&amp;a,&amp;b), a||b)&#123; ...//当a和b中有一个不为零时就进行循环。注意！输入多少数据(&amp;a和&amp;b)，判零条件就有几个(a||b)，否则输入输出的格式会出错。&#125;//输入题目指定组数的数据while(T--)&#123;...&#125; 另外要注意！多点测试中每一次循环都要重置一下变量和数组(memset函数或fill函数)，否则在下一组数据来临之前变量和数组的状态就不是初始状态了。 三、OJ常见评测结果1. 答案正确(Accepted, AC)若为单点测试，则每通过一组数据就会返回一个Accepted,若是多点测试，那么只有当通过了所有数据时，才会返回Accepted。 2. 编译错误(Compile Error, CE)出现这种情况有可能是选错了语言。 3. 答案错误(Wrong Answer, WA)代码逻辑问题或输出的内容有误。 4. 运行超时(Time Limit Excees, TLE)一般来说，导致该结果是由于算法的时间复杂度导致的，也可能是某组数据使得代码某处死循环了。 5. 运行错误(Runtime Error, RE)段错误(非法访问内存，如数组越界、指针乱指)、浮点错误(例如除数为0、模数为0)、递归爆栈(一般由于递归层数过深)。 6. 内存超限(Memory Limit Exceeded, MLE)如果程序使用太多空间，例如数组太大可能会导致此结果。 7. 格式错误(Presentation Error, PE)多输出了空格或换行。 8. 输出超限(Output Limit Exceeded, OLE)输出了过量的内容，如大量调试信息或者特殊数据导致的死循环。","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"}]},{"title":"C和C++的常用语法","date":"2020-04-15T09:45:33.000Z","path":"2020/04/15/算法笔记/C和C++常用语法/","text":"在算法机试中，最适合使用的就是C语言和C++语言，C++可以向下兼容C，且其基本语法除了输入输出部分，其余顺序结构、循环结构、数组、指针都是几乎一样的。C++中的cin和cout消耗时间比C中的scanf和printf多得多，而C中有一些不太顺手的设定可以使用C++来取代，故我们在机试时通常选择C++的编译器，而混用C和C++的语法来优化算法。本篇简单介绍一下机试中常用的C/C++基本语法。 一、C程序的组成1234567#include &lt;stdio.h&gt;int main()&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\",a+b); return 0;&#125; 1.头文件#include &lt;stdio.h&gt;即是头文件，用来添加程序中需要使用到的库函数，其中stdio.h是标准输入输出库，是一个.h格式的文件，其中包含了一些与输入输出有关的东西，其他功能的库文件还有math.h，负责数学函数,string.h负责字符串相关函数，等等。当我们需要用到这些库函数时就必须将其头文件include起来。此外，C++中的等价写法为#include &lt;csdio&gt;,#include &lt;cmath&gt;,include &lt;cstring&gt;。 2.主函数12345int main()&#123; ... return 0;&#125; 主函数是一个程序的入口，也就是程序开始执行的地方，一个程序最多只能有一个主函数。注意！请不要在同一个程序中使用cout和printf，有时会出问题。 二、基本数据类型1. 变量的定义变量类型 变量名;变量类型 变量名 = 初值;变量名区分大小写。 2. 变量类型 2.1 整型短整型(short): 2Byte，机试中一般用不到。整型(int): 4Byte,绝对值在109范围内整数都可以定义为Int型。长整型(long long): 8Byte,赋值大于231-1的初值，需要在初值后面加上LL，否则编译错误。 2.2 浮点型单精度(float): 有效精度6-7位。双精度(double): 有效精度15-16位,因此机试中碰到浮点型一般都是用double来存储。 浮点数在经过容易损失精度得计算后，计算结果总是不精确得，有一定得误差，故需要引入一个极小数eps来修正误差，从而进行各种比较操作，可以取eps为10-8,变量b的浮动范围为[b-eps,b+eps],各种比较操作的宏定义如下： a==b: a&gt;b: a&lt;b: a&gt;=b: a&lt;=b: 123456789101112131415#include &lt;stdio.h&gt;#include &lt;math.h&gt;double db1=4*asin(sqrt(2)/2); //PI的损失精度的计算double db2=3*asin(sqrt(3.0)/2);db1==db2; //flase;const double pi=acos(-1); //定义piconst double eps=1e-8; //注意该用括号的地方用括号#define Equ(a,b) ((fabs((a)-(b)))&lt;(eps)) //a==b,不等于可使用!Equ(a,b)#define More(a,b) (((a)-(b))&gt;(eps)) //a&gt;b#define Less(a,b) (((a)-(b))&lt;(-eps)) //a&lt;b#define MoreEqu(a,b) (((a)-(b))&gt;(-eps)) //a&gt;=b#define LessEqu(a,b) (((a)-(b))&lt;(eps)) //a&lt;=b 2.3 字符型字符常量和字符变量: 1char c1 = 'z', c2 = 'j', c3 = 117; 字符常量统一使用ASCII编码，小写字母比大写字母码值大32。0-9（48-57），A-Z（65-90），a-z（97-122）。转义字符: \\n（换行）、\\t（Tab）、\\0（代表空字符NULL，其ASCII码为0，请注意\\0不是空格） 字符串常量: 1char str[25]=\"wo ai de ren ye ai wo\"; C语言中无基本数据类型可存储字符串常量，只能用字符数组，而C++中有string类型。 2.4 布尔型1bool flag1=0, flag2=true; bool在C++中可直接使用，在C中必须添加stdbool.h,但机试选择C++编译器，故可不添加。用整型赋值时true(非零)，false(零)。bool可以%d格式输出0或1。 3. 强制类型转换1(新类型名)变量名; 其中(int)f直接将小数部分切掉，即向下取整。在赋值时，编译器可以自动进行转换，但在计算过程中需要手动强制类型转换。 4. 符号常量和const常量(宏定义、宏替换)#define 标识符 常量 : 1#define pi 3.14 const 数据类型 变量名 = 常量; : 推荐方式。 1const double pi = 3.14; #define 标识符 任何语句或片段 : 不推荐。 1# difine ADD(a,b) ((a)+(b)) 由于宏定义是直接将对应部分替换然后进行编译和运行，故能加括号的地方应添加括号，否则会出现逻辑错误。 5. 运算符7个常用算术运算符 : + - * / % ++ --+ - * /优先级与四则运算相同， %和/优先级相同，且当/和%的除数为0时会导致程序异常退出或得到错误”1.#INF00”。6个关系运算符 : &lt; &gt; &lt;= &gt;= == !=3个逻辑运算符 : &amp;&amp; || ！1个条件运算符(c中唯一的三目运算符) : A ? B : C6个位运算符 : &lt;&lt;(左移) &gt;&gt;(右移) &amp;(位与) |(位或) ^(位异或) ~(位取反)运算符的优先级和结合性参见https://zh.cppreference.com/w/c/language/operator_precedence程序中无穷大的数INF的设置： 1const int INF = (1 &lt;&lt; 30) - 1; 或者 1const int INF = 0x3fffffff; 二者等价。 三、顺序结构1. 赋值表达式给多个变量赋值，可使用连续等号。 12int n, m;n = m = 5; 复合赋值运算符+= -= *= /= %=可以加快编译速度，提高代码可读性，故在程序中经常用到。 2. 使用C语言中的scanf和printf输入/输出2.1 scanf(“格式控制”,变量地址)123scanf(\"%d:%d:%d\",&amp;hh,&amp;mm,&amp;ss); //输入hh:mm:ssscanf(\"%d,%lf%c\",&amp;a,&amp;b,&amp;c); //输入a,b,cscanf(\"%d%d\",&amp;a,&amp;b); //输入a b scanf函数的格式控制符如下图所示： 格式控制和我们在控制台输入的格式一致。 &amp;为取地址符，char数组名本来就是一个地址，故不需要&amp;。 除了控制符%c可以读入一个空白符(空格、换行、Tab)以外,scanf的其他格式符的输入均以空白符为结束判断标志。 scanf中可以用转义字符，不过一般用不到。 2.2 printf(“格式控制”, 变量名称)1printf(\"%d\",n); printf函数的格式控制符如下图所示： printf中不使用&amp;。 注意double类型变量scanf的格式符为%lf,printf的格式符为%f。 printf中可使用转义字符\\n、\\t等。 12printf(\"%%\"); //输出%printf(\"\\\\\"); //输出\\ 3种实用的输出格式: %md &emsp;使不足m位的int变量以M位右对齐输出，高位空格补齐；若变量本身超过m位则保持原样。%0md &nbsp;相比于%md高位补0。%.mf &nbsp;使浮点数保留m位小数输出，使用“四舍六入五成双”规则，而不是四舍五入。 C++中的输入与输出函数cin与cout 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt; //string#include &lt;iomanip&gt; //控制double型精度using namespace std;cin&gt;&gt;n&gt;&gt;db&gt;&gt;c&gt;&gt;str;cout&lt;&lt;n&lt;&lt;\" \"&lt;&lt;db&lt;&lt;\" \"&lt;&lt;str&lt;&lt;\"haha\"&lt;&lt;\"\\n\"&lt;endl; //\"\\n\"和endl都表示换行char str[100];cin.getline(str,100); //读入一行string str; //使用C++中的string容器输入一行getline(cin,str);cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;123.4567&lt;&lt;endl; //控制double型变量输出小数点后两位。 cin与cout在输入/输出大量数据的情况下表现得非常糟糕，有时题目中数据还没有输入完毕就已经超时，故还是推荐使用scanf与printf输入与输出。 3. 使用getchar和putchar输入/输出字符getchar用来输入单个字符，注意它能够读入空白符，它经常使用在某些scanf使用不便的场合。putchar用来输出单个字符。 4. 注释123456//单行注释/*多行注释...*/ 编译时会自动跳过注释部分，不执行。 5. typedef用于给复杂的数据类型起一个别名，用别名代替原来的写法，提高编码效率。 1typedef long long LL; 6. 常用math函数除了abs在C编译器中需要添加stdlib.h外，其它数学函数使用时需要添加头文件math.h和cmath。注意! 123456789101112131415161718192021double fabs(double x); // double型变量取绝对值int abs(int x); //int型变量取绝对值double floor(double x); //向下取整double ceil(double x); //向上取整double pow(double x, double p); //返回x的p次方double sqrt(double x); //返回根号xdouble log(double x); //返回以自然对数e为底数的logx,c语言中没有对任意底数求对数的函数，只能使用此公式和换底公式来实现。double sin(double x); //三角函数,x必须为弧度制，如pi/2double cos(double x);double tan(double x);const double pi = acos(-1.0); double asin(double x); //反三角函数double acos(double x);double atan(double x);double round(double x); //对x四舍五入到整数位，以%d格式printf时需取整(int)double round(double x)&#123;return (x&gt;0.0) ? floor(x+0.5) : ceil(x-0.5);&#125; //有些编译器如PAT不支持round函数，可利用floor和ceil写一个。 四、选择结构1. if语句用于分支条件较少的情况。 123456789101112131415161718192021222324252627if(A)&#123; ...&#125;if(A)&#123; ...&#125;else&#123; ...&#125;if(A)&#123; ...&#125;else if(B)&#123; ...&#125;else&#123; ...&#125;if(A)&#123; //if语句嵌套 ... if(B)&#123; ... &#125; ...&#125;else&#123; ...&#125; 2. switch语句用于分支条件较多的情况。 12345678910111213switch(表达式)&#123; case 常量表达式1: ... break; case 常量表达式2; ... break; case 常量表达式n; ... break; default: ...&#125; 删除break则会从第一个匹配的case开始执行之后的所有语句。 五、循环结构1. while语句1234567while(A)&#123; //推荐 ...&#125;do&#123; ...&#125;while(A); //不推荐 2. for语句123for(A;B;C)&#123; //注意！C中A位置不允许定义变量而C++可以。 ...&#125; 3. break和continue语句break：跳出循环体。continue：跳出当前循环，即continue后面的代码不执行，直接进入下一轮循环。 六、数组如果数组大小较大（大概106级别），则需要将其定义在主函数外面，否则会使程序异常退出，因为函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的全局变量来自静态存储区，允许申请的空间较大。数组的长度计算： 1int length = sizeof(arr) / sizeof(arr[0]); //数组占内存总空间，除以单个元素占内存空间大小 1. 一维数组1数据类型 数组名[数组大小]; //数组大小必须是整数常量，不可以是变量。 初始化： 123int a[10]=&#123;1,2&#125;; //后面未被初始化的元素将根据编译器内部实现的不同而被赋以不同的初值（可能是很大的随机数），但一般默认为0。int a[10]=&#123;0&#125;;int a[10]=&#123;&#125;; 2. 二维数组1数据类型 数组名[第一维大小][第二维大小]; 初始化： 1int a[5][6]=&#123;&#123;1,2,3&#125;,&#123;&#125;,&#123;8,4&#125;&#125;; 3. 字符数组 初始化：12char str[15] = &#123;'G','o','o','d',' ','s','t','o','r','y','!'&#125;;char str[15] = \"Good story!\"; //直接赋值字符串，注意！仅限于初始化，程序其他位置不允许这样直接赋值整个字符串。 注意！定义了数组或字符指针之后，需要做一个初始化，否则里面将是随机值，以后将无法判断改字符串是否为空。123memset(数组名,‘\\0’,sizeof(数组名)); if (strlen(str) == 0) //推荐判空方式 if (str[0] == '\\0') /避免使用，容易crash 输入输出：12345678910char str[10];scanf(\"%c\",&amp;str[0]); //%c能读入空白符（空格，TAB，换行），%s以空白符为结束符。scanf(\"%s\",str);printf(\"%s\",str);str[0]=getchar(); //getchar()可以读入空白符。注意！在scanf(\"%s\\n\")和gets(str)之间应先使用getchar()吸收掉\\n，否则不能读取str,因为gets(str)以\\n为结束符。putchar(str[0]);gets(str); //gets()以换行符\\n为结束符，可以读入空格。PAT OJ中不支持gets()函数。puts(str); //输出一个字符串并紧跟换行 3. 字符数组的存放方式：每一个一维数组的末尾都有一个空字符\\0，占一位，表示存放的字符串的结尾，puts和printf就是通过识别\\0来输出字符串的。故在定义字符数组时长度一定要比实际存储字符串的长度至少多1。\\0在使用gets和scanf(“%s”)时会自动添加，其他的输入如getchar()则需要在字符串末尾手动添加\\0，否则puts和printf将由于无法识别字符串末尾而输出一大堆乱码。 4. memset——对数组中每一个元素赋相同的值12#include&lt;string.h&gt;memset(数组名，值，sizeof(数组名)); //速度快，但它是按字节赋值，即对每一个字节赋同样的值，故常用它赋0或-1不容易出错。 5. string.h头文件包含了很多关于字符数组的函数。 123456#include&lt;string.h&gt;int strlen(str); //返回字符数组中第一个\\0之前的字符的个数。int strcmp(str1,dtr2); //按字典序返回两个字符串大小的比较结果: 大于0的数(str1 &gt; str2)、返回0(str1 == str2)、小于0的数(str1 &lt; str2),返回值根据不同编译器处理而有不同的返回值，通常为1、0、-1。void strcpy(str1,str2); //将str2复制给str1，包括\\0。void strcat(str1,str2); //将str2拼接到str1的后面。 6. sscanf与sprintf处理字符串格式输入输出问题的利器。 1234567#include&lt;stdio.h&gt;sscanf(str, \"%d\", &amp;n); //将str中的内容以%d格式写入n中，从左至右。sprintf(str, \"%d\", n); //将n以%d格式写入字符数组str中，从右至左。sscanf(str, \"%d:%f,%s\",&amp;n1,&amp;n2,&amp;n3);sprintf(str, \"%d:%.2f,%s\",n1,n2,n3); sscanf还支持正则表达式，可解决字符串中的复杂问题。 七、函数1. 函数定义12345返回类型 函数名称(参数类型 参数)&#123; 函数主题&#125;void func(int c); //值传递,传入的是实参的一个副本，故不能改变实参的值 2. 以数组作为函数参数123void func(int a[], int b[][5]); //第一维度可不写长度，第二维度需要写明长度，可以再函数内部修改实参数组中的元素的值。func(a,b); //调用时只需要写数组名。 注意！数组可以作为函数的参数却不允许作为函数返回值，若想返回数组只有将返回的数组作为参数传入。函数可以嵌套调用，也可以递归调用。 八、指针C语言中用指针来表示内存地址，它是一个unsigned类型的整数，若这个内存地址恰好是某个变量的地址，则称这个指针指向该变量，变量的地址一般指它占用的字节中第一个字节的地址。在变量前加上取地址运算符&amp;即可得到变量的地址。 1. 指针变量指针变量用来存放指针。 1234567891011121314//定义和初始化int a,b;int* p=&amp;a; //C++写法，地址是赋值给p而不是*p的，*是类型的一部分。int *p1=&amp;b,p2; //C写法int *q1,*q2,*q3; //基类型(int)必须和指针变量存储的地址类型相同。char* str=\"I love china!\";*(str+1); //获得str+1位置的字符printf(\"%s\",a+n); //输出包括a+n位置及后面所有字符的字符串。//操作*p; //获得变量a的值，对*p的操作等同于对a操作。 p+1; //p所指的int型变量的下一个int型变量地址，跨越了一整个Int型(4Byte)。p++,p--;p1-p2; //2个指针之间相差的Int型变量的个数。 注意！若指针不进行初始化则指向的地址是随机的，而且很可能随机指向系统工作区，那么就会出错。 2. 使用指针变量作为函数参数使用指针变量作为函数参数时，在函数内部对指针变量(形参)本身进行修改并不能使传入的指针变量(实参)改变，因为传入的指针变量相当于传入一个副本，能够使实参改变的只能是该函数中对指针指向的数据进行的修改。 123456void swap(int* m, int* n)&#123; int temp=*m; *m=*n; *n=temp;&#125;swap(p,p1); 3. 引用引用(&amp;，区分取地址符)可以不使用指针，也能达到修改传入参数的目的，且引用不产生副本，而是给原变量(而不是常量，常量不可使用引用)起了个别名，故旧名字与新名字指向同一个东西，对引用变量的操作就是对原变量的操作。 12void func(int &amp;x);func(p2); 指针的引用：通过将指针的引用作为形参，从而达到将传入的地址交换以交换两个变量的结果。 1234567void swap(int* &amp;m, int* &amp;n)&#123; int* temp=m; m=n; n=temp;&#125;swap(p,p1); //swap(&amp;p,&amp;p1)写法错误，因为&amp;p,&amp;p1为常量，而常量不可使用引用。 九、结构体(struct)的使用需要将一些相关的变量放在一起存储时，需要用到结构体。 123struct Name &#123; //一些基本的数据结构或自定义的数据类型。&#125;结构体变量名; 1. 结构体的定义123456789struct StudentInfo &#123; int id; char gender; char name[20]; char major[20]; StudentInfo* next; //结构体内不能定义自己，会引起循环定义问题，但可以定义自身类型的指针变量，它可以定义除自身外的任何数据类型。注意！结构体指针变量不能在匿名结构体内定义。&#125;Alice,stu[1000]; //直接定义结构体变量StudentInfo Bob,*p; 2. 访问结构体内的元素12345678910stu[0].id;stu[0].gender;(*p).id;(*p).name;(*p).next;p-&gt;id;p-&gt;name;p-&gt;next; 3. 结构体的初始化和赋值结构体使用构造函数来进行初始化，对于一个普通定义的结构体，其内部会生成一个默认构造函数(但不可见)，如studentInfo(){}，正是由于默认构造函数的存在才可以直接定义结构体变量而不进行初始化，因为它没有让用户提供任何初始化参数。 1234567891011121314struct StudentInfo&#123; int id; char gender; StudentInfo(int _id, char _gender)&#123; //自定义构造函数 id=_id; gender=_gender; &#125; StudentInfo(int _id, char _gender): id(_id), gender(_gender) &#123;&#125; //构造函数的简化写法&#125;stu[3]=&#123;1,'M',2,'F'&#125;;StudentInfo stu = StudentInfo(10086,'M'); //初始化结构体stu[2]=stu; //C++中相同类型结构体之间可以直接赋值，而C语言中不可以。 注意！若自定义了构造函数而不想进行初始化，则需要手动添加默认构造函数。只要参数和类型不完全相同，就可以定义任意多个构造函数，以适应不同的初始化场合。 4. 共用体共用体可定义在结构体内部，用于建立有不同类型数据组成的组合型的数据结构。原则上，共用体的大小取决于占据最多内存的成员的长度，但会受到最宽基本类型成员大小的影响。即:共用体的总大小为共用体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。 12345678union MyUnion&#123; int i; char chs[11];&#125;u = &#123; 10 &#125;, u2 = &#123;.chs=\"niko\"&#125;; // 初始化;union MyUnion mu = &#123; 1 &#125;; // 默认初始化第一个成员union MyUnion mu2 = &#123; .chs = \"hello\" &#125;; // 指定要初始化的成员","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"},{"name":"C","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"}]},{"title":"SpringMVC","date":"2019-02-20T04:05:33.000Z","path":"2019/02/20/Spring实战/SpringMVC/","text":"","tags":[{"name":"java","slug":"java","permalink":"https://sunnyyi.github.io/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://sunnyyi.github.io/tags/Spring/"}]}]