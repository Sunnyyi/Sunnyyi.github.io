[{"title":"Codeup和PAT刷题记录——算法初步","date":"2020-05-20T08:45:22.000Z","path":"2020/05/20/算法笔记/算法初步/","text":"记录刷题过程中遇到的问题和技巧。 一、技巧总结1.排序1.1 简单选择排序总共进行n趟操作，每趟选出A[i，n]中最小的元素与A[i]交换。 123456789101112void selectSort()&#123; for(int i=1;i&lt;=n;i++)&#123; int k=i; for(int j=i;j&lt;=n;j++)&#123; if(A[j]&lt;A[k]) k=j; &#125; int temp=A[i]; A[i]=A[k]; A[k]=temp; &#125;&#125; 1.2 直接插入排序总共进行n-1趟，每趟将A[i]插入A[i-1,1]中合适位置。 12345678910void insertSort()&#123; for(int i=2;i&lt;=n;i++)&#123; int temp=A[i]; for(int j=i;j&gt;1;j--)&#123; if(temp&lt;A[j]) A[j]=A[j-1]; &#125; A[j]=temp; &#125;&#125; 1.3 C++标准模板库中的sort()由于c语言中的qsort函数涉及很多指针操作，且std中的sort()在实现中规避了经典快速排序中可能出现的导致实际时间复杂度退化到O(n2)的极端情况。使用C++头文件需要添加std的命名空间： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数cmp(非必填，默认递增排序)) //注意序列中的元素一定要有可比性才可以不写cmp函数，否则需指定cmp比较规则，例如结构体。//基本数据类型数组的排序 int double ...int A[6]=&#123;&#125;;bool cmp(int a, int b) &#123;return a&gt;b;&#125;sort(A,A+4,cmp); //将A[0]-A[3]从大到小排序//结构体的排序struct Node&#123; int x,y; char name[10];&#125;ssd[10];bool cmp(node a, node b)&#123; //若x不等，按x从大到小排序，否则按y从小到大排序。 if(a.x!=b.x) return a.x&gt;b.x; else return a.y &lt; b.y&#125;strcmp(a.name,b.name)&lt;0; //表示a.name字典序小于b.name的字典序。&lt;font color=Crmison&gt;注意！strcmp返回值不一定是-1或+1,故==-1写法错误。&lt;/font&gt;sort(ssd,ssd+3,cmp);//容器的排序vector&lt;int&gt; vi;vi.push_back(3);....//初始化bool cmp(int a, int b) &#123;return a&gt;b;&#125; //vector中类型为int型sort(vi.begin,vi.end,cmp);string str[3]=&#123;\"bbbb\",\"cc\",\"aaa\"&#125;;str[0]&gt;str[1]; //true,c++中string之间可直接比较大小。bool cmp(string str1,string str2)&#123;return str1.length &lt; str2.length;&#125; //按字符串长度递增排序sort(str,str+3);sort(str,str+3,cmp); 1.4 排名的实现分数不同排名不同，分数相同排名相同但占用一个排位：先排序：思路1：将排名这一项添加到结构体中进行记录，若当前个体分数等于上一个个体则排名等于上一个个体排名，否则当前个体排名等于数组下标+1。思路2：不记录进结构体，直接输出排名。 2. 散列2.1 散列的定义有些算法题消耗时间很长，需要利用空间换时间的策略，如将输入的数字作为数组下标来统计这个数出现的次数，而输入的数不一定为整数，且有可能出现冲突，即输入多个相同的数，这时就需要用到散列的策略。定义：将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素。可使用C++标准模板库中的map或reordered_mp直接使用整数hash的功能。散列常应用在查找某个字符串或数字是否出现或出现的次数。 2.2 整数散列其中直接定址法、平方取中法、除留余数法为散列方法；线性探查法(开放定址法)、平方探查法(开放定址法)、链地址法(拉链法)为解决冲突的方法。 2.2.1 直接定址法H(key)=keyH(key)=a*key+b 2.2.2 平方取中法取key的平方的中间若干位作为hash值，很少用。 2.2.3 除留余数法为最常用方法。H(key)=key%mod该方法可将一个较大的数变为可行的数组下标。表长TSize必须不小于mod，否则越界，一般取TSize=mod，且mod取素数可有效避免冲突。 2.2.4 线性探查法若H(key)位置被占用，则检查H(key)+1，H(key)+2,…，直到找到一个没被占用的位置，若超过了表长则回到表的首位继续循环查找。此方法容易出现扎堆现象，即表中连续若干个位置都被使用，一定程度上会降低效率。 2.2.5 平方探查法 该方法可避免扎堆现象。 若H(key)位置被占用，则检查H(key)+12，H(key)-12,H(key)+22,H(key)-22…，直到找到一个没被占用的位置，也可只进行正向平方探查。 若超过了表长则计算(H(key)+k2)%mod。 若H(key)-k2&lt;0,则计算((H(key)-k2)%TSize+TSize)%TSize;相当于将H(key)-k2不断加上TSize直到出现第一个非负数。 可证明，若k在[0，TSize)范围内都无法找到位置，那么当k&gt;=TSize时也一定无法找到位置。 2.2.6 链地址法（拉链法）设定一个数组链表，Link[0]-Link[mod-1],用Link[h]将所有H(key)=h的key链接起来。注意！以上方法一般都无需自己实现，除非必须模拟这些算法或提升效率，否则都可以直接使用标准模板库中的map函数来直接使用hash功能，C++11以后可以用unordered_map，速度更快。 2.3 字符串hash初步利用其它进制转换为10进制的策略，仅限字符串长度不是很长的情况。 若字符串均由大写字母构成：将26个大写字母视为26进制，转换为10进制。 若出现了小写字母，则将A-Z作为0—25,将a-z作为26-51(例如a-‘a’+26)，共52进制，转换为10进制。 若出现了数字，则可按照小写字母的处理方法增大进制数至62。 若能保证字符串末尾是数字则可将末尾的数字直接拼接上去。 ASCII码的hash值可用 字符-‘\\0’ 计算，因为’\\0’的ASCII码值为0。 3. 递归二、经典题目2.1 问题 B: 分组统计题目描述先输入一组数，然后输入其分组，按照分组统计出现次数并输出，参见样例。输入输入第一行表示样例数m，对于每个样例，第一行为数的个数n，接下来两行分别有n个数，第一行有n个数，第二行的n个数分别对应上一行每个数的分组，n不超过100。输出输出m行，格式参见样例，按从小到大排。样例输入173 2 3 8 8 2 31 2 3 2 1 3 1样例输出1={2=0,3=2,8=1}2={2=1,3=0,8=1}3={2=1,3=1,8=0}思路 利用一个二维矩阵A[i][j]记录数字j在组别i中出现的次数 flagS[j]和flagG[i]分别记录数字j和组别i是否出现，这里容易出错 找出最大组别编号和最大数字，若组号i和数字j均存在，则输出result[i][j] 易错点:组号i小于n，但样例数大小j范围未知，二维数组的第二维应初始化大一些，否则容易错误50%12345678910111213141516171819202122232425262728293031323334353637383940414243int main()&#123; int m,n; while(scanf(\"%d\",&amp;m)!=EOF)&#123; while(m--)&#123; scanf(\"%d\",&amp;n); //在循环内部定义数组就无须初始化为0了 int sample[110]=&#123;&#125;,flagS[2010]=&#123;&#125;,group[110]=&#123;&#125;,flagG[110]=&#123;&#125;; int maxs=0,maxg=0; //找出最大样例和最大组别，方便输出。 for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",sample+i); if(sample[i]&gt;maxs) maxs=sample[i]; flagS[sample[i]]=1; &#125; int result[110][2010]=&#123;&#125;; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",group+i); if(group[i]&gt;maxg) maxg=group[i]; flagG[group[i]]=1; //记录统计结果 result[group[i]][sample[i]]++; &#125; //输出统计结果 for(int i=0;i&lt;=maxg;i++)&#123; if(flagG[i]==1)&#123; printf(\"%d=&#123;\",i); for(int j=0;j&lt;=maxs;j++)&#123; if(flagS[j]==1)&#123; printf(\"%d=%d\",j,result[i][j]); if(j&lt;maxs) printf(\",\"); &#125; &#125; printf(\"&#125;\\n\"); &#125; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"}]},{"title":"Codeup和PAT刷题记录——入门模拟","date":"2020-04-24T08:45:22.000Z","path":"2020/04/24/算法笔记/入门模拟/","text":"记录刷题过程中遇到的问题和技巧。 一、技巧总结1. 简单模拟①将字符型数字转换为整型数字：例如&#39;8&#39;-&#39;0&#39;。②当 -109&lt;a,b&lt;109,或者-231&lt;a,b&lt;231，a+b仍为Int型,但当区间带等号时a,b,c都应当定义为long long型变量。 2. 图形输出③整数n/2避免使用round函数来进行四舍五入： 12if(n%2==0) n=n/2;else n=n/2+1; ②使用指定字符输出图形实质上是确定每一行输出的不同字符数与行数之间的数学计算关系。 3. 日期处理①日期处理问题往往需要使用数组存储与日期如平年和闰年的月份、月份和星期的英文字符串等 12345678910//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！month[m][0]存储平年每个月天数，month[m][1]存储闰年每个月天数 int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//存储月份英文名称和罗马数字的关系char monthToNum[13][20]=&#123;\" \",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\", \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;;//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ char numToWeek[8][20]=&#123;\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"&#125;; ②判断是否为闰年的函数写法 12//判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125; ③查找任意年y的某个月m的天数写法 1month[m][isLeapTear(y)]; ④提取int型变量中的任意几位：例如提取20130102中的YYYY、MM、DD。 1y1=date1/10000,m1=date1%10000/100,d1=date1%10000%100; ⑤计算任意两个日期间差值可分别计算它们与公元1年1月1日的差值然后再计算两个差值的差值。⑥计算某个日期的星期数可首先计算与公元1年1月1日天数差值，再对差值取余即为星期数的下标。 4. 进制转换①P进制数x转换为十进制数y，利用while循环 12345while(x!=0)&#123; y=y+(x%10)*product; x/=10; product*=P;&#125; ②十进制数y转换为Q进制数z[num-1,0],利用“除基取余法”和do while循环，防止y=0而没有输出 1234do&#123; z[num++]=y%Q; y/=Q;&#125;while(y!=0); ②注意当数组z为字符数组时，在末尾应手动添加’\\0’，否则容易出错。③当十进制整数超出整型可存储的范围时，用字符数组来存储处理比较方便，来模拟十进制整数的运算过程。 5. 字符串处理①边输入边处理被空格分隔的字符串有两种方式 12while((c=getchar())!='\\n')&#123;...&#125;while(scanf(\"%s\",s[num++])!=EOF); ②一定要注意scanf(“%c”)和gets(s)之间要用getchar()吸收换行符，否则很容易出错。③若题设条件未给出输入字符串格式，则应考虑带空格的输入。此时应用gets(s)进行输入。 二、经典题目1. 比较交换3个实数值，并按序输出题目描述从键盘输入3个实数a, b, c，通过比较交换，将最小值存储在变量a中，最大值存储在变量c中，中间值存储在变量b中，并按照从小到大的顺序输出这三个数a, b, c。末尾输出换行。输入输入以空格分隔的三个实数输出按照从小到大的顺序输出这三个实数，中间以空格分隔，最小值在前，最大值在后。小数点后保留2位小数。注意末尾的换行。样例输入3 7 1样例输出1.00 3.00 7.00 思路冒泡法。 12345678910111213#include&lt;stdio.h&gt;int main()&#123; double a,b,c,temp; scanf(\"%lf%lf%lf\",&amp;a,&amp;b,&amp;c); //冒泡法 if(a&gt;b)temp=a,a=b,b=temp; if(b&gt;c)temp=b,b=c,c=temp; if(a&gt;b)temp=a,a=b,b=temp; printf(\"%.2f %.2f %.2f\\n\",a,b,c); return 0;&#125; 2. 三个整数求最大值题目描述有3个整数a, b, c，由键盘输入，输出其中最大的数。输入以空格分割的三个整数。输出三个数中的最大值，末尾换行。样例输入1 3 2样例输出3思路比较 1234567891011#include&lt;stdio.h&gt;int main()&#123; int a,b,c,max; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); max=a&gt;b?a:b; max=max&gt;c?max:c; printf(\"%d\\n\",max); return 0;&#125; 3. 矩阵输出题目描述输出以下4*5的矩阵 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20要求使用循环实现，注意每行输出5个数字，每个数字占3个字符的宽度，右对齐。输入无输出每行输出5个数字，每个数字占3个字符的宽度，右对齐。样例输入无样例输出 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20思路 i保存每一行的输出值，a为每行的累加值， i=i+a; 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int i=1,a=1; while(a&lt;=4)&#123; printf(\"%3d\",i); //依次输出元素 if(i%5==0)&#123; printf(\"\\n\"),a++,i=a; continue; //若每行元素达到5个，则换行且重置a和i的值，并跳出本次循环。 &#125; i+=a; &#125; return 0;&#125; 4. 杨辉三角题目描述按要求输入如下格式的杨辉三角11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1最多输出10层输入输入只包含一个正整数n，表示将要输出的杨辉三角的层数。输出对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开样例输入5样例输出11 11 2 11 3 3 11 4 6 4 1思路i控制输出的行数，j控制每行元素个数，j&lt;=i,a[j]保存上一行的元素，b[j]根据a[j]计算本行的元素值并输出； ① 首先输出每行的第一个元素b[1]；② 然后控制j=2,j&lt;i,输出每行中间元素b[j]=a[j-1]+a[j]；③ 最后输出每行最后一个元素b[j]=a[j],并换行；④ 更新a[j]，回到步骤① 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,i,j,a[15]=&#123;0,1,1,1,1,1,1,1,1,1,1&#125;,b[15]; b[1]=a[1]; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++)&#123; printf(\"%d \",b[1]); //输出每一行第一个元素 for(j=2;j&lt;i;j++)&#123; //输出每行中间的元素 b[j]=a[j-1]+a[j]; printf(\"%d \",b[j]); &#125; if(j&gt;i)&#123; printf(\"\\n\"); continue; &#125; b[j]=a[j]; //输出每一行最后一个元素 printf(\"%d\\n\",b[j]); for(j=2;j&lt;i;j++) a[j]=b[j]; //更新a[j] &#125; return 0;&#125; 5. Shortest Distance (20)题目描述The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.输入Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.输出For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.样例输入5 1 2 4 14 931 32 54 1样例输出3107思路本题中的距离不能暴力求解，否则极易出现超时错误！ ①输入距离d的同时利用circle累加距离，并同时利用数组dist[i+1]=circle记录出口i到出口1的距离，输入结束后circle即为计算的周长。②计算任意出口a,b间的顺时针距离d1，利用d1=abs(dist[b]-dist[a])。③计算任意出口a,b间的逆时针距离d2，利用d2=circle-d1。④输出d1和d2中较小的那一个距离。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; //Codeup中的C++编译器不支持cmath中的abs函数int main()&#123; int N,M,a,b,d; //出口个数N、区间[a,b]的个数M，以及出口间距离d while(scanf(\"%d\",&amp;N)!=EOF)&#123; int circle=0,dist[100010]=&#123;0&#125;; //周长及各出口离起始出口的距离 for(int i=1;i&lt;=N;i++)&#123; scanf(\"%d\",&amp;d); circle+=d; //计算周长 dist[i+1]=circle; //计算各出口距离出口1的距离 &#125; scanf(\"%d\",&amp;M); while(M--)&#123; int d1,d2; //正向反向距离 scanf(\"%d%d\",&amp;a,&amp;b); d1=abs(dist[b]-dist[a]); //计算正向距离 d2=circle-d1; //反向距离=周长-正向距离 if(d1&gt;d2) printf(\"%d\\n\",d2); else printf(\"%d\\n\",d1); &#125; &#125; return 0;&#125; 6. 日期差值题目描述有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。 输入有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD 输出每组数据输出一行，即日期差值 样例输入2013010120130105样例输出5思路 ①首先求出每个日期到公元1年1月1日的天数days1和days2，则days2-days1+1即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125;//计算任意日期距离公元1年1月1日的天数 int daysFromFirstYear(int y,int m,int d)&#123; int days=0,i=1,j=1,k=1; //累加年 for(;i&lt;y;i++)&#123; if(isLeapYear(i)) days+=366; else days+=365; &#125; //累加月 for(;j&lt;m;j++)&#123; if(isLeapYear(i)) days+=month[j][1]; else days+=month[j][0]; &#125; //累加日 days+=(d-k+1); return days;&#125; int main()&#123; int y1,m1,d1,y2,m2,d2; int date1,date2; while(scanf(\"%d\\n%d\",&amp;date1,&amp;date2)!=EOF)&#123; if(date1&gt;date2)&#123; int temp=date1; date1=date2; date2=temp; &#125; y1=date1/10000,m1=date1%10000/100,d1=date1%10000%100; y2=date2/10000,m2=date2%10000/100,d2=date2%10000%100; int days1,days2; days1=daysFromFirstYear(y1,m1,d1); days2=daysFromFirstYear(y2,m2,d2); printf(\"%d\\n\",days2-days1+1); &#125; return 0;&#125; 7. Day of Week题目描述We now use the Gregorian style of dating in Russia. The leap years are years with number divisible by 4 but not divisible by 100, or divisible by 400.For example, years 2004, 2180 and 2400 are leap. Years 2004, 2181 and 2300 are not leap.Your task is to write a program which will compute the day of week corresponding to a given date in the nearest past or in the future using today’s agreement about dating. 输入There is one single line contains the day number d, month name M and year number y(1000≤y≤3000). The month name is the corresponding English name starting from the capital letter. 输出Output a single line with the English name of the day of week corresponding to the date, starting from the capital letter. All other letters must be in lower case. 样例输入21 December 20125 January 2013样例输出FridaySaturday思路 ①存储闰年平年天数int month[13][2]、英文月份char monthToNum[13][20]以及英文星期char numToWeek[8][20]，注意!格里高利纪元中公元1年1月1日为星期一;②计算给定日期距离1年1月1日天数days;③numToWeek[days%7]即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt; //存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;, &#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//存储月份英文名称和罗马数字的关系char monthToNum[13][20]=&#123;\" \",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\", \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"&#125;;//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ char numToWeek[8][20]=&#123;\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"&#125;; //判断是否为闰年 bool isLeapYear(int y) &#123; return (((y%4==0) &amp;&amp; (y%100!=0)) || (y%400==0)); &#125;//计算任意日期距离公元1年1月1日的天数 int daysFromFirstYear(int y,int m,int d)&#123; int days=0,i=1,j=1,k=1; //累加年 for(;i&lt;y;i++)&#123; if(isLeapYear(i)) days+=366; else days+=365; &#125; //累加月 for(;j&lt;m;j++)&#123; if(isLeapYear(i)) days+=month[j][1]; else days+=month[j][0]; &#125; //累加日 days+=(d-k+1); return days;&#125; int main()&#123; int d,m,y; char mon[20]; while(scanf(\"%d%s%d\",&amp;d,mon,&amp;y)!=EOF)&#123; //获取英文月份的罗马数字 for(int i=1;i&lt;=12;i++)&#123; if(strcmp(monthToNum[i],mon)==0)&#123; m=i; break; &#125; &#125; int days=daysFromFirstYear(y,m,d); printf(\"%s\\n\",numToWeek[days%7]); &#125; return 0;&#125; 8. 进制转换题目描述将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。 输入多组数据，每行为一个长度不超过30位的十进制非负整数。（注意是10进制数字的个数可能有30个，而非30bits的整数） 输出每行输出对应的二进制数。 样例输入9852111126样例输出11110110011101001110001100110思路 ①输入超过整型可存储范围，使用字符数组模拟除法过程和判断是否为0过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt; //模拟十进制除法，返回余数 char divideBy2(char number[],char result[])&#123; int num=0,sum=0; for(int i=0;i&lt;strlen(number);i++)&#123; int temp=number[i]-'0'; sum=sum*10+temp; result[num++]=sum/2+'0'; sum=sum%2; &#125; result[num]='\\0'; return sum+'0';&#125;//判断字符串转为十进制是否为0 bool isZero(char number[])&#123; int i; for(i=0;i&lt;strlen(number);i++)&#123; if(number[i]!='0') return false; &#125; if(i==strlen(number)) return true;&#125; //输入超过整型可存储范围，使用字符数组模拟除法过程 int main()&#123; char number[35]; char result[100]; char left[100]; //定义商和余数 while(scanf(\"%s\",number)!=EOF)&#123; int num=0; do&#123; left[num++]=divideBy2(number,result); strcpy(number,result); &#125;while(!isZero(number)); for(int i=num-1;i&gt;=0;i--) printf(\"%c\",left[i]); printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"}]},{"title":"算法复杂度和黑盒测试","date":"2020-04-23T15:29:52.000Z","path":"2020/04/23/算法笔记/算法复杂度和黑盒测试/","text":"引言了解算法复杂度很重要，我们在编写算法时常常要注意算法复杂度以避免出现程序运行超时的结果，此外，了解常用OJ的黑盒测试方法也有助于编写正确高效的算法。本篇简单介绍了三种算法复杂度和黑盒测试的代码写法，并简单罗列了OJ在判定时出现的一些结果，以便找到出错原因。 一、算法复杂度1. 时间复杂度时间复杂度是算法执行基本运算(如加减乘除)的次数所处的等级，是评判算法时间效率的有效标准，较高的时间复杂度会让评测系统返回“运行超时”，对一般的OJ系统来说，一秒能承受的运算次数大概是107至108。 讲时间复杂度是不带系数的，称为时间复杂度常数，例如基本运算次数为cn,cn2，则时间复杂度分别为O(n)，O(n2)。 高等级的幂次会覆盖低等级的幂次，因此O(3n2+n+2)=O(n2)。 当某些算法实现较为复杂时，其常数会比较大，这时即使时间复杂度相同其性能也会有较大差距。 不同级别时间复杂度比较：O(1)&lt;O(logn)&lt;O(n)&lt;O(n2)。 2. 空间复杂度空间复杂度和时间复杂度的写法相同，表示算法需要消耗的最大数据空间。一般来说空间都是足够使用的，只要不开好几个107以上的数组，故一般会使用以空间换时间的算法策略。 3. 编码复杂度编码复杂度是一个定性的概念，没有一个量化标准，就是指代码的冗长程度。如果使用了冗长的算法思想则编码复杂度就会很大。 二、黑盒测试OJ后台会准备若干组数据(一般是放在一个文件里)让程序运行，并将运行结果在字符串意义上进行比较，若完全相同，则称通过了本题的黑盒测试，否则返回不同判定结果，根据黑盒测试对每组数据单独测试还是一次性全部测试，分为单点和多点测试。 1. 单点测试PAT采取的是单点测试，它会对每组数据都给出相应的测评结果，并且每组数据都有得分值，题目总得分等于通过数据得分值之和。所以它仅要求编写的程序能一次运行一组数据，采用普通写法。 2. 多点测试大部分OJ如Codeup等都是采用多点测试，它要求编写的程序能够一次性运行所有的数据，并要求所有输出结果都必须完全正确才算通过测试，故需要用到循环结构。多点测试能够考验算法编写的严谨性。题目一般会有3种输入格式，需要采取不同的输入方式。 三种输入类型 123456789101112131415//循环输入直到文件末尾while(scanf(\"%d\",&amp;n)!=EOF)&#123; ...//scanf返回值为成功读入的参数个数，当读取文件到达末尾时才会读取失败，此时返回-1，C语言中用EOF(End Of File)代替-1。 //在运行框输入数据时并不会触发EOF，需要手动输入&lt;Ctrl+Z&gt;键，再按&lt;Enter&gt;键触发。&#125;while(scanf(\"%s\",str)!=EOF)&#123;...&#125;while(gets(str)!=NULL)&#123;...&#125;//输入直到满足某个条件时退出while(scanf(\"%d%d\",&amp;a,&amp;b), a||b)&#123; ...//当a和b中有一个不为零时就进行循环。注意！输入多少数据(&amp;a和&amp;b)，判零条件就有几个(a||b)，否则输入输出的格式会出错。&#125;//输入题目指定组数的数据while(T--)&#123;...&#125; 另外要注意！多点测试中每一次循环都要重置一下变量和数组(memset函数或fill函数)，否则在下一组数据来临之前变量和数组的状态就不是初始状态了。 三、OJ常见评测结果1. 答案正确(Accepted, AC)若为单点测试，则每通过一组数据就会返回一个Accepted,若是多点测试，那么只有当通过了所有数据时，才会返回Accepted。 2. 编译错误(Compile Error, CE)出现这种情况有可能是选错了语言。 3. 答案错误(Wrong Answer, WA)代码逻辑问题或输出的内容有误。 4. 运行超时(Time Limit Excees, TLE)一般来说，导致该结果是由于算法的时间复杂度导致的，也可能是某组数据使得代码某处死循环了。 5. 运行错误(Runtime Error, RE)段错误(非法访问内存，如数组越界、指针乱指)、浮点错误(例如除数为0、模数为0)、递归爆栈(一般由于递归层数过深)。 6. 内存超限(Memory Limit Exceeded, MLE)如果程序使用太多空间，例如数组太大可能会导致此结果。 7. 格式错误(Presentation Error, PE)多输出了空格或换行。 8. 输出超限(Output Limit Exceeded, OLE)输出了过量的内容，如大量调试信息或者特殊数据导致的死循环。","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"},{"name":"C","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"}]},{"title":"Java基本语法","date":"2020-04-20T04:05:33.000Z","path":"2020/04/20/Java基础知识/Java基本语法/","text":"一、Java应用程序的结构1. 程序的组成123456public class FirstSample&#123; public static void main(String[] args) &#123; //要运行java程序，必须有一个main方法，public和static的位置可以互换，但其它部分位置固定 System.out.println(\"We will not use 'Hello, World!\"'); &#125; &#125; java区分大小写； public关键字为访问修饰符，用于控制程序的其他部分对这段代码的访问级別； 关键字 class 表明 Java 程序中的全部内容都包含在类中； class 后面紧跟类名，名字必须以字母开头，后面可以跟字母和数字的任意组合，采用驼峰命名法，不能使用java保留字； 源代码的文件名必须与public类的名字相同，并用 .java 作为扩展名。源文件可以包含多个类定义，但最多只能包含一个public类定义。可以没有public类定义，此时文件名可随意。 成功编译后会得到一个包含这个类字节码的文件。Java 编译器将字节码文件自动地命名为 ClassName. class, 并与源文件存储在同一个目录下。 运行已编译的程序时，Java 虚拟机将从指定类中的 main 方法开始执行,故在类的源文件中必须包含一个 main方法。 在 Java SE 1.4 及以后的版本中强制 main方法是 public 的。 Java 中的 main 方法必须是静态static的。 在 Java 中，每个句子必须用分号结束。特别需要说明，回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。 2. 注释123456789//单行注释/*比较长的一段话，注意不能嵌套*//***多行注释，可自动生成文档。***/ 二、8种基本数据类型4种整型，2种浮点型，1种用于表示 Unicode 编码的字符单元的字符类型 char和 1 种用于表示真值的 boolean 类型。 1. 整型 int：109以内； long：1010——1018，数值有一个后缀L或l； 二进制从Java7开始，要加上前缀0b或0B；八进制加前缀0(容易混淆数值，不推荐)；十六进制加前缀0x或0X； 从Java7开始还可以为数字字面量加下划线让程序更易读，Java编译器会去除这些下划线。如1_000_000或0b1111_0100_0010_0200_0000。 Java中所有的数值类型所占据的字节数量与平台无关，而C和C++会随着平台改变而改变。 注意!Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。 2. 浮点型2.1 两种浮点类型 float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。 也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。 绝大部分应用程序都采用 double 类型。在很多情况下，float 类型的精度很难满足需求。 可以使用十六进制表示浮点数值。例如，0.125=2—3可以表示成 0xl.0p-3。在十六进制表示法中， 使用 p 表示指数， 而不是 e。 注意， 尾数采用十六进制，指数采用十进制。指数的基数是 2。 2.2 浮点型的计算 所有的浮点数值计算都遵循 IEEE 754 规范。 三个特殊浮点值表示溢出和出错情况： 正无穷大(常量 Double.POSITIVE_INFINITY或Flocat.POSITIVE_INFINITY) 负无穷大(Double.NEGATIVE_INFINITY或Float.NEGATIVE_INFINITY) NaN(非数值，Double.NaN或Float.NaN):注意！所有非数值都认为是不相同的。 12if (x = Double.NaN) // is never true 错误判断方法if (Double.isNaN(x)) // check whether x is \"not a number\" 正确判断方法 浮点数值采用二进制系统表示，故无法精确表示1/10，如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal类 3. Unicode编码与字符编码表设计 Unicode 编码的目的是将世界不同地区的不同编码标准如美国的 ASCII、 西欧语言中的ISO 8859-1 俄罗斯的 KOI-8、 中国的 GB 18030 和 BIG-5 等统一起来，起初Unicode是固定的16位，而经过一段时间的发展，Unicode 字符超过了 65 536 个，其主要原因是增加了大量的汉语、 日语和韩语中的表意文字。为了解决这个问题，设计了不同的变长编码方式，如UTF-8和UTF-16，要理解这两种编码方式，必须首先理解Unicode码点等含义。码点：是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中，码点采用 U+十六进制 书写,Unicode 的码点可以分成 17 个代码级别，从U+10000 到 U+10FFFF。基本的多语言级别：码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；辅助字符级别：其余的 16个级别的码点从 U+10000 到 U+10FFFF , 其中包括一些辅助字符。 3.1 UTF-16字符编码表UTF-16 编码采用不同长度(2字节和4字节)的编码表示所有 Unicode 码点。在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元; 而辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的 2048 字节内， 通常被称为替代区域，其中 U+D800 ~ U+DBFF 用于第一个代码单元，U+DC00 ~ U+DFFF 用于第二个代码单元，而这些替代区域Unicode规定不对应与任何字符。这样设计十分巧妙，我们可以从中迅速地知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。参见https://zh.wikipedia.org/wiki/UTF-16#从U+0000至U+D7FF以及从U+E000至U+FFFF的码位UTF-16编码算法： 码位减去 0x10000，得到的值的范围为20比特长的 0…0xFFFFF。 高位的10比特的值（值的范围为 0…0x3FF）被加上 0xD800 得到第一个码元或称作高位代理，值的范围是 0xD800…0xDBFF。由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理。 低位的10比特的值（值的范围也是 0…0x3FF）被加上 0xDC00 得到第二个码元或称作低位代理，现在值的范围是 0xDC00…0xDFFF。由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理。 UTF-16编码示例： 3.2 UTF-8字符编码表UTF-8编码也采用不同字节编码所有U你从的码点(1字节-6字节)参见https://zhuanlan.zhihu.com/p/72254734UTF-16编码规则表：UTF-16编码示例：汉字「吕」的 Unicode 编码是 U+5415，对应二进制为 0101010000010101，总共有 15 位。因为两字节最多表示 11 位，三字节最多表示 16 位，所以使用三字节编码。对应二进制拆成（从低位到高位）三部分，分别是 0101, 010000, 010101，再拼上编码前缀得到 11100101, 10010000, 10010101，对应十六进制为 0xe5, 0x90, 0x95，这就是汉字「吕」的 UTF-8 编码。 4. char类型 char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。 char 类型的字面量值要用单引号括起来。 char 类型的值可以用转义序列\\u和十六进制值表示，其范围从 \\u0000 到 \\uffff。 除了转义序列 \\u 之外， 还有一些用于表示特殊字符的转义序列： 所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\\02122’ 或 “Hello\\n”。转义序列 \\u还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以。 Unicode 转义序列会在解析代码之前得到处理。123456public static void main(String\\u005B\\ u00SD args); //\\u005B 和 \\u005D 是 [ 和 ] 的编码。\"\\u0022+\\u0022\"; //\"\"+\"\" 即空串// \\u00A0 is a newline //\\u00A0为换行符，故会产生一个语法错误// Look inside c:\\users //也会产生一个语法错误， 因为 \\u 后面并未跟着 4 个十六进制数。 5. boolean类型boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件。要注意！整型值和布尔值之间不能进行相互转换。 三、变量1. 变量的声明 变量名必须是一个以字母开头并由字母或数字构成的序列。 需要注意，与大多数程序设计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括 ‘A’ ~ ‘Z’、 ‘a’ ~ ‘z’、或在某种语言中表示字母的任何 Unicode 字符。 但 V 和 ‘©’这样的符号不能出现在变量名中，空格也不行。可以使用 Character 类的isJavaldentifierStart 和 isJavaldentifierPart 方法来检查哪些 Unicode 字符属于 Java 中的“ 字母”。 另外， 不能使用 Java 保留字作为变量名。 12345int i,j; //不提倡int a;int b; //提倡，可读性强Box box;Box aBox; 2. 变量的初始化12345int vacationDays; //声明一个变量之后，必须用赋值语句对变量进行显式初始化,否则不能使用vacationDays=12; //可以将变量的声明和初始化放在同一行中。//在 Java 中可以将声明放在代码中的任何地方,但应尽可能地靠近变量第一次使用的地方。int vacationDays = 12; //在 Java 中， 不区分变量的声明与定义。 3. 常量12345final double CM_PER_INCH = 2.54; //关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。//类常量的定义位于 main 方法的外部。public static final double CM_PER_INCH = 2.54; //使用关键字 static final 可设置一个类常量,可使其在一个类中的多个方法中使用 //如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量，ClassName.常量名。 const 是 Java 保留的关键字，但目前并没有使用。 四、运算符+ - * / %加、减、乘、除、取余数 需要注意， 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。 在默认情况下， 虚拟机设计者允许对中间计算结果采用扩展的精度。但是， 对于使用 strictfp 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。 如果将一个类标记为strictfp, 这个类中的所有方法都要使用严格的浮点计算。1public static strictfp void main(String[] args) 1. 数学函数与数学常量123456789101112131415161718192021222324252627282930313233343536import static java.lang.Math.*; //静态导入Math包后，就不需要使用 Math.方法名 来调用了//解决负整数取余数问题的方法,n%2=-1，若n为负整数floorMod(position+adjustment,12); //（对于负除数，floorMod 会得到负数结果，不过这种情况在实际中很少出现。//三角函数方法static double sin(double a ) ： 返回角的三角正弦static double cos(double a) ： 返回角的三角余弦static double tan(double a) ： 返回角的三角正切static double asin(double a) : 返回角的反正弦static double acos(double a) : 返回角的反余弦static double atan(double a) ： 返回角的反正切static double toRadians(double a) : 将角转换为弧度static doueble toDegrees(double a) : 将弧度转化为角//指数函数方法static double exp(double a) : 用于获取e的a次方；static double log(double a) : 即lna;static double log10(double a) : 即log10a;static double sqrt(double a ):用于取a的平方根；static double cbrt(double a) : 用于取a的立方根；static double pow(double a, double b) : 用于求a的b次方；//取整函数方法static double ceil(double a)：返回大于等于a的整数值，返回值类型为double；static double floor(double a) : 返回小于等于a的整数值，返回值类型为double；static double rint(double a) : 返回与a最接近的整数值，返回值类型为double；（如果两个同为整数且同样接近，选取偶数值的那个）static double random( ):返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。//四舍五入函数static long round(double a ): 其值等于Math.floor(a + 0.5)，返回值类型为long;static int round(float a ): 其值等于Math.floor(a + 0.5)，返回值类型为int;//求绝对值运算和最值运算，这里的类型就是double，float，int和long类型static 类型 abs(类型); 返回对应类型的绝对值static 类型 max(类型1,类型2); 返回对应类型的最大值static 类型 min(类型1,类型2); 返回对应类型的最小值 2. 数值类型之间的合法自动转换其中6个实心箭头，表示无信息丢失的转换；有 3 个虚箭头，表示可能有精度损失的转换。当进行二元操作时，会将两个操作数自动转换为同一种类型，再进行计算，转换规则为： 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 否则， 两个操作数都将被转换为 int 类型。 3. 强制类型转换cast当存在信息丢失的可能时，需要进行强制类型转换才可以，比如long—&gt;int,强制类型转换会进行截断。 12(目标类型)变量; //不要在 boolean 类型与任何数值类型之间进行强制类型转换， 这样可以防止发生错误。b?1:0; //极少情况下使用 4. 结合赋值运算符+= -= *= /= %= 12int x;x += 3.5; //等价 (int)(x+3.5) 运算符得到一个值， 其类型与左侧操作数的类型不同， 就会发生强制类型转换。 5. 自增与自减运算符12345int n=12;n++; //由于这些运算符会改变变量的值，所以它们的操作数不能是数值。n-- //不推荐使用++,容易产生bug。++n;--n; 6. 关系运算符和boolean运算符 关系运算符：== != &lt; &gt; &lt;= &gt;= boolean运算符:&amp;&amp; || ! ?: 7. 位运算符&amp; | ^(异或) ~ &lt;&lt;(左移) &gt;&gt;(右移) 利用 &amp; 并结合使用适当的 2 的幂， 可以把其他位掩掉， 而只保留其中的某一位。 &gt;&gt;&gt; 运算符会用 0 填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。 移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作数模 64 )。 C/C++中&gt;&gt;对于负数生成的结果可能会依赖于具体的实现。Java 则消除了这种不确定性。123(n &amp; (1 &lt;&lt; 3)) &gt;&gt; 3;1&lt;&lt;35; //等价8或者1&lt;&lt;3 8. 括号与运算符的优先级 9. 枚举类型用于变量的取值只在一个有限的集合内的情况。 12enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;; //定义枚举类型Size s = Size.MEDIUM; //声明变量，只能存储Size中给定的枚举值或null值，null 表示这个变量没有设置任何值。 五、字符串 Java 字符串就是 Unicode 字符序列。Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。每个用双引号括起来的字符串都是 String类的一个实例。String 类对象为不可变字符串，不能修改字符串中的任一字符，但是可以修改整个字符串变量，让它引用另外一个字符串。字符串存放在一个公共存储池(堆)中，字符串变量指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同的字符。即：编译器可以让字符串共享。Java 将自动地进行垃圾回收。 如果修改字符串变量后之前的字符串所占的一块内存不再使用了， 系统最终会将其回收。 1. String中的各种字符串操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849String greeting = \"Hello\";String expletive = \"Expletive\";//子串 substring方法String s = greeting.substring(0, 3); //\"Hel\"//拼接 +String message = expletive + greeting; //当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串（任何一个 Java 对象都可以转换成字符串）。nt age = 13;String rating = \"PC\" + age; //PG13System.out.println(\"The answer is \" + answer);//join方法：把多个字符串放在一起， 用一个定界符分隔String all = String.join(\" / \", \"S\", \"M\", \"L\", \"XL\"); //\"S / H / L / XL\"//修改字符串变量，达到修改字符的效果greeting = greeting.substring(0, 3) + \"p!\"; //共享享带来的高效率远远胜过于提取、 拼接字符串所带来的低效率。因为对字符串进行的操作往往只是比较。//检测字符串是否相等s.equals(t); \"Hello\".equals(greeting);\"Hello\".equalsIgnoreCase(\"hel1o\"); //判断是否相等而不区分大小写if (greeting.compareTo(\"Hel1o\") == 0)//检测字符串是否放置在同一个位置上greeting == \"Hello\"; //可能正确也可能错误，因为实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。int n = greeting.length(); //返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。int cpCount = greeting.codePointCount(0, greeting.length()); //得到实际的长度，即码点数量s.charAt(n); //返回位置 n 的代码单元int index = greeting.offsetByCodePoints(0, i); //得到第 i 个码点int cp = greeting.codePointAt(index); //遍历字符串的码点int[] codePoints = str.codePointsO.toArray();//把一个码点数组转换为一个字符串String str = new String(codePoints, 0, codePoints.length);//返回一个新字符串。 这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。String toLowerCase( )String toUpperCase( )//返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。String trim( )//返回一个新字符串。这个字符串用 newString 代替原始字符串中所有的 oldString。可以用 String 或 StringBuilder 对象作为 CharSequence 参数。String replace( CharSequence oldString,CharSequence newString) Java 中的 String类包含了 50 多个方法。详参https://docs.oracle.com/javase/8/docs/api/ 2. 空串与null串123456String e = \"\"; // 空串,它是长度为0的字符串，有自己的内容(空)String str=null; //这表示目前没有任何对象与该变量关联if (str == null) //检查一个字符串是否为 nullif (str != null &amp;&amp; str.length() != 0) //检查一个字符串既不是 null 也不为空串，注意！首先要检查 str 不为 null。因为如果在一个 mill 值上调用方法， 会出现错误。 3. 使用StringBuilder类构建字符串1234StringBuilder builder = new StringBuilder();builder.append(ch); // appends a single characterbui1der.append(str); // appends a stringString completedString = builder.toString(); StringBuffer是StringBuilder的前身，其效率稍有些低， 但允许采用多线程的方式执行添加或删除字符的操作。 如果所有字符串在一个单线程中编辑 （通常都是这样)，则应该用 StringBuilder 替代它。 六、输入输出1. 读取输入1234567891011121314151617181920212223242526import java.util.*; //当使用的类不是定义在基本java.lang 包中时，一定要使用import指示字将相应的包加载进来。//构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。Scanner in = new Scanner(System.in);//使用 Scanner 类的各种方法实现输入String name = in.nextLine(); //nextLine()可读入空白符String firstName = in.next(); //以空白符结束int age = in.nextlnt(); //读取一个整数double num = nextDouble(); //读取一个浮点数boolean hasNext( ) //检测输人中是否还有其他单词。//检测是否还有表示整数或浮点数的下一个字符序列。boolean hasNextInt()boolean hasNextDouble()//用Console类从控制台读取密码Console cons = System.console();String username = cons.readLine(\"User name: \")；char[] passwd = cons.readPassword(\"Password:\"); //为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素//显示字符串 prompt 并且读取用户输入，直到输入行结束。args 参数可以用来提供输人格式。有关这部分内容将在下一节中介绍。static char[] readPassword(String prompt, Object...args)static String readLine(String prompt, Object...args) 采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有能够读取一个单词或一个数值的方法。 2. 格式化输出123456double x = 10000.0 / 3.0;System.out.print(x);System.out.printf(\"%8.2f\", x); //Java SE5.0沿用了C中的printf方法用于对输出进行各种格式控制//使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出String message = String.format(\"Hello, %s. Next year, you'll be %d\", name , age); 还可以在printf中给出控制格式化输出的各种标志:printf方法中日期与时间的格式化选项，格式包括两个字母， 以 t 开始， 以表中的任意字母结束： 12345System.out.printf(\"%tc\", new Date()); //打印当前完整的日期和时间//使用格式化的参数索引System.out.printf(\"l$s %2$tB %2$te, %2$tY\", \"Due date:\", new DateQ); //%1$表示对第1个参数格式化， Due date: February 9, 2015System.out .printf(\"%s %tB %&lt;te, %&lt;tY\", \"Due date:\", new DateO); //&lt; 示前而格式说明中的参数将被再次使用 以上有关printf方法中日期与时间的格式化选项已过时，新代码应使用java.time 包中的方法。printf格式说明符的语法图：许多格式化规则是本地环境特有的。例如，在德国，组分隔符是句号而不是逗号，Monday 被格式化为 Montag,java可以控制控制应用的国际化行为。 3. 文件输入与输出1234567//若读取文件时不设置字符编码，则会使用运行该java程序的默认编码，若在不同的机器上运行可能会有不同的表现//可使用Scannner的任意方法对文件进行读取Scanner in = new Scanner(Paths.get(\"myfile.txt\"), \"UTF-8\"); //如果文件名中包含反斜杠符号，需要在每个反斜杠之前再加一个额外的反斜杠：“ c:\\\\mydirectory\\\\myfile.txt ”//写入文件//可以像输出到 System.out—样使用 print、 println 以及 printf命令。PrintWriter out = new PrintWriter(\"myfile.txt\", \"UTF-8\"); 如果用一个不存在的文件构造一个Scanner,或者用一个不能被创建的文件名构造一个PrintWriter,那么就会发生异常。Java 编译器认为这些异常比“被零除”异常更严重。 七、控制流程1. 块作用域 块，即复合语句，是由一对大括号括起来的若干条简单的 Java 语句。 一个块可以嵌套在另一个块中。 但是，不能在嵌套的两个块中声明同名的变量，否则无法通过编译。123456&#123; int n; &#123; int k; &#125;&#125; 2. 条件语句123456789101112131415if(condition)&#123;...&#125;if(condition)&#123; ...&#125;else&#123; ...&#125;if(condition1)&#123; ...&#125;else if(condition2)&#123; ...&#125;else if(condition3)&#123; ...&#125; 3. 循环12345678910111213while(condition)&#123; ...&#125;do&#123; ...&#125;while(condition);for (int i = 1; i &lt;= 10; i++)&#123; ...&#125;for (double x = 0; x != 10; x += 0 .1) //由于浮点数的舍入误差，该循环永远不可能结束 4. switch语句12345678910111213141516171819202122232425switch (choice) &#123; //case标签范围：类型为 char、byte、 short 或 int 的常量表达式。 case 1: //枚举常量。 ... //从 Java SE 7开始， case 标签还可以是字符串字面量。 break; case 2: ... break; case 3: ... break; case 4: ... break; default: ... break; &#125;Size sz = . . .;switch (sz) &#123; case SMALL: // 无需使用Size.SMALL ... break; ...&#125; 5. 中断控制流程语句12345678910111213141516171819202122232425262728//不带标签的break语句，用于跳出当前循环while(c)&#123; ... break;&#125;//带标签的break语句，用于跳出多重嵌套的循环语句,也可以应用到任何语句中。//标签必须放在希望跳出的最外层循环之前， 并且必须紧跟一个冒号。read_data:while(...)&#123; for(...)&#123; ... break read_data; &#125;&#125;label:&#123; ... if(condition) break label; ...&#125;//continue语句跳过本次循环剩余部分，进入下一次循环for(...)&#123; ... break;&#125; 八、大数值Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算，类提供的方法参见java文档https://docs.oracle.com/javase/8/docs/api/。 12345import java.math.*Biglnteger a = Biglnteger.valueOf(100); //将普通的数值转换为大数值Biglnteger c = a.add(b); // c = a + bBiglnteger d = c.multiply(b.add(Biglnteger.valueOf(2))); // d = c * (b + 2) 大数值不能使用 + 和 * 与 C++ 不同， Java 没有提供运算符重载功能。 程序员无法重定义 + 和 * 运算符，虽然为字符串的连接重栽了+ 运算符，但没有重载其他的运算符。 九、数组1. 数组的创建/初始化/匿名数组123456789int[] a = new int[100]; //也可用int a[];声明数组，但是不推荐，创建一个数字数组则所有元素会被初始化为0boolean[] b = new boolean[100]; //元素初始化为 falseString[] names = new String[10]; //对象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。a.length; //获取数组中元素个数int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13 &#125;; //创建数组的同时进行初始化small Primes = new int[] &#123; 17, 19, 23, 29, 31, 37 &#125;; //匿名数组初始化，可以在不创建新变量的情况下重新初始化一个数组new elementType[0]; //创建一个长度为 0 的数组,与null不同。 如果经常需要在运行过程中扩展数组的大小， 应该使用数组列表（array list)。 2. 数组的for each循环1234for (int element : a) System.out.println(element);System.out.println(Arrays.toString(a)); //以[2,3,5,7,11,13]方式打印数组 3. 数组拷贝1234567int[] luckyNumbers = smallPrimes; //将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组luckyNumbers[5] = 12; //如果数组元素是数值型，那么多余的元素将被赋值为 0 ; //如果数组元素是布尔型，则将赋值为 false。//相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length*2); //将一个数组的所有值拷贝到一个新的数组中去,第二个参数为新数组大小，该方法常用来增加数组大小 java中没有指针运算，不能通过 a+1 得到数组的下一个元素。[]被预定义为检查数组边界。 4. 命令行参数main函数中的String[] args表明main 方法将接收一个字符串数组， 也就是命令行参数。 12345678public class Message&#123; public static void main(String[] args) &#123; ... &#125;&#125;//在命令行输入命令可读入内容到args数组中,程序名并没有存储在 args 数组中java Message -g cruel world //args[0]:\"-g\" args[l]:\"cruel\" args[2]:\"cruel\" \"world\" 4. 数组排序123456789101112131415import java.util.Arrays;static String toString(type[] a) //类型为 int、long、short、 char、 byte、boolean、float 或 double 的数组。static type copyOf(type[]a, int length)static type copyOfRange(type[]a , int start, int end)static void sort(type[] a) //采用优化的快速排序算法对数组进行排序。static int binarySearch(type[]a , type v) //采用二分搜索算法查找值 vstatic int binarySearch(type[]a, int start, int end, type v) //类型为 int、 long、 short、 char、 byte、 boolean 、 float 或 double 的有序数组。static void fill(type[]a , type v) //将数组的所有数据元素值设置为 Vstatic boolean equals(type[]a, type[]b) //如果两个数组大小相同， 并且下标相同的元素都对应相等， 返回 true。 5. 多维数组12345678910111213141516//创建double[][] balances = new double[100][100];int[][] magicSquare = &#123; &#123;16, 3, 2, 13&#125;， &#123;5, 10, 11, 8&#125;, (9, 6, 7, 12&#125;, &#123;4, 15, 14, 1&#125; &#125;;//遍历for (double[] row : a) for (double value : row) .......//快速打印System.out.println(Arrays.deepToString(a)); //输出[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]//交换二维数组中的两行double[] temp = balances[i];balances[i] = balances[i + 1];balances[i + 1] = temp; 6. 不规则数组12345//首先分配一个具有所含行数的数组int[][] odds = new int[NMAX + 1][];//接下来，分配这些行for (int n = 0; n &lt;= NMAX ; n++) odds[n] = new int[n + 1];","tags":[{"name":"Java","slug":"Java","permalink":"https://sunnyyi.github.io/tags/Java/"}]},{"title":"C和C++的常用语法","date":"2020-04-15T09:45:33.000Z","path":"2020/04/15/算法笔记/C和C++常用语法/","text":"在算法机试中，最适合使用的就是C语言和C++语言，C++可以向下兼容C，且其基本语法除了输入输出部分，其余顺序结构、循环结构、数组、指针都是几乎一样的。C++中的cin和cout消耗时间比C中的scanf和printf多得多，而C中有一些不太顺手的设定可以使用C++来取代，故我们在机试时通常选择C++的编译器，而混用C和C++的语法来优化算法。本篇简单介绍一下机试中常用的C/C++基本语法。 一、C程序的组成1234567#include &lt;stdio.h&gt;int main()&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\",a+b); return 0;&#125; 1.头文件#include &lt;stdio.h&gt;即是头文件，用来添加程序中需要使用到的库函数，其中stdio.h是标准输入输出库，是一个.h格式的文件，其中包含了一些与输入输出有关的东西，其他功能的库文件还有math.h，负责数学函数,string.h负责字符串相关函数，等等。当我们需要用到这些库函数时就必须将其头文件include起来。此外，C++中的等价写法为#include &lt;csdio&gt;,#include &lt;cmath&gt;,include &lt;cstring&gt;。 2.主函数12345int main()&#123; ... return 0;&#125; 主函数是一个程序的入口，也就是程序开始执行的地方，一个程序最多只能有一个主函数。注意！请不要在同一个程序中使用cout和printf，有时会出问题。 二、基本数据类型1. 变量的定义变量类型 变量名;变量类型 变量名 = 初值;变量名区分大小写。 2. 变量类型 2.1 整型短整型(short): 2Byte，机试中一般用不到。整型(int): 4Byte,绝对值在109范围内整数都可以定义为Int型。长整型(long long): 8Byte,赋值大于231-1的初值，需要在初值后面加上LL，否则编译错误。 2.2 浮点型单精度(float): 有效精度6-7位。双精度(double): 有效精度15-16位,因此机试中碰到浮点型一般都是用double来存储。 浮点数在经过容易损失精度得计算后，计算结果总是不精确得，有一定得误差，故需要引入一个极小数eps来修正误差，从而进行各种比较操作，可以取eps为10-8,变量b的浮动范围为[b-eps,b+eps],各种比较操作的宏定义如下： a==b: a&gt;b: a&lt;b: a&gt;=b: a&lt;=b: 123456789101112131415#include &lt;stdio.h&gt;#include &lt;math.h&gt;double db1=4*asin(sqrt(2)/2); //PI的损失精度的计算double db2=3*asin(sqrt(3.0)/2);db1==db2; //flase;const double pi=acos(-1); //定义piconst double eps=1e-8; //注意该用括号的地方用括号#define Equ(a,b) ((fabs((a)-(b)))&lt;(eps)) //a==b,不等于可使用!Equ(a,b)#define More(a,b) (((a)-(b))&gt;(eps)) //a&gt;b#define Less(a,b) (((a)-(b))&lt;(-eps)) //a&lt;b#define MoreEqu(a,b) (((a)-(b))&gt;(-eps)) //a&gt;=b#define LessEqu(a,b) (((a)-(b))&lt;(eps)) //a&lt;=b 2.3 字符型字符常量和字符变量: 1char c1 = 'z', c2 = 'j', c3 = 117; 字符常量统一使用ASCII编码，小写字母比大写字母码值大32。0-9（48-57），A-Z（65-90），a-z（97-122）。转义字符: \\n（换行）、\\t（Tab）、\\0（代表空字符NULL，其ASCII码为0，请注意\\0不是空格） 字符串常量: 1char str[25]=\"wo ai de ren ye ai wo\"; C语言中无基本数据类型可存储字符串常量，只能用字符数组，而C++中有string类型。 2.4 布尔型1bool flag1=0, flag2=true; bool在C++中可直接使用，在C中必须添加stdbool.h,但机试选择C++编译器，故可不添加。用整型赋值时true(非零)，false(零)。bool可以%d格式输出0或1。 3. 强制类型转换1(新类型名)变量名; 其中(int)f直接将小数部分切掉，即向下取整。在赋值时，编译器可以自动进行转换，但在计算过程中需要手动强制类型转换。 4. 符号常量和const常量(宏定义、宏替换)#define 标识符 常量 : 1#define pi 3.14 const 数据类型 变量名 = 常量; : 推荐方式。 1const double pi = 3.14; #define 标识符 任何语句或片段 : 不推荐。 1# difine ADD(a,b) ((a)+(b)) 由于宏定义是直接将对应部分替换然后进行编译和运行，故能加括号的地方应添加括号，否则会出现逻辑错误。 5. 运算符7个常用算术运算符 : + - * / % ++ --+ - * /优先级与四则运算相同， %和/优先级相同，且当/和%的除数为0时会导致程序异常退出或得到错误”1.#INF00”。6个关系运算符 : &lt; &gt; &lt;= &gt;= == !=3个逻辑运算符 : &amp;&amp; || ！1个条件运算符(c中唯一的三目运算符) : A ? B : C6个位运算符 : &lt;&lt;(左移) &gt;&gt;(右移) &amp;(位与) |(位或) ^(位异或) ~(位取反)运算符的优先级和结合性参见https://zh.cppreference.com/w/c/language/operator_precedence程序中无穷大的数INF的设置： 1const int INF = (1 &lt;&lt; 30) - 1; 或者 1const int INF = 0x3fffffff; 二者等价。 三、顺序结构1. 赋值表达式给多个变量赋值，可使用连续等号。 12int n, m;n = m = 5; 复合赋值运算符+= -= *= /= %=可以加快编译速度，提高代码可读性，故在程序中经常用到。 2. 使用C语言中的scanf和printf输入/输出2.1 scanf(“格式控制”,变量地址)123scanf(\"%d:%d:%d\",&amp;hh,&amp;mm,&amp;ss); //输入hh:mm:ssscanf(\"%d,%lf%c\",&amp;a,&amp;b,&amp;c); //输入a,b,cscanf(\"%d%d\",&amp;a,&amp;b); //输入a b scanf函数的格式控制符如下图所示： 格式控制和我们在控制台输入的格式一致。 &amp;为取地址符，char数组名本来就是一个地址，故不需要&amp;。 除了控制符%c可以读入一个空白符(空格、换行、Tab)以外,scanf的其他格式符的输入均以空白符为结束判断标志。 scanf中可以用转义字符，不过一般用不到。 2.2 printf(“格式控制”, 变量名称)1printf(\"%d\",n); printf函数的格式控制符如下图所示： printf中不使用&amp;。 注意double类型变量scanf的格式符为%lf,printf的格式符为%f。 printf中可使用转义字符\\n、\\t等。 12printf(\"%%\"); //输出%printf(\"\\\\\"); //输出\\ 3种实用的输出格式: %md &emsp;使不足m位的int变量以M位右对齐输出，高位空格补齐；若变量本身超过m位则保持原样。%0md &nbsp;相比于%md高位补0。%.mf &nbsp;使浮点数保留m位小数输出，使用“四舍六入五成双”规则，而不是四舍五入。 C++中的输入与输出函数cin与cout 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt; //string#include &lt;iomanip&gt; //控制double型精度using namespace std;cin&gt;&gt;n&gt;&gt;db&gt;&gt;c&gt;&gt;str;cout&lt;&lt;n&lt;&lt;\" \"&lt;&lt;db&lt;&lt;\" \"&lt;&lt;str&lt;&lt;\"haha\"&lt;&lt;\"\\n\"&lt;endl; //\"\\n\"和endl都表示换行char str[100];cin.getline(str,100); //读入一行string str; //使用C++中的string容器输入一行getline(cin,str);cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;123.4567&lt;&lt;endl; //控制double型变量输出小数点后两位。 cin与cout在输入/输出大量数据的情况下表现得非常糟糕，有时题目中数据还没有输入完毕就已经超时，故还是推荐使用scanf与printf输入与输出。 3. 使用getchar和putchar输入/输出字符getchar用来输入单个字符，注意它能够读入空白符，它经常使用在某些scanf使用不便的场合。putchar用来输出单个字符。 4. 注释123456//单行注释/*多行注释...*/ 编译时会自动跳过注释部分，不执行。 5. typedef用于给复杂的数据类型起一个别名，用别名代替原来的写法，提高编码效率。 1typedef long long LL; 6. 常用math函数除了abs在C编译器中需要添加stdlib.h外，其它数学函数使用时需要添加头文件math.h和cmath。注意! 123456789101112131415161718192021double fabs(double x); // double型变量取绝对值int abs(int x); //int型变量取绝对值double floor(double x); //向下取整double ceil(double x); //向上取整double pow(double x, double p); //返回x的p次方double sqrt(double x); //返回根号xdouble log(double x); //返回以自然对数e为底数的logx,c语言中没有对任意底数求对数的函数，只能使用此公式和换底公式来实现。double sin(double x); //三角函数,x必须为弧度制，如pi/2double cos(double x);double tan(double x);const double pi = acos(-1.0); double asin(double x); //反三角函数double acos(double x);double atan(double x);double round(double x); //对x四舍五入到整数位，以%d格式printf时需取整(int)double round(double x)&#123;return (x&gt;0.0) ? floor(x+0.5) : ceil(x-0.5);&#125; //有些编译器如PAT不支持round函数，可利用floor和ceil写一个。 四、选择结构1. if语句用于分支条件较少的情况。 123456789101112131415161718192021222324252627if(A)&#123; ...&#125;if(A)&#123; ...&#125;else&#123; ...&#125;if(A)&#123; ...&#125;else if(B)&#123; ...&#125;else&#123; ...&#125;if(A)&#123; //if语句嵌套 ... if(B)&#123; ... &#125; ...&#125;else&#123; ...&#125; 2. switch语句用于分支条件较多的情况。 12345678910111213switch(表达式)&#123; case 常量表达式1: ... break; case 常量表达式2; ... break; case 常量表达式n; ... break; default: ...&#125; 删除break则会从第一个匹配的case开始执行之后的所有语句。 五、循环结构1. while语句1234567while(A)&#123; //推荐 ...&#125;do&#123; ...&#125;while(A); //不推荐 2. for语句123for(A;B;C)&#123; //注意！C中A位置不允许定义变量而C++可以。 ...&#125; 3. break和continue语句break：跳出循环体。continue：跳出当前循环，即continue后面的代码不执行，直接进入下一轮循环。 六、数组如果数组大小较大（大概106级别），则需要将其定义在主函数外面，否则会使程序异常退出，因为函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的全局变量来自静态存储区，允许申请的空间较大。数组的长度计算： 1int length = sizeof(arr) / sizeof(arr[0]); //数组占内存总空间，除以单个元素占内存空间大小 1. 一维数组1数据类型 数组名[数组大小]; //数组大小必须是整数常量，不可以是变量。 初始化： 123int a[10]=&#123;1,2&#125;; //后面未被初始化的元素将根据编译器内部实现的不同而被赋以不同的初值（可能是很大的随机数），但一般默认为0。int a[10]=&#123;0&#125;;int a[10]=&#123;&#125;; 2. 二维数组1数据类型 数组名[第一维大小][第二维大小]; 初始化： 1int a[5][6]=&#123;&#123;1,2,3&#125;,&#123;&#125;,&#123;8,4&#125;&#125;; 3. 字符数组 初始化：12char str[15] = &#123;'G','o','o','d',' ','s','t','o','r','y','!'&#125;;char str[15] = \"Good story!\"; //直接赋值字符串，注意！仅限于初始化，程序其他位置不允许这样直接赋值整个字符串。 注意！定义了数组或字符指针之后，需要做一个初始化，否则里面将是随机值，以后将无法判断改字符串是否为空。123memset(数组名,‘\\0’,sizeof(数组名)); if (strlen(str) == 0) //推荐判空方式 if (str[0] == '\\0') /避免使用，容易crash 输入输出：12345678910char str[10];scanf(\"%c\",&amp;str[0]); //%c能读入空白符（空格，TAB，换行），%s以空白符为结束符。scanf(\"%s\",str);printf(\"%s\",str);str[0]=getchar(); //getchar()可以读入空白符。注意！在scanf(\"%s\\n\")和gets(str)之间应先使用getchar()吸收掉\\n，否则不能读取str,因为gets(str)以\\n为结束符。putchar(str[0]);gets(str); //gets()以换行符\\n为结束符，可以读入空格。PAT OJ中不支持gets()函数。puts(str); //输出一个字符串并紧跟换行 3. 字符数组的存放方式：每一个一维数组的末尾都有一个空字符\\0，占一位，表示存放的字符串的结尾，puts和printf就是通过识别\\0来输出字符串的。故在定义字符数组时长度一定要比实际存储字符串的长度至少多1。\\0在使用gets和scanf(“%s”)时会自动添加，其他的输入如getchar()则需要在字符串末尾手动添加\\0，否则puts和printf将由于无法识别字符串末尾而输出一大堆乱码。 4. memset——对数组中每一个元素赋相同的值12#include&lt;string.h&gt;memset(数组名，值，sizeof(数组名)); //速度快，但它是按字节赋值，即对每一个字节赋同样的值，故常用它赋0或-1不容易出错。 5. string.h头文件包含了很多关于字符数组的函数。 123456#include&lt;string.h&gt;int strlen(str); //返回字符数组中第一个\\0之前的字符的个数。int strcmp(str1,dtr2); //按字典序返回两个字符串大小的比较结果: 大于0的数(str1 &gt; str2)、返回0(str1 == str2)、小于0的数(str1 &lt; str2),返回值根据不同编译器处理而有不同的返回值，通常为1、0、-1。void strcpy(str1,str2); //将str2复制给str1，包括\\0。void strcat(str1,str2); //将str2拼接到str1的后面。 6. sscanf与sprintf处理字符串格式输入输出问题的利器。 1234567#include&lt;stdio.h&gt;sscanf(str, \"%d\", &amp;n); //将str中的内容以%d格式写入n中，从左至右。sprintf(str, \"%d\", n); //将n以%d格式写入字符数组str中，从右至左。sscanf(str, \"%d:%f,%s\",&amp;n1,&amp;n2,&amp;n3);sprintf(str, \"%d:%.2f,%s\",n1,n2,n3); sscanf还支持正则表达式，可解决字符串中的复杂问题。 七、函数1. 函数定义12345返回类型 函数名称(参数类型 参数)&#123; 函数主题&#125;void func(int c); //值传递,传入的是实参的一个副本，故不能改变实参的值 2. 以数组作为函数参数123void func(int a[], int b[][5]); //第一维度可不写长度，第二维度需要写明长度，可以再函数内部修改实参数组中的元素的值。func(a,b); //调用时只需要写数组名。 注意！数组可以作为函数的参数却不允许作为函数返回值，若想返回数组只有将返回的数组作为参数传入。函数可以嵌套调用，也可以递归调用。 八、指针C语言中用指针来表示内存地址，它是一个unsigned类型的整数，若这个内存地址恰好是某个变量的地址，则称这个指针指向该变量，变量的地址一般指它占用的字节中第一个字节的地址。在变量前加上取地址运算符&amp;即可得到变量的地址。 1. 指针变量指针变量用来存放指针。 1234567891011121314//定义和初始化int a,b;int* p=&amp;a; //C++写法，地址是赋值给p而不是*p的，*是类型的一部分。int *p1=&amp;b,p2; //C写法int *q1,*q2,*q3; //基类型(int)必须和指针变量存储的地址类型相同。char* str=\"I love china!\";*(str+1); //获得str+1位置的字符printf(\"%s\",a+n); //输出包括a+n位置及后面所有字符的字符串。//操作*p; //获得变量a的值，对*p的操作等同于对a操作。 p+1; //p所指的int型变量的下一个int型变量地址，跨越了一整个Int型(4Byte)。p++,p--;p1-p2; //2个指针之间相差的Int型变量的个数。 注意！若指针不进行初始化则指向的地址是随机的，而且很可能随机指向系统工作区，那么就会出错。 2. 使用指针变量作为函数参数使用指针变量作为函数参数时，在函数内部对指针变量(形参)本身进行修改并不能使传入的指针变量(实参)改变，因为传入的指针变量相当于传入一个副本，能够使实参改变的只能是该函数中对指针指向的数据进行的修改。 123456void swap(int* m, int* n)&#123; int temp=*m; *m=*n; *n=temp;&#125;swap(p,p1); 3. 引用引用(&amp;，区分取地址符)可以不使用指针，也能达到修改传入参数的目的，且引用不产生副本，而是给原变量(而不是常量，常量不可使用引用)起了个别名，故旧名字与新名字指向同一个东西，对引用变量的操作就是对原变量的操作。 12void func(int &amp;x);func(p2); 指针的引用：通过将指针的引用作为形参，从而达到将传入的地址交换以交换两个变量的结果。 1234567void swap(int* &amp;m, int* &amp;n)&#123; int* temp=m; m=n; n=temp;&#125;swap(p,p1); //swap(&amp;p,&amp;p1)写法错误，因为&amp;p,&amp;p1为常量，而常量不可使用引用。 九、结构体(struct)的使用需要将一些相关的变量放在一起存储时，需要用到结构体。 123struct Name &#123; //一些基本的数据结构或自定义的数据类型。&#125;结构体变量名; 1. 结构体的定义123456789struct StudentInfo &#123; int id; char gender; char name[20]; char major[20]; StudentInfo* next; //结构体内不能定义自己，会引起循环定义问题，但可以定义自身类型的指针变量，它可以定义除自身外的任何数据类型。注意！结构体指针变量不能在匿名结构体内定义。&#125;Alice,stu[1000]; //直接定义结构体变量StudentInfo Bob,*p; 2. 访问结构体内的元素12345678910stu[0].id;stu[0].gender;(*p).id;(*p).name;(*p).next;p-&gt;id;p-&gt;name;p-&gt;next; 3. 结构体的初始化和赋值结构体使用构造函数来进行初始化，对于一个普通定义的结构体，其内部会生成一个默认构造函数(但不可见)，如studentInfo(){}，正是由于默认构造函数的存在才可以直接定义结构体变量而不进行初始化，因为它没有让用户提供任何初始化参数。 1234567891011121314struct StudentInfo&#123; int id; char gender; StudentInfo(int _id, char _gender)&#123; //自定义构造函数 id=_id; gender=_gender; &#125; StudentInfo(int _id, char _gender): id(_id), gender(_gender) &#123;&#125; //构造函数的简化写法&#125;stu[3]=&#123;1,'M',2,'F'&#125;;StudentInfo stu = StudentInfo(10086,'M'); //初始化结构体stu[2]=stu; //C++中相同类型结构体之间可以直接赋值，而C语言中不可以。 注意！若自定义了构造函数而不想进行初始化，则需要手动添加默认构造函数。只要参数和类型不完全相同，就可以定义任意多个构造函数，以适应不同的初始化场合。 4. 共用体共用体可定义在结构体内部，用于建立有不同类型数据组成的组合型的数据结构。原则上，共用体的大小取决于占据最多内存的成员的长度，但会受到最宽基本类型成员大小的影响。即:共用体的总大小为共用体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。 12345678union MyUnion&#123; int i; char chs[11];&#125;u = &#123; 10 &#125;, u2 = &#123;.chs=\"niko\"&#125;; // 初始化;union MyUnion mu = &#123; 1 &#125;; // 默认初始化第一个成员union MyUnion mu2 = &#123; .chs = \"hello\" &#125;; // 指定要初始化的成员","tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://sunnyyi.github.io/tags/algorithms/"},{"name":"C","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://sunnyyi.github.io/tags/C/"}]},{"title":"SpringMVC","date":"2019-02-20T04:05:33.000Z","path":"2019/02/20/Spring实战/SpringMVC/","text":"","tags":[{"name":"java","slug":"java","permalink":"https://sunnyyi.github.io/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://sunnyyi.github.io/tags/Spring/"}]}]