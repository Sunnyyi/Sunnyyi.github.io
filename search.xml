<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringMVC</title>
    <url>/2019/02/20/Spring%E5%AE%9E%E6%88%98/SpringMVC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeup和PAT刷题记录——入门模拟</title>
    <url>/2020/04/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>记录刷题过程中遇到的问题和技巧。</p>
<h1 id="一、技巧总结"><a href="#一、技巧总结" class="headerlink" title="一、技巧总结"></a>一、技巧总结</h1><h2 id="1-简单模拟"><a href="#1-简单模拟" class="headerlink" title="1. 简单模拟"></a>1. 简单模拟</h2><p>①将字符型数字转换为整型数字：例如<code>&#39;8&#39;-&#39;0&#39;</code>。<br>②当 -10<sup>9</sup>&lt;a,b&lt;10<sup>9</sup>,或者-2<sup>31</sup>&lt;a,b&lt;2<sup>31</sup>，a+b仍为Int型,但当区间带等号时a,b,c都应当定义为long long型变量。</p>
<h2 id="2-图形输出"><a href="#2-图形输出" class="headerlink" title="2. 图形输出"></a>2. 图形输出</h2><p>③整数n/2避免使用round函数来进行四舍五入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) n=n/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> n=n/<span class="number">2</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>②使用指定字符输出图形实质上是确定每一行输出的不同字符数与行数之间的数学计算关系。</p>
<h2 id="3-日期处理"><a href="#3-日期处理" class="headerlink" title="3. 日期处理"></a>3. 日期处理</h2><p>①日期处理问题往往需要使用数组存储与日期如平年和闰年的月份、月份和星期的英文字符串等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！month[m][0]存储平年每个月天数，month[m][1]存储闰年每个月天数 </span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储月份英文名称和罗马数字的关系</span></span><br><span class="line"><span class="keyword">char</span>  monthToNum[<span class="number">13</span>][<span class="number">20</span>]=&#123;<span class="string">" "</span>,<span class="string">"January"</span>,<span class="string">"February"</span>,<span class="string">"March"</span>,<span class="string">"April"</span>,<span class="string">"May"</span>,<span class="string">"June"</span>,</span><br><span class="line">			<span class="string">"July"</span>,<span class="string">"August"</span>,<span class="string">"September"</span>,<span class="string">"October"</span>,<span class="string">"November"</span>,<span class="string">"December"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ </span></span><br><span class="line"><span class="keyword">char</span> numToWeek[<span class="number">8</span>][<span class="number">20</span>]=&#123;<span class="string">"Sunday"</span>,<span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>,<span class="string">"Wednesday"</span>,<span class="string">"Thursday"</span>,<span class="string">"Friday"</span>,<span class="string">"Saturday"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>②判断是否为闰年的函数写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为闰年 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (((y%<span class="number">4</span>==<span class="number">0</span>) &amp;&amp; (y%<span class="number">100</span>!=<span class="number">0</span>)) || (y%<span class="number">400</span>==<span class="number">0</span>)); &#125;</span><br></pre></td></tr></table></figure>
<p>③查找任意年y的某个月m的天数写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">month[m][isLeapTear(y)];</span><br></pre></td></tr></table></figure>
<p>④提取int型变量中的任意几位：例如提取20130102中的YYYY、MM、DD。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y1=date1/<span class="number">10000</span>,m1=date1%<span class="number">10000</span>/<span class="number">100</span>,d1=date1%<span class="number">10000</span>%<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>⑤计算任意两个日期间差值可分别计算它们与公元1年1月1日的差值然后再计算两个差值的差值。<br>⑥计算某个日期的星期数可首先计算与公元1年1月1日天数差值，再对差值取余即为星期数的下标。</p>
<h2 id="4-进制转换"><a href="#4-进制转换" class="headerlink" title="4. 进制转换"></a>4. 进制转换</h2><p>①P进制数x转换为十进制数y，利用while循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">	y=y+(x%<span class="number">10</span>)*product;</span><br><span class="line">	x/=<span class="number">10</span>;</span><br><span class="line">	product*=P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②十进制数y转换为Q进制数z[num-1,0],利用“除基取余法”和do while循环，防止y=0而没有输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	z[num++]=y%Q;</span><br><span class="line">	y/=Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>②注意当数组z为字符数组时，在末尾应手动添加’\0’，否则容易出错。<br>③当十进制整数超出整型可存储的范围时，用字符数组来存储处理比较方便，来模拟十进制整数的运算过程。</p>
<h2 id="5-字符串处理"><a href="#5-字符串处理" class="headerlink" title="5. 字符串处理"></a>5. 字符串处理</h2><p>①边输入边处理被空格分隔的字符串有两种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span>)&#123;...&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[num++])!=EOF);</span><br></pre></td></tr></table></figure>
<p>②一定要注意scanf(“%c”)和gets(s)之间要用getchar()吸收换行符，否则很容易出错。<br>③若题设条件未给出输入字符串格式，则应考虑带空格的输入。此时应用gets(s)进行输入。</p>
<h1 id="二、经典题目"><a href="#二、经典题目" class="headerlink" title="二、经典题目"></a>二、经典题目</h1><h2 id="1-比较交换3个实数值，并按序输出"><a href="#1-比较交换3个实数值，并按序输出" class="headerlink" title="1. 比较交换3个实数值，并按序输出"></a>1. 比较交换3个实数值，并按序输出</h2><p><strong>题目描述</strong><br>从键盘输入3个实数a, b, c，通过比较交换，将最小值存储在变量a中，最大值存储在变量c中，中间值存储在变量b中，并按照从小到大的顺序输出这三个数a, b, c。<br>末尾输出换行。<br><strong>输入</strong><br>输入以空格分隔的三个实数<br><strong>输出</strong><br>按照从小到大的顺序输出这三个实数，中间以空格分隔，最小值在前，最大值在后。小数点后保留2位小数。<br>注意末尾的换行。<br><strong>样例输入</strong><br>3 7 1<br><strong>样例输出</strong><br>1.00 3.00 7.00</p>
<p><strong>思路</strong><br>冒泡法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> a,b,c,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="comment">//冒泡法 </span></span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)temp=a,a=b,b=temp;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)temp=b,b=c,c=temp;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)temp=a,a=b,b=temp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2f %.2f %.2f\n"</span>,a,b,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-三个整数求最大值"><a href="#2-三个整数求最大值" class="headerlink" title="2. 三个整数求最大值"></a>2. 三个整数求最大值</h2><p><strong>题目描述</strong><br>有3个整数a, b, c，由键盘输入，输出其中最大的数。<br><strong>输入</strong><br>以空格分割的三个整数。<br><strong>输出</strong><br>三个数中的最大值，末尾换行。<br><strong>样例输入</strong><br>1 3 2<br><strong>样例输出</strong><br>3<br><strong>思路</strong><br>比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a,b,c,<span class="built_in">max</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="built_in">max</span>=a&gt;b?a:b;</span><br><span class="line">	<span class="built_in">max</span>=<span class="built_in">max</span>&gt;c?<span class="built_in">max</span>:c;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">max</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-矩阵输出"><a href="#3-矩阵输出" class="headerlink" title="3. 矩阵输出"></a>3. 矩阵输出</h2><p><strong>题目描述</strong><br>输出以下4*5的矩阵</p>
<p>  1  2  3  4  5</p>
<p>  2  4  6  8 10</p>
<p>  3  6  9 12 15</p>
<p>  4  8 12 16 20<br>要求使用循环实现，注意每行输出5个数字，每个数字占3个字符的宽度，右对齐。<br><strong>输入</strong><br>无<br><strong>输出</strong><br>每行输出5个数字，每个数字占3个字符的宽度，右对齐。<br><strong>样例输入</strong><br>无<br><strong>样例输出</strong><br>  1  2  3  4  5<br>  2  4  6  8 10<br>  3  6  9 12 15<br>  4  8 12 16 20<br><strong>思路</strong></p>
<blockquote>
<p>i保存每一行的输出值，a为每行的累加值， i=i+a;</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>,a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(a&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%3d"</span>,i);  <span class="comment">//依次输出元素 </span></span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>),a++,i=a;</span><br><span class="line">			<span class="keyword">continue</span>;  <span class="comment">//若每行元素达到5个，则换行且重置a和i的值，并跳出本次循环。</span></span><br><span class="line">		&#125;</span><br><span class="line">		i+=a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-杨辉三角"><a href="#4-杨辉三角" class="headerlink" title="4. 杨辉三角"></a>4. 杨辉三角</h2><p><strong>题目描述</strong><br>按要求输入如下格式的杨辉三角<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1<br>最多输出10层<br><strong>输入</strong><br>输入只包含一个正整数n，表示将要输出的杨辉三角的层数。<br><strong>输出</strong><br>对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开<br><strong>样例输入</strong><br>5<br><strong>样例输出</strong><br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br><strong>思路</strong><br>i控制输出的行数，j控制每行元素个数，j&lt;=i,a[j]保存上一行的元素，b[j]根据a[j]计算本行的元素值并输出；</p>
<blockquote>
<p>① 首先输出每行的第一个元素b[1]；<br>② 然后控制j=2,j&lt;i,输出每行中间元素b[j]=a[j-1]+a[j]；<br>③ 最后输出每行最后一个元素b[j]=a[j],并换行；<br>④ 更新a[j]，回到步骤①</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n,i,j,a[<span class="number">15</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,b[<span class="number">15</span>];</span><br><span class="line">	b[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	 </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,b[<span class="number">1</span>]);  <span class="comment">//输出每一行第一个元素 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;j++)&#123;          <span class="comment">//输出每行中间的元素 </span></span><br><span class="line">			b[j]=a[j<span class="number">-1</span>]+a[j];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,b[j]);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j&gt;i)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		b[j]=a[j];    <span class="comment">//输出每一行最后一个元素 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[j]);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;j++) a[j]=b[j];  <span class="comment">//更新a[j]	</span></span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Shortest-Distance-20"><a href="#5-Shortest-Distance-20" class="headerlink" title="5. Shortest Distance (20)"></a>5. Shortest Distance (20)</h2><p><strong>题目描述</strong><br>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.<br><strong>输入</strong><br>Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.<br><strong>输出</strong><br>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.<br><strong>样例输入</strong><br>5 1 2 4 14 9<br>3<br>1 3<br>2 5<br>4 1<br><strong>样例输出</strong><br>3<br>10<br>7<br><strong>思路</strong><br>本题中的距离不能暴力求解，否则极易出现超时错误！</p>
<blockquote>
<p>①输入距离d的同时利用circle累加距离，并同时利用数组dist[i+1]=circle记录出口i到出口1的距离，输入结束后circle即为计算的周长。<br>②计算任意出口a,b间的顺时针距离d1，利用d1=abs(dist[b]-dist[a])。<br>③计算任意出口a,b间的逆时针距离d2，利用d2=circle-d1。<br>④输出d1和d2中较小的那一个距离。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; //Codeup中的C++编译器不支持cmath中的abs函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> N,M,a,b,d;   <span class="comment">//出口个数N、区间[a,b]的个数M，以及出口间距离d</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">circle</span>=<span class="number">0</span>,dist[<span class="number">100010</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//周长及各出口离起始出口的距离 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d);</span><br><span class="line">			<span class="built_in">circle</span>+=d;  <span class="comment">//计算周长</span></span><br><span class="line">			dist[i+<span class="number">1</span>]=<span class="built_in">circle</span>;   <span class="comment">//计算各出口距离出口1的距离 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;M);</span><br><span class="line">		<span class="keyword">while</span>(M--)&#123;</span><br><span class="line">			<span class="keyword">int</span> d1,d2;  <span class="comment">//正向反向距离 </span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			d1=<span class="built_in">abs</span>(dist[b]-dist[a]);   <span class="comment">//计算正向距离 </span></span><br><span class="line">			d2=<span class="built_in">circle</span>-d1;     <span class="comment">//反向距离=周长-正向距离 </span></span><br><span class="line">			<span class="keyword">if</span>(d1&gt;d2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d2);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-日期差值"><a href="#6-日期差值" class="headerlink" title="6. 日期差值"></a>6. 日期差值</h2><p><strong>题目描述</strong><br>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。</p>
<p><strong>输入</strong><br>有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD</p>
<p><strong>输出</strong><br>每组数据输出一行，即日期差值</p>
<p><strong>样例输入</strong><br>20130101<br>20130105<br><strong>样例输出</strong><br>5<br><strong>思路</strong></p>
<blockquote>
<p>①首先求出每个日期到公元1年1月1日的天数days1和days2，则days2-days1+1即为所求。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ </span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为闰年 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (((y%<span class="number">4</span>==<span class="number">0</span>) &amp;&amp; (y%<span class="number">100</span>!=<span class="number">0</span>)) || (y%<span class="number">400</span>==<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算任意日期距离公元1年1月1日的天数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysFromFirstYear</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> days=<span class="number">0</span>,i=<span class="number">1</span>,j=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//累加年 </span></span><br><span class="line">	<span class="keyword">for</span>(;i&lt;y;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=<span class="number">366</span>;</span><br><span class="line">		<span class="keyword">else</span> days+=<span class="number">365</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加月 </span></span><br><span class="line">	<span class="keyword">for</span>(;j&lt;m;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=month[j][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> days+=month[j][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加日</span></span><br><span class="line">	days+=(d-k+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> days;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> y1,m1,d1,y2,m2,d2;</span><br><span class="line">	<span class="keyword">int</span> date1,date2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d\n%d"</span>,&amp;date1,&amp;date2)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">if</span>(date1&gt;date2)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=date1;</span><br><span class="line">			date1=date2;</span><br><span class="line">			date2=temp;</span><br><span class="line">		&#125;</span><br><span class="line">		y1=date1/<span class="number">10000</span>,m1=date1%<span class="number">10000</span>/<span class="number">100</span>,d1=date1%<span class="number">10000</span>%<span class="number">100</span>;</span><br><span class="line">		y2=date2/<span class="number">10000</span>,m2=date2%<span class="number">10000</span>/<span class="number">100</span>,d2=date2%<span class="number">10000</span>%<span class="number">100</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> days1,days2;</span><br><span class="line">		days1=daysFromFirstYear(y1,m1,d1);</span><br><span class="line">		days2=daysFromFirstYear(y2,m2,d2);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,days2-days1+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Day-of-Week"><a href="#7-Day-of-Week" class="headerlink" title="7. Day of Week"></a>7. Day of Week</h2><p><strong>题目描述</strong><br>We now use the Gregorian style of dating in Russia. The leap years are years with number divisible by 4 but not divisible by 100, or divisible by 400.<br>For example, years 2004, 2180 and 2400 are leap. Years 2004, 2181 and 2300 are not leap.<br>Your task is to write a program which will compute the day of week corresponding to a given date in the nearest past or in the future using today’s agreement about dating.</p>
<p><strong>输入</strong><br>There is one single line contains the day number d, month name M and year number y(1000≤y≤3000). The month name is the corresponding English name starting from the capital letter.</p>
<p><strong>输出</strong><br>Output a single line with the English name of the day of week corresponding to the date, starting from the capital letter. All other letters must be in lower case.</p>
<p><strong>样例输入</strong><br>21 December 2012<br>5 January 2013<br><strong>样例输出</strong><br>Friday<br>Saturday<br><strong>思路</strong></p>
<blockquote>
<p>①存储闰年平年天数int month[13][2]、英文月份char monthToNum[13][20]以及英文星期char numToWeek[8][20]，<font color=Crmison>注意!格里高利纪元中公元1年1月1日为星期一;</font><br>②计算给定日期距离1年1月1日天数days;<br>③numToWeek[days%7]即为所求。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ </span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">		&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储月份英文名称和罗马数字的关系</span></span><br><span class="line"><span class="keyword">char</span>  monthToNum[<span class="number">13</span>][<span class="number">20</span>]=&#123;<span class="string">" "</span>,<span class="string">"January"</span>,<span class="string">"February"</span>,<span class="string">"March"</span>,<span class="string">"April"</span>,<span class="string">"May"</span>,<span class="string">"June"</span>,</span><br><span class="line">			<span class="string">"July"</span>,<span class="string">"August"</span>,<span class="string">"September"</span>,<span class="string">"October"</span>,<span class="string">"November"</span>,<span class="string">"December"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ </span></span><br><span class="line"><span class="keyword">char</span> numToWeek[<span class="number">8</span>][<span class="number">20</span>]=&#123;<span class="string">"Sunday"</span>,<span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>,<span class="string">"Wednesday"</span>,<span class="string">"Thursday"</span>,<span class="string">"Friday"</span>,<span class="string">"Saturday"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断是否为闰年 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (((y%<span class="number">4</span>==<span class="number">0</span>) &amp;&amp; (y%<span class="number">100</span>!=<span class="number">0</span>)) || (y%<span class="number">400</span>==<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算任意日期距离公元1年1月1日的天数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysFromFirstYear</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> days=<span class="number">0</span>,i=<span class="number">1</span>,j=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//累加年 </span></span><br><span class="line">	<span class="keyword">for</span>(;i&lt;y;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=<span class="number">366</span>;</span><br><span class="line">		<span class="keyword">else</span> days+=<span class="number">365</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加月 </span></span><br><span class="line">	<span class="keyword">for</span>(;j&lt;m;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=month[j][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> days+=month[j][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加日</span></span><br><span class="line">	days+=(d-k+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> days;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> d,m,y;</span><br><span class="line">	<span class="keyword">char</span> mon[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>,&amp;d,mon,&amp;y)!=EOF)&#123;</span><br><span class="line">		<span class="comment">//获取英文月份的罗马数字 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(monthToNum[i],mon)==<span class="number">0</span>)&#123;</span><br><span class="line">				m=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> days=daysFromFirstYear(y,m,d);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,numToWeek[days%<span class="number">7</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-进制转换"><a href="#8-进制转换" class="headerlink" title="8. 进制转换"></a>8. 进制转换</h2><p><strong>题目描述</strong><br>将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。</p>
<p><strong>输入</strong><br>多组数据，每行为一个长度不超过30位的十进制非负整数。<br>（注意是10进制数字的个数可能有30个，而非30bits的整数）</p>
<p><strong>输出</strong><br>每行输出对应的二进制数。</p>
<p><strong>样例输入</strong><br>985<br>211<br>1126<br><strong>样例输出</strong><br>1111011001<br>11010011<br>10001100110<br><strong>思路</strong></p>
<blockquote>
<p>①输入超过整型可存储范围，使用字符数组模拟除法过程和判断是否为0过程。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟十进制除法，返回余数 </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">divideBy2</span><span class="params">(<span class="keyword">char</span> number[],<span class="keyword">char</span> result[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(number);i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=number[i]-<span class="string">'0'</span>;</span><br><span class="line">		sum=sum*<span class="number">10</span>+temp;</span><br><span class="line">		result[num++]=sum/<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">		sum=sum%<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	result[num]=<span class="string">'\0'</span>; </span><br><span class="line">	<span class="keyword">return</span> sum+<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串转为十进制是否为0 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">char</span> number[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(number);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(number[i]!=<span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="built_in">strlen</span>(number)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//输入超过整型可存储范围，使用字符数组模拟除法过程 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> number[<span class="number">35</span>];</span><br><span class="line">	<span class="keyword">char</span> result[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> left[<span class="number">100</span>]; <span class="comment">//定义商和余数 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,number)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			left[num++]=divideBy2(number,result);</span><br><span class="line">			<span class="built_in">strcpy</span>(number,result);</span><br><span class="line">		&#125;<span class="keyword">while</span>(!isZero(number));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">"%c"</span>,left[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>C/C++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeup和PAT刷题记录——算法初步</title>
    <url>/2020/05/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>记录刷题过程中遇到的问题和技巧。</p>
<h1 id="一、技巧总结"><a href="#一、技巧总结" class="headerlink" title="一、技巧总结"></a>一、技巧总结</h1><h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h2><h3 id="1-1-简单选择排序"><a href="#1-1-简单选择排序" class="headerlink" title="1.1 简单选择排序"></a>1.1 简单选择排序</h3><p>总共进行n趟操作，每趟选出A[i，n]中最小的元素与A[i]交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[k])</span><br><span class="line">                k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=A[i];</span><br><span class="line">        A[i]=A[k];</span><br><span class="line">        A[k]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-直接插入排序"><a href="#1-2-直接插入排序" class="headerlink" title="1.2 直接插入排序"></a>1.2 直接插入排序</h3><p>总共进行n-1趟，每趟将A[i]插入A[i-1,1]中合适位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;A[j])</span><br><span class="line">                A[j]=A[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        A[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-C-标准模板库中的sort"><a href="#1-3-C-标准模板库中的sort" class="headerlink" title="1.3 C++标准模板库中的sort()"></a>1.3 C++标准模板库中的sort()</h3><p>由于c语言中的qsort函数涉及很多指针操作，且std中的sort()在实现中规避了经典快速排序中可能出现的导致实际时间复杂度退化到O(n<sup>2</sup>)的极端情况。使用C++头文件需要添加std的命名空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数cmp(非必填，默认递增排序)) <span class="comment">//注意序列中的元素一定要有可比性才可以不写cmp函数，否则需指定cmp比较规则，例如结构体。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型数组的排序 int double ...</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">6</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line">sort(A,A+<span class="number">4</span>,cmp); <span class="comment">//将A[0]-A[3]从大到小排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;    <span class="comment">//若x不等，按x从大到小排序，否则按y从小到大排序。</span></span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y &lt; b.y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcmp</span>(a.name,b.name)&lt;<span class="number">0</span>; <span class="comment">//表示a.name字典序小于b.name的字典序。&lt;font color=Crmison&gt;注意！strcmp返回值不一定是-1或+1,故==-1写法错误。&lt;/font&gt;</span></span><br><span class="line">sort(ssd,ssd+<span class="number">3</span>,cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器的排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vi.push_back(<span class="number">3</span>);</span><br><span class="line">....<span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b;&#125;  <span class="comment">//vector中类型为int型</span></span><br><span class="line">sort(vi.<span class="built_in">begin</span>,vi.<span class="built_in">end</span>,cmp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str[<span class="number">3</span>]=&#123;<span class="string">"bbbb"</span>,<span class="string">"cc"</span>,<span class="string">"aaa"</span>&#125;;</span><br><span class="line">str[<span class="number">0</span>]&gt;str[<span class="number">1</span>];  <span class="comment">//true,c++中string之间可直接比较大小。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span></span>&#123;<span class="keyword">return</span> str1.length &lt; str2.length;&#125; <span class="comment">//按字符串长度递增排序</span></span><br><span class="line">sort(str,str+<span class="number">3</span>);</span><br><span class="line">sort(str,str+<span class="number">3</span>,cmp);</span><br></pre></td></tr></table></figure>
<h3 id="1-4-排名的实现"><a href="#1-4-排名的实现" class="headerlink" title="1.4 排名的实现"></a>1.4 排名的实现</h3><p>分数不同排名不同，分数相同排名相同但占用一个排位：<br>先排序：<br>思路1：将排名这一项添加到结构体中进行记录，若当前个体分数等于上一个个体则排名等于上一个个体排名，否则当前个体排名等于数组下标+1。<br>思路2：不记录进结构体，直接输出排名。</p>
<h2 id="2-散列"><a href="#2-散列" class="headerlink" title="2. 散列"></a>2. 散列</h2><h3 id="2-1-散列的定义"><a href="#2-1-散列的定义" class="headerlink" title="2.1 散列的定义"></a>2.1 散列的定义</h3><p>有些算法题消耗时间很长，需要利用空间换时间的策略，如将输入的数字作为数组下标来统计这个数出现的次数，而输入的数不一定为整数，且有可能出现冲突，即输入多个相同的数，这时就需要用到散列的策略。<br>定义：将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素。可使用C++标准模板库中的map或reordered_mp直接使用整数hash的功能。散列常应用在查找某个字符串或数字是否出现或出现的次数。</p>
<h3 id="2-2-整数散列"><a href="#2-2-整数散列" class="headerlink" title="2.2 整数散列"></a>2.2 整数散列</h3><p>其中直接定址法、平方取中法、除留余数法为散列方法；线性探查法(开放定址法)、平方探查法(开放定址法)、链地址法(拉链法)为解决冲突的方法。</p>
<h4 id="2-2-1-直接定址法"><a href="#2-2-1-直接定址法" class="headerlink" title="2.2.1 直接定址法"></a>2.2.1 直接定址法</h4><p>H(key)=key<br>H(key)=a*key+b</p>
<h4 id="2-2-2-平方取中法"><a href="#2-2-2-平方取中法" class="headerlink" title="2.2.2 平方取中法"></a>2.2.2 平方取中法</h4><p>取key的平方的中间若干位作为hash值，很少用。</p>
<h4 id="2-2-3-除留余数法"><a href="#2-2-3-除留余数法" class="headerlink" title="2.2.3 除留余数法"></a>2.2.3 除留余数法</h4><p>为最常用方法。<br>H(key)=key%mod<br>该方法可将一个较大的数变为可行的数组下标。<br>表长TSize必须不小于mod，否则越界，一般取TSize=mod，且mod取素数可有效避免冲突。</p>
<h4 id="2-2-4-线性探查法"><a href="#2-2-4-线性探查法" class="headerlink" title="2.2.4 线性探查法"></a>2.2.4 线性探查法</h4><p>若H(key)位置被占用，则检查H(key)+1，H(key)+2,…，直到找到一个没被占用的位置，若超过了表长则回到表的首位继续循环查找。此方法容易出现扎堆现象，即表中连续若干个位置都被使用，一定程度上会降低效率。</p>
<h4 id="2-2-5-平方探查法"><a href="#2-2-5-平方探查法" class="headerlink" title="2.2.5 平方探查法"></a>2.2.5 平方探查法</h4><ul>
<li>该方法可避免扎堆现象。</li>
<li>若H(key)位置被占用，则检查H(key)+1<sup>2</sup>，H(key)-1<sup>2</sup>,H(key)+2<sup>2</sup>,H(key)-2<sup>2</sup>…，直到找到一个没被占用的位置，也可只进行正向平方探查。</li>
<li>若超过了表长则计算(H(key)+k<sup>2</sup>)%mod。</li>
<li>若H(key)-k<sup>2</sup>&lt;0,则计算((H(key)-k<sup>2</sup>)%TSize+TSize)%TSize;相当于将H(key)-k<sup>2</sup>不断加上TSize直到出现第一个非负数。</li>
<li>可证明，若k在[0，TSize)范围内都无法找到位置，那么当k&gt;=TSize时也一定无法找到位置。</li>
</ul>
<h4 id="2-2-6-链地址法（拉链法）"><a href="#2-2-6-链地址法（拉链法）" class="headerlink" title="2.2.6 链地址法（拉链法）"></a>2.2.6 链地址法（拉链法）</h4><p>设定一个数组链表，Link[0]-Link[mod-1],用Link[h]将所有H(key)=h的key链接起来。<br><font color=Crmison>注意！以上方法一般都无需自己实现，除非必须模拟这些算法或提升效率，否则都可以直接使用标准模板库中的map函数来直接使用hash功能，C++11以后可以用unordered_map，速度更快。</font></p>
<h3 id="2-3-字符串hash初步"><a href="#2-3-字符串hash初步" class="headerlink" title="2.3 字符串hash初步"></a>2.3 字符串hash初步</h3><p>利用其它进制转换为10进制的策略，仅限字符串长度不是很长的情况。</p>
<ul>
<li>若字符串均由大写字母构成：将26个大写字母视为26进制，转换为10进制。</li>
<li>若出现了小写字母，则将A-Z作为0—25,将a-z作为26-51(例如a-‘a’+26)，共52进制，转换为10进制。</li>
<li>若出现了数字，则可按照小写字母的处理方法增大进制数至62。</li>
<li>若能保证字符串末尾是数字则可将末尾的数字直接拼接上去。</li>
<li><font color=Crmison>ASCII码的hash值可用 字符-‘\0’ 计算，因为’\0’的ASCII码值为0。</font></li>
</ul>
<h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h2><h3 id="3-1-分治"><a href="#3-1-分治" class="headerlink" title="3.1 分治"></a>3.1 分治</h3><p>分治法三个步骤：</p>
<ul>
<li><strong>分解</strong>：将原问题分解为若干与原问题拥有相同或相似结构的子问题。<font color=Crmison>子问题应当互相独立、没有交叉，否则不能使用分治法。</font></li>
<li><strong>解决</strong>：递归求解所有子问题。</li>
<li><strong>合并</strong>：将子问题的解合并为原问题的解。<br>当子问题个数为1时，称为减治，如求n!,大于1则称为分治，如求Fibonacci数列。分治法既可以用递归手段也可用非递归手段去实现。</li>
</ul>
<h3 id="3-2-递归"><a href="#3-2-递归" class="headerlink" title="3.2 递归"></a>3.2 递归</h3><p>递归很适合用来实现分治思想。</p>
<h4 id="3-2-1-递归的三要素"><a href="#3-2-1-递归的三要素" class="headerlink" title="3.2.1 递归的三要素"></a>3.2.1 递归的三要素</h4><p>出自<a href="https://www.zhihu.com/question/31412436/answer/683820765?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=697560822683041792&amp;utm_content=sec的讲解" target="_blank" rel="noopener">https://www.zhihu.com/question/31412436/answer/683820765?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=697560822683041792&amp;utm_content=sec的讲解</a></p>
<ul>
<li><strong>明确函数想要做的事情(函数功能)。</strong></li>
<li><strong>寻找递归结束条件，避免程序一直调用自己，进入无底洞(递归边界)。</strong><br>需要找出当参数为什么时，递归结束，即能直接知道函数的结果，结束后需要返回或输出结果。</li>
<li><strong>找出函数的等价关系式(递归式、递归调用)</strong>。<br>最难也是最关键的一步。需要不断缩小参数的范围，且缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。<font color=Crmison>注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。这些条件一旦漏掉可能会导致死循环。</font></li>
</ul>
<h4 id="3-2-2-求n"><a href="#3-2-2-求n" class="headerlink" title="3.2.2 求n!"></a>3.2.2 求n!</h4><ul>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求n的阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于0！=1，不妨将f(0)=1作为递归边界</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f(n)这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1)*n。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-求Fibonacci数列的第n项"><a href="#3-2-3-求Fibonacci数列的第n项" class="headerlink" title="3.2.3 求Fibonacci数列的第n项"></a>3.2.3 求Fibonacci数列的第n项</h4></li>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求Fibonacci的第n项，1、1、2、3、5、8、13、21、34....</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显然f(1)=f(2)=1,故可设置递归边界为n&lt;=2。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//观察数列可轻易得到等价关系为f(n)=f(n-1)+f(n-2),</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-小青蛙跳台阶"><a href="#3-2-3-小青蛙跳台阶" class="headerlink" title="3.2.3 小青蛙跳台阶"></a>3.2.3 小青蛙跳台阶</h4>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求青蛙跳上一个n级的台阶总共有多少种跳法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少。显然f(n)=1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次跳的时候，小青蛙有两种跳法。即跳一个台阶或跳两个台阶。</span></span><br><span class="line"><span class="comment">//第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。</span></span><br><span class="line"><span class="comment">//第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。</span></span><br><span class="line"><span class="comment">//所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	ruturn f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-反转单链表"><a href="#3-2-4-反转单链表" class="headerlink" title="3.2.4 反转单链表"></a>3.2.4 反转单链表</h4><img src="1.png" alt="1"><br>例如链表为：1-&gt;2-&gt;3-&gt;4。反转后为 4-&gt;3-&gt;2-&gt;1<br>链表节点定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第一步，明确函数的功能<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转单链表，其中 head 表示链表的头节点。</span></span><br><span class="line"><span class="function">Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接把链表压缩到只有一个节点和空表分析，若为空表或只有头节点存在则直接返回head节点。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverseList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null || head.next == null)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式</li>
</ul>
<ol>
<li>首先缩小范围分析，对2-&gt;3-&gt;4反转得到4-&gt;3-&gt;2并将递归的结果用一个新节点newList保存起来。1 这个节点我们并没有去碰它，所以1的 next 节点仍然是连接着2。<br><img src="2.png" alt="2"></li>
<li>接下来只需要把节点 2 的 next 指向 1，然后把 1 的 next 指向 null即完成了反转。<br><img src="3.png" alt="3"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverseList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1.递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) &#123;</span><br><span class="line">             <span class="keyword">return</span> head;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 递归反转 子链表</span></span><br><span class="line">         Node newList = reverseList2(head.next);</span><br><span class="line">         <span class="comment">// 改变 1，2节点的指向。</span></span><br><span class="line">         <span class="comment">// 通过 head.next获取节点2</span></span><br><span class="line">         Node t1  = head.next;</span><br><span class="line">         <span class="comment">// 让 2 的 next 指向 2</span></span><br><span class="line">         t1.next = head;</span><br><span class="line">         <span class="comment">// 1 的 next 指向 null.</span></span><br><span class="line">        head.next = null;</span><br><span class="line">        <span class="comment">// 把调整之后的链表返回。</span></span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-5-递增输出n个数的全排列"><a href="#3-2-5-递增输出n个数的全排列" class="headerlink" title="3.2.5 递增输出n个数的全排列"></a>3.2.5 递增输出n个数的全排列</h4></li>
</ol>
<ul>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按从小到大输出1-n的全排列，即为每一位填入一个从1-n枚举的不重复的数字</span></span><br><span class="line"><span class="comment">//P为当前排列，hashTable记录整数x是否已经在当前排列中，即P中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ptintf(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式</li>
</ul>
<ol>
<li>首先处理index节点，枚举1-n，将第一个还未填入P中的值x填入P[index]中，并记录hashTable[x]=true。</li>
<li>接下来只需要处理下一个位置，即generateP(index+1);</li>
<li>当处理完p[index]=x的子问题后，还原hashTable[x]=false;<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出从1-n的全排列，从index开始填</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ptintf(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举1-n，将x填入P[index]位置。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=index;x&lt;=n;x++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">			P[index]=x;</span><br><span class="line">			hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">			generateP(index+<span class="number">1</span>);</span><br><span class="line">			hashTable[x]=<span class="literal">false</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-6-n皇后问题"><a href="#3-2-6-n皇后问题" class="headerlink" title="3.2.6 n皇后问题"></a>3.2.6 n皇后问题</h4></li>
</ol>
<ul>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个n*n棋盘上放置n个皇后使其两两均不在同一行、同一列、同一条对角线上，求合法方案数。</span></span><br><span class="line"><span class="comment">//考虑每行和没每列均只能放置一个皇后，问题归结为求全排列中的合法放置方案数，即求全排列中两两不在同一对角线的方案并统计。</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列</span></span><br><span class="line"><span class="comment">//判断当前方案是否合法有两种方式，暴力法和回溯法</span></span><br><span class="line"><span class="comment">//暴力法：在每一次递归边界遍历任两个皇后，判断是否在同一条对角线</span></span><br><span class="line"><span class="comment">//回溯法：每次处理第index位时，遍历之前的皇后检查是否有冲突，若有冲突，则无需继续处理之后的位置，直接返回上一层即可。</span></span><br><span class="line"><span class="comment">//回溯法比暴力法效率要高。</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;   <span class="comment">//能到达递归边界的方案一定是合法方案</span></span><br><span class="line">        count++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;   <span class="comment">//能到达递归边界的方案一定是合法方案</span></span><br><span class="line">        count++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举1-n，将x填入P[index]位置。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">true</span>;  <span class="comment">//true表示不会冲突</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)&#123; <span class="comment">//</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">				P[index]=x;</span><br><span class="line">				hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">				generateP(index+<span class="number">1</span>);</span><br><span class="line">				hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-7-递归的优化"><a href="#3-2-7-递归的优化" class="headerlink" title="3.2.7 递归的优化"></a>3.2.7 递归的优化</h4></li>
</ul>
<p><strong>记录重复计算的子问题</strong><br>递归有时候是会产生大量重复计算的，例如求Fibonacci的第n项，例如f(5)=f(4)+f(3)，而f(4)会重复计算f(3)，优化时可保存下来已经被计算过的子问题即arr[n]=f(n),若未计算过，则置arr[n]=-1。在递归时判断一下是否计算过，若计算过则直接取出结果即可，否则再进行递归计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断有没计算过</span></span><br><span class="line">    <span class="keyword">if</span>(arr[n] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//计算过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没有计算过，递归计算,并且把结果保存到 arr数组里</span></span><br><span class="line">        arr[n] = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>考虑是否可以递推实现</strong><br>递归往往都是自上往下递归的，直到递归到最底，再一层一层把值返回。但是当n比较大的时候栈空间可能会不够。这时候可以考虑自底向上的做法，这种做法被称为<strong>递推</strong>。例如Fibonacci数列的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> n;</span><br><span class="line">       <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> f2 = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           sum = f1 + f2;</span><br><span class="line">           f1 = f2;</span><br><span class="line">           f2 = sum;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-贪心"><a href="#4-贪心" class="headerlink" title="4. 贪心"></a>4. 贪心</h2><h3 id="4-1-简单贪心"><a href="#4-1-简单贪心" class="headerlink" title="4.1 简单贪心"></a>4.1 简单贪心</h3><p>总是考虑当前状态下局部最优解，来使全局的结果达到最优。</p>
<h3 id="4-2-开区间不相交问题"><a href="#4-2-开区间不相交问题" class="headerlink" title="4.2 开区间不相交问题"></a>4.2 开区间不相交问题</h3><p><strong>题目描述</strong><br>给出n个开区间(x,y)，计算最多可以选择多少个区间，使得这些开区间两两没有交集。<br><strong>输入</strong><br>输入第一行为n表示n个开区间，第二行n个开区间对(x,y)。<br><strong>输出</strong><br>输出1行为方案个数。<br><strong>样例输入</strong><br>4<br>2 4 1 3 3 5 6 7<br><strong>样例输出</strong><br>3<br><strong>思路</strong></p>
<blockquote>
<p>按左端点从大到小排序，若左端点相同则按右端点从小到大排序<br> lastX记录上一个被选区间的左端点。<br> 若当前区间的右端点在上一个区间左端点的左边<font color=Crmison>(&lt;=)</font>则方案数+1</p>
</blockquote>
<h3 id="4-3-闭区间选点问题"><a href="#4-3-闭区间选点问题" class="headerlink" title="4.3 闭区间选点问题"></a>4.3 闭区间选点问题</h3><p><strong>题目描述</strong><br>给出n个闭区间[x,y]，计算最少需要确定多少个点，使得这些闭区中都至少存在一个点。<br><strong>输入</strong><br>输入第一行为n表示n个开区间，第二行n个闭区间对[x,y]。<br><strong>输出</strong><br>输出1行为方案个数。<br><strong>样例输入</strong><br>3<br>1 4 2 6 5 7<br><strong>样例输出</strong><br>2<br><strong>思路</strong></p>
<blockquote>
<p>按左端点从大到小排序，若左端点相同则按右端点从小到大排序<br> lastX记录上一个被选区间的左端点。<br> 若当前区间的右端点在上一个区间左端点的左边<font color=Crmison>(&lt;)</font>则方案数+1</p>
</blockquote>
<h1 id="二、经典题目"><a href="#二、经典题目" class="headerlink" title="二、经典题目"></a>二、经典题目</h1><h2 id="2-1-问题-B-分组统计"><a href="#2-1-问题-B-分组统计" class="headerlink" title="2.1 问题 B: 分组统计"></a>2.1 问题 B: 分组统计</h2><p><strong>题目描述</strong><br>先输入一组数，然后输入其分组，按照分组统计出现次数并输出，参见样例。<br><strong>输入</strong><br>输入第一行表示样例数m，对于每个样例，第一行为数的个数n，接下来两行分别有n个数，第一行有n个数，第二行的n个数分别对应上一行每个数的分组，n不超过100。<br><strong>输出</strong><br>输出m行，格式参见样例，按从小到大排。<br><strong>样例输入</strong><br>1<br>7<br>3 2 3 8 8 2 3<br>1 2 3 2 1 3 1<br><strong>样例输出</strong><br>1={2=0,3=2,8=1}<br>2={2=1,3=0,8=1}<br>3={2=1,3=1,8=0}<br><strong>思路</strong></p>
<ul>
<li>利用一个二维矩阵A[i][j]记录数字j在组别i中出现的次数</li>
<li>flagS[j]和flagG[i]分别记录数字j和组别i是否出现，这里容易出错 </li>
<li>找出最大组别编号和最大数字，若组号i和数字j均存在，则输出result[i][j]</li>
<li><font color=Crmison>易错点:组号i小于n，但样例数大小j范围未知，二维数组的第二维应初始化大一些，否则容易错误50%</font><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);	</span><br><span class="line">			<span class="comment">//在循环内部定义数组就无须初始化为0了 </span></span><br><span class="line">			<span class="keyword">int</span> sample[<span class="number">110</span>]=&#123;&#125;,flagS[<span class="number">2010</span>]=&#123;&#125;,group[<span class="number">110</span>]=&#123;&#125;,flagG[<span class="number">110</span>]=&#123;&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> maxs=<span class="number">0</span>,maxg=<span class="number">0</span>; <span class="comment">//找出最大样例和最大组别，方便输出。 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,sample+i);</span><br><span class="line">				<span class="keyword">if</span>(sample[i]&gt;maxs) maxs=sample[i];</span><br><span class="line">				flagS[sample[i]]=<span class="number">1</span>; </span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> result[<span class="number">110</span>][<span class="number">2010</span>]=&#123;&#125;;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,group+i);</span><br><span class="line">				<span class="keyword">if</span>(group[i]&gt;maxg) maxg=group[i];</span><br><span class="line">				flagG[group[i]]=<span class="number">1</span>;</span><br><span class="line">				<span class="comment">//记录统计结果 </span></span><br><span class="line">				result[group[i]][sample[i]]++; </span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			<span class="comment">//输出统计结果 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxg;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(flagG[i]==<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d=&#123;"</span>,i);</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxs;j++)&#123;</span><br><span class="line">						<span class="keyword">if</span>(flagS[j]==<span class="number">1</span>)&#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">"%d=%d"</span>,j,result[i][j]);</span><br><span class="line">							<span class="keyword">if</span>(j&lt;maxs) <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);	</span><br><span class="line">				&#125; 		</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>C/C++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法复杂度和黑盒测试</title>
    <url>/2020/04/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>了解算法复杂度很重要，我们在编写算法时常常要注意算法复杂度以避免出现程序运行超时的结果，此外，了解常用OJ的黑盒测试方法也有助于编写正确高效的算法。本篇简单介绍了三种算法复杂度和黑盒测试的代码写法，并简单罗列了OJ在判定时出现的一些结果，以便找到出错原因。</p>
<h1 id="一、算法复杂度"><a href="#一、算法复杂度" class="headerlink" title="一、算法复杂度"></a>一、算法复杂度</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>时间复杂度是算法执行基本运算(如加减乘除)的次数所处的等级，是评判算法时间效率的有效标准，较高的时间复杂度会让评测系统返回“运行超时”，<font color=Crmison>对一般的OJ系统来说，一秒能承受的运算次数大概是10<sup>7</sup>至10<sup>8</sup>。</font></p>
<blockquote>
<ol>
<li>讲时间复杂度是不带系数的，称为时间复杂度常数，例如基本运算次数为cn,cn<sup>2</sup>，则时间复杂度分别为O(n)，O(n<sup>2</sup>)。</li>
<li>高等级的幂次会覆盖低等级的幂次，因此O(3n<sup>2</sup>+n+2)=O(n<sup>2</sup>)。</li>
<li>当某些算法实现较为复杂时，其常数会比较大，这时即使时间复杂度相同其性能也会有较大差距。</li>
<li>不同级别时间复杂度比较：O(1)&lt;O(logn)&lt;O(n)&lt;O(n<sup>2</sup>)。</li>
</ol>
</blockquote>
<h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>空间复杂度和时间复杂度的写法相同，表示算法需要消耗的最大数据空间。一般来说空间都是足够使用的，只要不开好几个10<sup>7</sup>以上的数组，<font color=Crmison>故一般会使用以空间换时间的算法策略。</font></p>
<h2 id="3-编码复杂度"><a href="#3-编码复杂度" class="headerlink" title="3. 编码复杂度"></a>3. 编码复杂度</h2><p>编码复杂度是一个定性的概念，没有一个量化标准，就是指代码的冗长程度。如果使用了冗长的算法思想则编码复杂度就会很大。</p>
<h1 id="二、黑盒测试"><a href="#二、黑盒测试" class="headerlink" title="二、黑盒测试"></a>二、黑盒测试</h1><p>OJ后台会准备若干组数据(一般是放在一个文件里)让程序运行，并将运行结果在字符串意义上进行比较，若完全相同，则称通过了本题的黑盒测试，否则返回不同判定结果，根据黑盒测试对每组数据单独测试还是一次性全部测试，分为单点和多点测试。</p>
<h2 id="1-单点测试"><a href="#1-单点测试" class="headerlink" title="1. 单点测试"></a>1. 单点测试</h2><p>PAT采取的是单点测试，它会对每组数据都给出相应的测评结果，并且每组数据都有得分值，题目总得分等于通过数据得分值之和。所以它仅要求编写的程序能一次运行一组数据，采用普通写法。</p>
<h2 id="2-多点测试"><a href="#2-多点测试" class="headerlink" title="2. 多点测试"></a>2. 多点测试</h2><p>大部分OJ如Codeup等都是采用多点测试，它要求编写的程序能够一次性运行所有的数据，并要求所有输出结果都必须完全正确才算通过测试，故需要用到循环结构。多点测试能够考验算法编写的严谨性。题目一般会有3种输入格式，需要采取不同的输入方式。</p>
<blockquote>
<p>三种输入类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环输入直到文件末尾</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">    ...<span class="comment">//scanf返回值为成功读入的参数个数，当读取文件到达末尾时才会读取失败，此时返回-1，C语言中用EOF(End Of File)代替-1。</span></span><br><span class="line">    <span class="comment">//在运行框输入数据时并不会触发EOF，需要手动输入&lt;Ctrl+Z&gt;键，再按&lt;Enter&gt;键触发。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str)!=EOF)&#123;...&#125;</span><br><span class="line"><span class="keyword">while</span>(gets(str)!=<span class="literal">NULL</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入直到满足某个条件时退出</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b), a||b)&#123;</span><br><span class="line">    ...<span class="comment">//当a和b中有一个不为零时就进行循环。注意！输入多少数据(&amp;a和&amp;b)，判零条件就有几个(a||b)，否则输入输出的格式会出错。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入题目指定组数的数据</span></span><br><span class="line"><span class="keyword">while</span>(T--)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>另外要<font color=Crmison>注意！多点测试中每一次循环都要重置一下变量和数组(memset函数或fill函数)，否则在下一组数据来临之前变量和数组的状态就不是初始状态了。</font></p>
<h1 id="三、OJ常见评测结果"><a href="#三、OJ常见评测结果" class="headerlink" title="三、OJ常见评测结果"></a>三、OJ常见评测结果</h1><h2 id="1-答案正确-Accepted-AC"><a href="#1-答案正确-Accepted-AC" class="headerlink" title="1. 答案正确(Accepted, AC)"></a>1. 答案正确(Accepted, AC)</h2><p>若为单点测试，则每通过一组数据就会返回一个Accepted,若是多点测试，那么只有当通过了所有数据时，才会返回Accepted。</p>
<h2 id="2-编译错误-Compile-Error-CE"><a href="#2-编译错误-Compile-Error-CE" class="headerlink" title="2. 编译错误(Compile Error, CE)"></a>2. 编译错误(Compile Error, CE)</h2><p>出现这种情况有可能是选错了语言。</p>
<h2 id="3-答案错误-Wrong-Answer-WA"><a href="#3-答案错误-Wrong-Answer-WA" class="headerlink" title="3. 答案错误(Wrong Answer, WA)"></a>3. 答案错误(Wrong Answer, WA)</h2><p>代码逻辑问题或输出的内容有误。</p>
<h2 id="4-运行超时-Time-Limit-Excees-TLE"><a href="#4-运行超时-Time-Limit-Excees-TLE" class="headerlink" title="4. 运行超时(Time Limit Excees, TLE)"></a>4. 运行超时(Time Limit Excees, TLE)</h2><p>一般来说，导致该结果是由于算法的时间复杂度导致的，也可能是某组数据使得代码某处死循环了。</p>
<h2 id="5-运行错误-Runtime-Error-RE"><a href="#5-运行错误-Runtime-Error-RE" class="headerlink" title="5. 运行错误(Runtime Error, RE)"></a>5. 运行错误(Runtime Error, RE)</h2><p>段错误(非法访问内存，如数组越界、指针乱指)、浮点错误(例如除数为0、模数为0)、递归爆栈(一般由于递归层数过深)。</p>
<h2 id="6-内存超限-Memory-Limit-Exceeded-MLE"><a href="#6-内存超限-Memory-Limit-Exceeded-MLE" class="headerlink" title="6. 内存超限(Memory Limit Exceeded, MLE)"></a>6. 内存超限(Memory Limit Exceeded, MLE)</h2><p>如果程序使用太多空间，例如数组太大可能会导致此结果。</p>
<h2 id="7-格式错误-Presentation-Error-PE"><a href="#7-格式错误-Presentation-Error-PE" class="headerlink" title="7. 格式错误(Presentation Error, PE)"></a>7. 格式错误(Presentation Error, PE)</h2><p>多输出了空格或换行。</p>
<h2 id="8-输出超限-Output-Limit-Exceeded-OLE"><a href="#8-输出超限-Output-Limit-Exceeded-OLE" class="headerlink" title="8. 输出超限(Output Limit Exceeded, OLE)"></a>8. 输出超限(Output Limit Exceeded, OLE)</h2><p>输出了过量的内容，如大量调试信息或者特殊数据导致的死循环。</p>
]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>C/C++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C和C++的常用语法</title>
    <url>/2020/04/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/C%E5%92%8CC++%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在算法机试中，最适合使用的就是C语言和C++语言，C++可以向下兼容C，且其基本语法除了输入输出部分，其余顺序结构、循环结构、数组、指针都是几乎一样的。C++中的cin和cout消耗时间比C中的scanf和printf多得多，而C中有一些不太顺手的设定可以使用C++来取代，故我们在机试时通常选择C++的编译器，而混用C和C++的语法来优化算法。本篇简单介绍一下机试中常用的C/C++基本语法。</p>
<h1 id="一、C程序的组成"><a href="#一、C程序的组成" class="headerlink" title="一、C程序的组成"></a>一、C程序的组成</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件"></a>1.头文件</h2><p><code>#include &lt;stdio.h&gt;</code>即是头文件，用来添加程序中需要使用到的库函数，其中<code>stdio.h</code>是标准输入输出库，是一个.h格式的文件，其中包含了一些与输入输出有关的东西，其他功能的库文件还有<code>math.h</code>，负责数学函数,<code>string.h</code>负责字符串相关函数，等等。当我们需要用到这些库函数时就必须将其头文件include起来。此外，C++中的等价写法为<code>#include &lt;csdio&gt;</code>,<code>#include &lt;cmath&gt;</code>,<code>include &lt;cstring&gt;</code>。</p>
<h2 id="2-主函数"><a href="#2-主函数" class="headerlink" title="2.主函数"></a>2.主函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数是一个程序的入口，也就是程序开始执行的地方，一个程序最多只能有一个主函数。<font color=Crimson>注意！请不要在同一个程序中使用cout和printf，有时会出问题。</font></p>
<h1 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h1><h2 id="1-变量的定义"><a href="#1-变量的定义" class="headerlink" title="1. 变量的定义"></a>1. 变量的定义</h2><p><code>变量类型 变量名;</code><br><code>变量类型 变量名 = 初值;</code><br>变量名区分大小写。</p>
<h2 id="2-变量类型"><a href="#2-变量类型" class="headerlink" title="2. 变量类型"></a>2. 变量类型</h2><p><img src="1.png" alt="基本数据类型"></p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><font color=Crimson>短整型(short): </font> 2Byte，机试中一般用不到。<br><font color=Crimson>整型(int): </font> 4Byte,绝对值在10<sup>9</sup>范围内整数都可以定义为Int型。<br><font color=Crimson>长整型(long long): 8Byte,赋值大于2<sup>31</sup>-1的初值，需要在初值后面加上LL，否则编译错误。</font></p>
<h3 id="2-2-浮点型"><a href="#2-2-浮点型" class="headerlink" title="2.2 浮点型"></a>2.2 浮点型</h3><p><font color=Crimson>单精度(float): </font> 有效精度6-7位。<br><font color=Crimson>双精度(double): </font> 有效精度15-16位,因此机试中碰到浮点型一般都是用double来存储。</p>
<blockquote>
<p>浮点数<font>在经过容易损失精度得计算后</font>，计算结果总是不精确得，有一定得误差，故需要引入一个极小数eps来修正误差，从而进行各种比较操作，可以取eps为10<sup>-8</sup>,变量b的浮动范围为[b-eps,b+eps],各种比较操作的宏定义如下：</p>
</blockquote>
<p>a==b:<img src="4.png" alt="a==b"> a&gt;b:<img src="5.png" alt="a&gt;b"> a&lt;b:<img src="6.png" alt="a&lt;b"> a&gt;=b:<img src="7.png" alt="a&gt;=b"> a&lt;=b:<img src="8.png" alt="a&lt;=b"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> db1=<span class="number">4</span>*<span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>);   <span class="comment">//PI的损失精度的计算</span></span><br><span class="line"><span class="keyword">double</span> db2=<span class="number">3</span>*<span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="number">3.0</span>)/<span class="number">2</span>);</span><br><span class="line">db1==db2;  <span class="comment">//flase;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);    <span class="comment">//定义pi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;  <span class="comment">//注意该用括号的地方用括号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Equ(a,b) ((fabs((a)-(b)))&lt;(eps))  <span class="comment">//a==b,不等于可使用!Equ(a,b)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> More(a,b) (((a)-(b))&gt;(eps))   <span class="comment">//a&gt;b</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Less(a,b) (((a)-(b))&lt;(-eps))  <span class="comment">//a&lt;b</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MoreEqu(a,b) (((a)-(b))&gt;(-eps))  <span class="comment">//a&gt;=b</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LessEqu(a,b) (((a)-(b))&lt;(eps))   <span class="comment">//a&lt;=b</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-字符型"><a href="#2-3-字符型" class="headerlink" title="2.3 字符型"></a>2.3 字符型</h3><p><font color=Crimson>字符常量和字符变量: </font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'z'</span>, c2 = <span class="string">'j'</span>, c3 = <span class="number">117</span>;</span><br></pre></td></tr></table></figure>
<p>字符常量统一使用ASCII编码，小写字母比大写字母码值大32。0-9（48-57），A-Z（65-90），a-z（97-122）。<br><font color=Crimson>转义字符: </font>\n（换行）、\t（Tab）、<font color=Crimson>\0（代表空字符NULL，其ASCII码为0，请注意\0不是空格）</font></p>
<p><font color=Crimson>字符串常量: </font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">25</span>]=<span class="string">"wo ai de ren ye ai wo"</span>;</span><br></pre></td></tr></table></figure>
<p>C语言中无基本数据类型可存储字符串常量，只能用字符数组，而C++中有string类型。</p>
<h3 id="2-4-布尔型"><a href="#2-4-布尔型" class="headerlink" title="2.4 布尔型"></a>2.4 布尔型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag1=<span class="number">0</span>, flag2=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>bool在C++中可直接使用，在C中必须添加<code>stdbool.h</code>,但机试选择C++编译器，故可不添加。用整型赋值时true(非零)，false(零)。bool可以%d格式输出0或1。</p>
<h2 id="3-强制类型转换"><a href="#3-强制类型转换" class="headerlink" title="3. 强制类型转换"></a>3. 强制类型转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(新类型名)变量名;</span><br></pre></td></tr></table></figure>
<p>其中(int)f直接将小数部分切掉，即向下取整。在赋值时，编译器可以自动进行转换，但在计算过程中需要手动强制类型转换。</p>
<h2 id="4-符号常量和const常量-宏定义、宏替换"><a href="#4-符号常量和const常量-宏定义、宏替换" class="headerlink" title="4. 符号常量和const常量(宏定义、宏替换)"></a>4. 符号常量和const常量(宏定义、宏替换)</h2><p><font color=Crimson><code>#define 标识符 常量</code> : </font> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14</span></span><br></pre></td></tr></table></figure>
<p><font color=Crimson><code>const 数据类型 变量名 = 常量;</code> : </font>  推荐方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p><font color=Crimson><code>#define 标识符 任何语句或片段</code> : </font>  不推荐。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># difine ADD(a,b) ((a)+(b))</span></span><br></pre></td></tr></table></figure>
<p>由于宏定义是直接将对应部分替换然后进行编译和运行，故能加括号的地方应添加括号，否则会出现逻辑错误。</p>
<h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h2><p><font color=Crimson>7个常用算术运算符 : </font>  <code>+ - * / % ++ --</code><br><code>+ - * /</code>优先级与四则运算相同， %和/优先级相同，且当/和%的除数为0时会导致程序异常退出或得到错误”1.#INF00”。<br><font color=Crimson>6个关系运算符 : </font> <code>&lt; &gt; &lt;= &gt;= == !=</code><br><font color=Crimson>3个逻辑运算符 : </font> <code>&amp;&amp; || ！</code><br><font color=Crimson>1个条件运算符(c中唯一的三目运算符) : </font> <code>A ? B : C</code><br><font color=Crimson>6个位运算符 : </font> &lt;&lt;(左移) &gt;&gt;(右移) &amp;(位与) |(位或) ^(位异或) ~(位取反)<br>运算符的优先级和结合性参见<a href="https://zh.cppreference.com/w/c/language/operator_precedence" target="_blank" rel="noopener">https://zh.cppreference.com/w/c/language/operator_precedence</a><br>程序中无穷大的数INF的设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br></pre></td></tr></table></figure>
<p>二者等价。</p>
<h1 id="三、顺序结构"><a href="#三、顺序结构" class="headerlink" title="三、顺序结构"></a>三、顺序结构</h1><h2 id="1-赋值表达式"><a href="#1-赋值表达式" class="headerlink" title="1. 赋值表达式"></a>1. 赋值表达式</h2><p>给多个变量赋值，可使用连续等号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">n = m = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>复合赋值运算符<code>+= -= *= /= %=</code>可以加快编译速度，提高代码可读性，故在程序中经常用到。</p>
<h2 id="2-使用C语言中的scanf和printf输入-输出"><a href="#2-使用C语言中的scanf和printf输入-输出" class="headerlink" title="2. 使用C语言中的scanf和printf输入/输出"></a>2. 使用C语言中的scanf和printf输入/输出</h2><h3 id="2-1-scanf-“格式控制”-变量地址"><a href="#2-1-scanf-“格式控制”-变量地址" class="headerlink" title="2.1 scanf(“格式控制”,变量地址)"></a>2.1 scanf(“格式控制”,变量地址)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>,&amp;hh,&amp;mm,&amp;ss);  <span class="comment">//输入hh:mm:ss</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%lf%c"</span>,&amp;a,&amp;b,&amp;c);  <span class="comment">//输入a,b,c</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b); <span class="comment">//输入a b</span></span><br></pre></td></tr></table></figure>
<p>scanf函数的格式控制符如下图所示：<br><img src="2.png" alt="scanf格式控制"></p>
<ol>
<li><p>格式控制和我们在控制台输入的格式一致。</p>
</li>
<li><p>&amp;为取地址符，char数组名本来就是一个地址，故不需要&amp;。</p>
</li>
<li><p><font color=Crmison>除了控制符%c可以读入一个空白符(空格、换行、Tab)以外,scanf的其他格式符的输入均以空白符为结束判断标志。</font></p>
</li>
<li><p>scanf中可以用转义字符，不过一般用不到。</p>
</li>
</ol>
<h3 id="2-2-printf-“格式控制”-变量名称"><a href="#2-2-printf-“格式控制”-变量名称" class="headerlink" title="2.2 printf(“格式控制”, 变量名称)"></a>2.2 printf(“格式控制”, 变量名称)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br></pre></td></tr></table></figure>
<p>printf函数的格式控制符如下图所示：<br><img src="3.png" alt="printf格式控制"></p>
<ol>
<li><p>printf中不使用&amp;。</p>
</li>
<li><p>注意double类型变量scanf的格式符为%lf,printf的格式符为%f。</p>
</li>
<li><p>printf中可使用转义字符\n、\t等。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%%"</span>); <span class="comment">//输出%</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\\"</span>); <span class="comment">//输出\</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>3种实用的输出格式:<blockquote>
<p><strong>%md</strong>    &emsp;使不足m位的int变量以M位右对齐输出，高位空格补齐；若变量本身超过m位则保持原样。<br><strong>%0md</strong>   &nbsp;相比于%md高位补0。<br><strong>%.mf</strong>   &nbsp;使浮点数保留m位小数输出，使用“四舍六入五成双”规则，而不是四舍五入。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>C++中的输入与输出函数cin与cout</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  //string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; //控制double型精度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;db&gt;&gt;c&gt;&gt;str;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;db&lt;&lt;<span class="string">" "</span>&lt;&lt;str&lt;&lt;<span class="string">"haha"</span>&lt;&lt;<span class="string">"\n"</span>&lt;<span class="built_in">endl</span>;  <span class="comment">//"\n"和endl都表示换行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str,<span class="number">100</span>); <span class="comment">//读入一行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;  <span class="comment">//使用C++中的string容器输入一行</span></span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;<span class="number">123.4567</span>&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//控制double型变量输出小数点后两位。</span></span><br></pre></td></tr></table></figure>
<p>cin与cout在输入/输出大量数据的情况下表现得非常糟糕，有时题目中数据还没有输入完毕就已经超时，故还是推荐使用scanf与printf输入与输出。</p>
<h2 id="3-使用getchar和putchar输入-输出字符"><a href="#3-使用getchar和putchar输入-输出字符" class="headerlink" title="3. 使用getchar和putchar输入/输出字符"></a>3. 使用getchar和putchar输入/输出字符</h2><p>getchar用来输入单个字符，注意它能够读入空白符，它经常使用在某些scanf使用不便的场合。putchar用来输出单个字符。</p>
<h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>编译时会自动跳过注释部分，不执行。</p>
<h2 id="5-typedef"><a href="#5-typedef" class="headerlink" title="5. typedef"></a>5. typedef</h2><p>用于给复杂的数据类型起一个别名，用别名代替原来的写法，提高编码效率。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br></pre></td></tr></table></figure>
<h2 id="6-常用math函数"><a href="#6-常用math函数" class="headerlink" title="6. 常用math函数"></a>6. 常用math函数</h2><p><font color=Crmison>除了abs在C编译器中需要添加stdlib.h外，其它数学函数使用时需要添加头文件math.h和cmath。注意!</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">// double型变量取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>; <span class="comment">//int型变量取绝对值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//向上取整</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> p)</span></span>; <span class="comment">//返回x的p次方</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回根号x</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回以自然对数e为底数的logx,c语言中没有对任意底数求对数的函数，只能使用此公式和换底公式来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;  <span class="comment">//三角函数,x必须为弧度制，如pi/2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//反三角函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//对x四舍五入到整数位，以%d格式printf时需取整(int)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;<span class="number">0.0</span>) ? <span class="built_in">floor</span>(x+<span class="number">0.5</span>) : <span class="built_in">ceil</span>(x<span class="number">-0.5</span>);&#125;  <span class="comment">//有些编译器如PAT不支持round函数，可利用floor和ceil写一个。</span></span><br></pre></td></tr></table></figure>

<h1 id="四、选择结构"><a href="#四、选择结构" class="headerlink" title="四、选择结构"></a>四、选择结构</h1><h2 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1. if语句"></a>1. if语句</h2><p>用于分支条件较少的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(B)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A)&#123;   <span class="comment">//if语句嵌套</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(B)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2. switch语句"></a>2. switch语句</h2><p>用于分支条件较多的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式n;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除break则会从第一个匹配的case开始执行之后的所有语句。</p>
<h1 id="五、循环结构"><a href="#五、循环结构" class="headerlink" title="五、循环结构"></a>五、循环结构</h1><h2 id="1-while语句"><a href="#1-while语句" class="headerlink" title="1. while语句"></a>1. while语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(A)&#123;  <span class="comment">//推荐</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(A);  <span class="comment">//不推荐</span></span><br></pre></td></tr></table></figure>

<h2 id="2-for语句"><a href="#2-for语句" class="headerlink" title="2. for语句"></a>2. for语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(A;B;C)&#123;   <span class="comment">//注意！C中A位置不允许定义变量而C++可以。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-break和continue语句"><a href="#3-break和continue语句" class="headerlink" title="3. break和continue语句"></a>3. break和continue语句</h2><p>break：跳出循环体。continue：跳出当前循环，即continue后面的代码不执行，直接进入下一轮循环。</p>
<h1 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h1><p>如果数组大小较大（大概10<sup>6</sup>级别），则需要将其定义在主函数外面，否则会使程序异常退出，因为函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的全局变量来自静态存储区，允许申请的空间较大。<br>数组的长度计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);  <span class="comment">//数组占内存总空间，除以单个元素占内存空间大小</span></span><br></pre></td></tr></table></figure>
<h2 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[数组大小];  <span class="comment">//数组大小必须是整数常量，不可以是变量。</span></span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//后面未被初始化的元素将根据编译器内部实现的不同而被赋以不同的初值（可能是很大的随机数），但一般默认为0。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2. 二维数组"></a>2. 二维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[第一维大小][第二维大小];</span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">6</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;&#125;,&#123;<span class="number">8</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-字符数组"><a href="#3-字符数组" class="headerlink" title="3. 字符数组"></a>3. 字符数组</h2><ol>
<li>初始化：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = &#123;<span class="string">'G'</span>,<span class="string">'o'</span>,<span class="string">'o'</span>,<span class="string">'d'</span>,<span class="string">' '</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'y'</span>,<span class="string">'!'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = <span class="string">"Good story!"</span>;  <span class="comment">//直接赋值字符串，注意！仅限于初始化，程序其他位置不允许这样直接赋值整个字符串。</span></span><br></pre></td></tr></table></figure>
<font color=Crmison>注意！定义了数组或字符指针之后，需要做一个初始化，否则里面将是随机值，以后将无法判断改字符串是否为空。</font><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名,‘\<span class="number">0</span>’,<span class="keyword">sizeof</span>(数组名));</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strlen</span>(str) == <span class="number">0</span>)  <span class="comment">//推荐判空方式</span></span><br><span class="line"> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'\0'</span>)  /避免使用，容易crash</span><br></pre></td></tr></table></figure></li>
<li>输入输出：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;str[<span class="number">0</span>]);  <span class="comment">//%c能读入空白符（空格，TAB，换行），%s以空白符为结束符。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>]=getchar();  <span class="comment">//getchar()可以读入空白符。注意！在scanf("%s\n")和gets(str)之间应先使用getchar()吸收掉\n，否则不能读取str,因为gets(str)以\n为结束符。</span></span><br><span class="line"><span class="built_in">putchar</span>(str[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">gets(str);     <span class="comment">//gets()以换行符\n为结束符，可以读入空格。PAT OJ中不支持gets()函数。</span></span><br><span class="line"><span class="built_in">puts</span>(str);    <span class="comment">//输出一个字符串并紧跟换行</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><font color=Crmison>3. 字符数组的存放方式：</font><br>每一个一维数组的末尾都有一个空字符\0，占一位，表示存放的字符串的结尾，puts和printf就是通过识别\0来输出字符串的。故在定义字符数组时长度一定要比实际存储字符串的长度至少多1。\0在使用gets和scanf(“%s”)时会自动添加，其他的输入如getchar()则需要在字符串末尾手动添加\0，否则puts和printf将由于无法识别字符串末尾而输出一大堆乱码。</p>
<h2 id="4-memset——对数组中每一个元素赋相同的值"><a href="#4-memset——对数组中每一个元素赋相同的值" class="headerlink" title="4. memset——对数组中每一个元素赋相同的值"></a>4. memset——对数组中每一个元素赋相同的值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">memset</span>(数组名，值，<span class="keyword">sizeof</span>(数组名));  <span class="comment">//速度快，但它是按字节赋值，即对每一个字节赋同样的值，故常用它赋0或-1不容易出错。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-string-h头文件"><a href="#5-string-h头文件" class="headerlink" title="5. string.h头文件"></a>5. string.h头文件</h2><p>包含了很多关于字符数组的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(str)</span></span>; <span class="comment">//返回字符数组中第一个\0之前的字符的个数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(str1,dtr2)</span></span>; <span class="comment">//按字典序返回两个字符串大小的比较结果: 大于0的数(str1 &gt; str2)、返回0(str1 == str2)、小于0的数(str1 &lt; str2),返回值根据不同编译器处理而有不同的返回值，通常为1、0、-1。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(str1,str2)</span></span>; <span class="comment">//将str2复制给str1，包括\0。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcat</span><span class="params">(str1,str2)</span></span>; <span class="comment">//将str2拼接到str1的后面。</span></span><br></pre></td></tr></table></figure>

<h2 id="6-sscanf与sprintf"><a href="#6-sscanf与sprintf" class="headerlink" title="6. sscanf与sprintf"></a>6. sscanf与sprintf</h2><p>处理字符串格式输入输出问题的利器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n); <span class="comment">//将str中的内容以%d格式写入n中，从左至右。</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, n); <span class="comment">//将n以%d格式写入字符数组str中，从右至左。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d:%f,%s"</span>,&amp;n1,&amp;n2,&amp;n3);</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d:%.2f,%s"</span>,n1,n2,n3);</span><br></pre></td></tr></table></figure>
<p>sscanf还支持正则表达式，可解决字符串中的复杂问题。</p>
<h1 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h1><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回类型 函数名称(参数类型 参数)&#123;</span><br><span class="line">    函数主题</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> c)</span></span>;  <span class="comment">//值传递,传入的是实参的一个副本，故不能改变实参的值</span></span><br></pre></td></tr></table></figure>

<h2 id="2-以数组作为函数参数"><a href="#2-以数组作为函数参数" class="headerlink" title="2. 以数组作为函数参数"></a>2. 以数组作为函数参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[][<span class="number">5</span>])</span></span>;  <span class="comment">//第一维度可不写长度，第二维度需要写明长度，可以再函数内部修改实参数组中的元素的值。</span></span><br><span class="line"></span><br><span class="line">func(a,b);  <span class="comment">//调用时只需要写数组名。</span></span><br></pre></td></tr></table></figure>
<p>注意！数组可以作为函数的参数却不允许作为函数返回值，若想返回数组只有将返回的数组作为参数传入。函数可以嵌套调用，也可以递归调用。</p>
<h1 id="八、指针"><a href="#八、指针" class="headerlink" title="八、指针"></a>八、指针</h1><p>C语言中用指针来表示内存地址，它是一个unsigned类型的整数，若这个内存地址恰好是某个变量的地址，则称这个指针指向该变量，变量的地址一般指它占用的字节中第一个字节的地址。在变量前加上取地址运算符&amp;即可得到变量的地址。</p>
<h2 id="1-指针变量"><a href="#1-指针变量" class="headerlink" title="1. 指针变量"></a>1. 指针变量</h2><p>指针变量用来存放指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义和初始化</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span>* p=&amp;a;  <span class="comment">//C++写法，地址是赋值给p而不是*p的，*是类型的一部分。</span></span><br><span class="line"><span class="keyword">int</span> *p1=&amp;b,p2;  <span class="comment">//C写法</span></span><br><span class="line"><span class="keyword">int</span> *q1,*q2,*q3; <span class="comment">//基类型(int)必须和指针变量存储的地址类型相同。</span></span><br><span class="line"><span class="keyword">char</span>* str=<span class="string">"I love china!"</span>;</span><br><span class="line">*(str+<span class="number">1</span>);  <span class="comment">//获得str+1位置的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,a+n);  <span class="comment">//输出包括a+n位置及后面所有字符的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line">*p;  <span class="comment">//获得变量a的值，对*p的操作等同于对a操作。 </span></span><br><span class="line">p+<span class="number">1</span>;  <span class="comment">//p所指的int型变量的下一个int型变量地址，跨越了一整个Int型(4Byte)。</span></span><br><span class="line">p++,p--;</span><br><span class="line">p1-p2;  <span class="comment">//2个指针之间相差的Int型变量的个数。</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>注意！若指针不进行初始化则指向的地址是随机的，而且很可能随机指向系统工作区，那么就会出错。</font></p>
<h2 id="2-使用指针变量作为函数参数"><a href="#2-使用指针变量作为函数参数" class="headerlink" title="2. 使用指针变量作为函数参数"></a>2. 使用指针变量作为函数参数</h2><p>使用指针变量作为函数参数时，在函数内部对指针变量(形参)本身进行修改并不能使传入的指针变量(实参)改变，因为传入的指针变量相当于传入一个副本，能够使实参改变的只能是该函数中对指针指向的数据进行的修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* m, <span class="keyword">int</span>* n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=*m;</span><br><span class="line">    *m=*n;</span><br><span class="line">    *n=temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(p,p1);</span><br></pre></td></tr></table></figure>

<h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h2><p>引用(&amp;，区分取地址符)可以不使用指针，也能达到修改传入参数的目的，且引用不产生副本，而是给<font color=Crmison>原变量(而不是常量，常量不可使用引用)</font>起了个别名，故旧名字与新名字指向同一个东西，对引用变量的操作就是对原变量的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>;</span><br><span class="line">func(p2);</span><br></pre></td></tr></table></figure>
<p>指针的引用：通过将指针的引用作为形参，从而达到将传入的地址交换以交换两个变量的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* &amp;m, <span class="keyword">int</span>* &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp=m;</span><br><span class="line">    m=n;</span><br><span class="line">    n=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(p,p1);   <span class="comment">//swap(&amp;p,&amp;p1)写法错误，因为&amp;p,&amp;p1为常量，而常量不可使用引用。</span></span><br></pre></td></tr></table></figure>

<h1 id="九、结构体-struct-的使用"><a href="#九、结构体-struct-的使用" class="headerlink" title="九、结构体(struct)的使用"></a>九、结构体(struct)的使用</h1><p>需要将一些相关的变量放在一起存储时，需要用到结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span> &#123;</span></span><br><span class="line">    <span class="comment">//一些基本的数据结构或自定义的数据类型。</span></span><br><span class="line">&#125;结构体变量名;</span><br></pre></td></tr></table></figure>

<h2 id="1-结构体的定义"><a href="#1-结构体的定义" class="headerlink" title="1. 结构体的定义"></a>1. 结构体的定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> major[<span class="number">20</span>];</span><br><span class="line">    StudentInfo* next;  <span class="comment">//结构体内不能定义自己，会引起循环定义问题，但可以定义自身类型的指针变量，它可以定义除自身外的任何数据类型。注意！结构体指针变量不能在匿名结构体内定义。</span></span><br><span class="line">&#125;Alice,stu[<span class="number">1000</span>];  <span class="comment">//直接定义结构体变量</span></span><br><span class="line"></span><br><span class="line">StudentInfo Bob,*p;</span><br></pre></td></tr></table></figure>

<h2 id="2-访问结构体内的元素"><a href="#2-访问结构体内的元素" class="headerlink" title="2. 访问结构体内的元素"></a>2. 访问结构体内的元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stu[<span class="number">0</span>].id;</span><br><span class="line">stu[<span class="number">0</span>].gender;</span><br><span class="line"></span><br><span class="line">(*p).id;</span><br><span class="line">(*p).name;</span><br><span class="line">(*p).next;</span><br><span class="line"></span><br><span class="line">p-&gt;id;</span><br><span class="line">p-&gt;name;</span><br><span class="line">p-&gt;next;</span><br></pre></td></tr></table></figure>

<h2 id="3-结构体的初始化和赋值"><a href="#3-结构体的初始化和赋值" class="headerlink" title="3. 结构体的初始化和赋值"></a>3. 结构体的初始化和赋值</h2><p>结构体使用构造函数来进行初始化，对于一个普通定义的结构体，其内部会生成一个<font color=Crmison>默认构造函数(但不可见)</font>，如studentInfo(){}，正是由于默认构造函数的存在才可以直接定义结构体变量而不进行初始化，因为它没有让用户提供任何初始化参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    StudentInfo(<span class="keyword">int</span> _id, <span class="keyword">char</span> _gender)&#123;   <span class="comment">//自定义构造函数</span></span><br><span class="line">        id=_id;</span><br><span class="line">        gender=_gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StudentInfo(<span class="keyword">int</span> _id, <span class="keyword">char</span> _gender): id(_id), gender(_gender) &#123;&#125;   <span class="comment">//构造函数的简化写法</span></span><br><span class="line">&#125;stu[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="string">'M'</span>,<span class="number">2</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line"></span><br><span class="line">StudentInfo stu = StudentInfo(<span class="number">10086</span>,<span class="string">'M'</span>);   <span class="comment">//初始化结构体</span></span><br><span class="line">stu[<span class="number">2</span>]=stu;  <span class="comment">//C++中相同类型结构体之间可以直接赋值，而C语言中不可以。</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>注意！若自定义了构造函数而不想进行初始化，则需要手动添加默认构造函数。</font>只要参数和类型不完全相同，就可以定义任意多个构造函数，以适应不同的初始化场合。</p>
<h2 id="4-共用体"><a href="#4-共用体" class="headerlink" title="4. 共用体"></a>4. 共用体</h2><p>共用体可定义在结构体内部，用于建立有不同类型数据组成的组合型的数据结构。原则上，共用体的大小取决于占据最多内存的成员的长度，但会受到最宽基本类型成员大小的影响。即:共用体的总大小为共用体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> MyUnion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> chs[<span class="number">11</span>];</span><br><span class="line">&#125;u = &#123; <span class="number">10</span> &#125;, u2 = &#123;.chs=<span class="string">"niko"</span>&#125;;   <span class="comment">// 初始化;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> MyUnion mu = &#123; <span class="number">1</span> &#125;;  <span class="comment">// 默认初始化第一个成员</span></span><br><span class="line"><span class="keyword">union</span> MyUnion mu2 = &#123; .chs = <span class="string">"hello"</span> &#125;;  <span class="comment">// 指定要初始化的成员</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>C/C++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基本语法</title>
    <url>/2020/04/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、Java应用程序的结构"><a href="#一、Java应用程序的结构" class="headerlink" title="一、Java应用程序的结构"></a>一、Java应用程序的结构</h1><h2 id="1-程序的组成"><a href="#1-程序的组成" class="headerlink" title="1. 程序的组成"></a>1. 程序的组成</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  <span class="comment">//要运行java程序，必须有一个main方法，public和static的位置可以互换，但其它部分位置固定</span></span><br><span class="line">    System.out.println(<span class="string">"We will not use 'Hello, World!"</span><span class="string">');</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>java区分大小写；</li>
<li>public关键字为访问修饰符，用于控制程序的其他部分对这段代码的访问级別；</li>
<li>关键字 class 表明 Java 程序中的全部内容都包含在类中；</li>
<li>class 后面紧跟类名，名字必须以字母开头，后面可以跟字母和数字的任意组合，采用驼峰命名法，不能使用java保留字；</li>
<li><font color=Crmison>源代码的文件名必须与public类的名字相同，并用 .java 作为扩展名。源文件可以包含多个类定义，但最多只能包含一个public类定义。可以没有public类定义，此时文件名可随意。</font></li>
<li><font color=Crmison>成功编译后会得到一个包含这个类字节码的文件。Java 编译器将字节码文件自动地命名为 ClassName. class, 并与源文件存储在同一个目录下。</font></li>
<li>运行已编译的程序时，Java 虚拟机将从指定类中的 main 方法开始执行,故<font color=Crmison>在类的源文件中必须包含一个 main方法。</font></li>
<li><font color-Crmison>在 Java SE 1.4 及以后的版本中<font color=Crmison>强制 main方法是 public 的。</font></li>
<li>Java 中的 <font color=Crmison>main 方法必须是静态static的。</font></li>
<li>在 Java 中，每个句子必须用分号结束。特别需要说明，回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。</li>
</ul>
<h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*比较长的一段话，注意不能嵌套*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*多行注释，可自动生成文档。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="二、8种基本数据类型"><a href="#二、8种基本数据类型" class="headerlink" title="二、8种基本数据类型"></a>二、8种基本数据类型</h1><p>4种整型，2种浮点型，1种用于表示 Unicode 编码的字符单元的字符类型 char和 1 种用于表示真值的 boolean 类型。</p>
<h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><p><img src="Java%E6%95%B4%E5%9E%8B.png" alt="Java整型"></p>
<ul>
<li><font color=Crmison>int：</font>10<sup>9</sup>以内；</li>
<li><font color=Crmison>long：</font>10<sup>10</sup>——10<sup>18</sup>，数值有一个后缀L或l；</li>
<li>二进制从Java7开始，要加上前缀0b或0B；八进制加前缀0(容易混淆数值，不推荐)；十六进制加前缀0x或0X；</li>
<li>从Java7开始还可以为数字字面量加下划线让程序更易读，Java编译器会去除这些下划线。如1_000_000或0b1111_0100_0010_0200_0000。</li>
<li><font color=Crmison>Java中所有的数值类型所占据的字节数量与平台无关</font>，而C和C++会随着平台改变而改变。</li>
<li><font color=Crmison>注意!Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。</font></li>
</ul>
<h2 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a>2. 浮点型</h2><h3 id="2-1-两种浮点类型"><a href="#2-1-两种浮点类型" class="headerlink" title="2.1 两种浮点类型"></a>2.1 两种浮点类型</h3><p><img src="%E6%B5%AE%E7%82%B9%E5%9E%8B.png" alt="浮点型"></p>
<ul>
<li>float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。</li>
<li>也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。</li>
<li>绝大部分应用程序都采用 double 类型。在很多情况下，float 类型的精度很难满足需求。</li>
<li><font color=Crmison>可以使用十六进制表示浮点数值。</font>例如，0.125=2<sup>—3</sup>可以表示成 0xl.0p-3。在十六进制表示法中， 使用 p 表示指数， 而不是 e。 注意， 尾数采用十六进制，指数采用十进制。指数的基数是 2。</li>
</ul>
<h3 id="2-2-浮点型的计算"><a href="#2-2-浮点型的计算" class="headerlink" title="2.2 浮点型的计算"></a>2.2 浮点型的计算</h3><ul>
<li>所有的浮点数值计算都遵循 IEEE 754 规范。</li>
<li>三个特殊浮点值表示溢出和出错情况：<br>  <font color=Crmison>正无穷大(常量 <code>Double.POSITIVE_INFINITY</code>或<code>Flocat.POSITIVE_INFINITY</code>)</font><br>  <font color=Crmison>负无穷大(<code>Double.NEGATIVE_INFINITY</code>或<code>Float.NEGATIVE_INFINITY</code>)</font><br>  <font color=Crmison>NaN(非数值，<code>Double.NaN</code>或<code>Float.NaN</code>):注意！所有非数值都认为是不相同的。</font>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = Double.NaN) <span class="comment">// is never true 错误判断方法</span></span><br><span class="line"><span class="keyword">if</span> (Double.isNaN(x)) <span class="comment">// check whether x is "not a number" 正确判断方法</span></span><br></pre></td></tr></table></figure></li>
<li>浮点数值采用二进制系统表示，故无法精确表示1/10，如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal类</li>
</ul>
<h2 id="3-Unicode编码与字符编码表"><a href="#3-Unicode编码与字符编码表" class="headerlink" title="3. Unicode编码与字符编码表"></a>3. Unicode编码与字符编码表</h2><p>设计 Unicode 编码的目的是将世界不同地区的不同编码标准如美国的 ASCII、 西欧语言中的ISO 8859-1 俄罗斯的 KOI-8、 中国的 GB 18030 和 BIG-5 等统一起来，起初Unicode是固定的16位，而经过一段时间的发展，Unicode 字符超过了 65 536 个，其主要原因是增加了大量的汉语、 日语和韩语中的表意文字。为了解决这个问题，设计了不同的变长编码方式，如UTF-8和UTF-16，要理解这两种编码方式，必须首先理解Unicode码点等含义。<br><font color=Crmison>码点：</font>是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中，码点采用 <font color=Crmison>U+十六进制</font> 书写,Unicode 的码点可以分成 17 个代码级别，从U+10000 到 U+10FFFF。<br><font color=Crmison>基本的多语言级别：</font>码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；<br><font color=Crmison>辅助字符级别：</font>其余的 16个级别的码点从 U+10000 到 U+10FFFF , 其中包括一些辅助字符。</p>
<h3 id="3-1-UTF-16字符编码表"><a href="#3-1-UTF-16字符编码表" class="headerlink" title="3.1 UTF-16字符编码表"></a>3.1 UTF-16字符编码表</h3><p>UTF-16 编码采用不同长度(2字节和4字节)的编码表示所有 Unicode 码点。在基本的多语言级别中，每个字符用 16 位表示，通常被称为<font color=Crmison>代码单元</font>; 而辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的 2048 字节内， 通常被称为替代区域，其中 U+D800 ~ U+DBFF 用于第一个代码单元，U+DC00 ~ U+DFFF 用于第二个代码单元，而这些替代区域Unicode规定不对应与任何字符。这样设计十分巧妙，我们可以从中迅速地知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。参见<a href="https://zh.wikipedia.org/wiki/UTF-16#从U+0000至U+D7FF以及从U+E000至U+FFFF的码位" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/UTF-16#从U+0000至U+D7FF以及从U+E000至U+FFFF的码位</a><br><font color=Crmison>UTF-16编码算法：</font></p>
<ul>
<li>码位减去 0x10000，得到的值的范围为20比特长的 0…0xFFFFF。</li>
<li>高位的10比特的值（值的范围为 0…0x3FF）被加上 0xD800 得到第一个码元或称作高位代理，值的范围是 0xD800…0xDBFF。由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理。</li>
<li>低位的10比特的值（值的范围也是 0…0x3FF）被加上 0xDC00 得到第二个码元或称作低位代理，现在值的范围是 0xDC00…0xDFFF。由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理。</li>
</ul>
<p><font color=Crmison>UTF-16编码示例：</font><br><img src="UTF-16.png" alt="UTF-16编码示例"></p>
<h3 id="3-2-UTF-8字符编码表"><a href="#3-2-UTF-8字符编码表" class="headerlink" title="3.2 UTF-8字符编码表"></a>3.2 UTF-8字符编码表</h3><p>UTF-8编码也采用不同字节编码所有Unicode码点(1字节-6字节)参见<a href="https://zhuanlan.zhihu.com/p/72254734" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72254734</a><br><font color=Crmison>UTF-16编码规则表：</font><br><img src="UTF-8.png" alt="UTF-8编码规则表"><br><font color=Crmison>UTF-16编码示例：</font><br>汉字「吕」的 Unicode 编码是 U+5415，对应二进制为 0101010000010101，总共有 15 位。因为两字节最多表示 11 位，三字节最多表示 16 位，所以使用三字节编码。对应二进制拆成（从低位到高位）三部分，分别是 0101, 010000, 010101，再拼上编码前缀得到 11100101, 10010000, 10010101，对应十六进制为 0xe5, 0x90, 0x95，这就是汉字「吕」的 UTF-8 编码。</p>
<h2 id="4-char类型"><a href="#4-char类型" class="headerlink" title="4. char类型"></a>4. char类型</h2><ul>
<li>char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。</li>
<li>char 类型的字面量值要用单引号括起来。</li>
<li>char 类型的值可以用转义序列\u和十六进制值表示，其范围从 \u0000 到 \uffff。</li>
<li>除了转义序列 \u 之外， 还有一些用于表示特殊字符的转义序列：<br><img src="%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97.png" alt="转义序列"></li>
<li>所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\02122’ 或 “Hello\n”。转义序列 \u还可以出现在加引号的字符常量或字符串之外（<font color=Crmison>而其他所有转义序列不可以</font>。</li>
<li><font color=Crmison>Unicode 转义序列会在解析代码之前得到处理。</font><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\u005B\ u00SD args)</span></span>;  <span class="comment">//\u005B 和 \u005D 是 [ 和 ] 的编码。</span></span><br><span class="line"><span class="string">"\u0022+\u0022"</span>;   <span class="comment">//""+""  即空串</span></span><br><span class="line"><span class="comment">// \u00A0 is a newline   </span></span><br><span class="line"><span class="comment">//\u00A0为换行符，故会产生一个语法错误</span></span><br><span class="line"><span class="comment">// Look inside c:\users   </span></span><br><span class="line"><span class="comment">//也会产生一个语法错误， 因为 \u 后面并未跟着 4 个十六进制数。</span></span><br></pre></td></tr></table></figure>
<h2 id="5-boolean类型"><a href="#5-boolean类型" class="headerlink" title="5. boolean类型"></a>5. boolean类型</h2>boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件。<font color=Crmison>要注意！整型值和布尔值之间不能进行相互转换。</font></li>
</ul>
<h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><h2 id="1-变量的声明"><a href="#1-变量的声明" class="headerlink" title="1. 变量的声明"></a>1. 变量的声明</h2><ol>
<li>变量名必须是一个以字母开头并由字母或数字构成的序列。</li>
<li>需要注意，与大多数程序设计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括 ‘A’ ~ ‘Z’、 ‘a’ ~ ‘z’、或在某种语言中表示字母的任何 Unicode 字符。</li>
<li>但 V 和 ‘©’这样的符号不能出现在变量名中，空格也不行。可以使用 Character 类的<code>isJavaldentifierStart</code> 和 <code>isJavaldentifierPart</code> 方法来检查哪些 Unicode 字符属于 Java 中的“ 字母”。</li>
<li>另外， 不能使用 Java 保留字作为变量名。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j; <span class="comment">//不提倡</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b; <span class="comment">//提倡，可读性强</span></span><br><span class="line">Box box;</span><br><span class="line">Box aBox;</span><br></pre></td></tr></table></figure>

<h2 id="2-变量的初始化"><a href="#2-变量的初始化" class="headerlink" title="2. 变量的初始化"></a>2. 变量的初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> vacationDays;  <span class="comment">//声明一个变量之后，必须用赋值语句对变量进行显式初始化,否则不能使用</span></span><br><span class="line">vacationDays=<span class="number">12</span>;  <span class="comment">//可以将变量的声明和初始化放在同一行中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 Java 中可以将声明放在代码中的任何地方,但应尽可能地靠近变量第一次使用的地方。</span></span><br><span class="line"><span class="keyword">int</span> vacationDays = <span class="number">12</span>;       <span class="comment">//在 Java 中， 不区分变量的声明与定义。</span></span><br></pre></td></tr></table></figure>
<h2 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> CM_PER_INCH = <span class="number">2.54</span>; <span class="comment">//关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类常量的定义位于 main 方法的外部。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> CM_PER_INCH = <span class="number">2.54</span>; <span class="comment">//使用关键字 static final 可设置一个类常量,可使其在一个类中的多个方法中使用</span></span><br><span class="line">                                            <span class="comment">//如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量，ClassName.常量名。</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>const 是 Java 保留的关键字，但目前并没有使用。</font></p>
<h1 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h1><p><code>+ - * / %</code>加、减、乘、除、取余数</p>
<ol>
<li><font color=Crmison>需要注意， 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。</font></li>
<li>在默认情况下， 虚拟机设计者允许对中间计算结果采用扩展的精度。但是， 对于使用 <code>strictfp</code> 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。</li>
<li>如果将一个类标记为strictfp, 这个类中的所有方法都要使用严格的浮点计算。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-数学函数与数学常量"><a href="#1-数学函数与数学常量" class="headerlink" title="1. 数学函数与数学常量"></a>1. 数学函数与数学常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;  <span class="comment">//静态导入Math包后，就不需要使用 Math.方法名 来调用了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决负整数取余数问题的方法,n%2=-1，若n为负整数</span></span><br><span class="line">floorMod(position+adjustment,<span class="number">12</span>);  <span class="comment">//（对于负除数，floorMod 会得到负数结果，不过这种情况在实际中很少出现。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三角函数方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span>  <span class="title">sin</span><span class="params">(<span class="keyword">double</span> a )</span> ： 返回角的三角正弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> a)</span>  ： 返回角的三角余弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span>  a)</span>  ： 返回角的三角正切</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> a)</span> : 返回角的反正弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> a)</span>  : 返回角的反余弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> a)</span>  ： 返回角的反正切</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">toRadians</span><span class="params">(<span class="keyword">double</span> a)</span> : 将角转换为弧度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  doueble <span class="title">toDegrees</span><span class="params">(<span class="keyword">double</span> a)</span> : 将弧度转化为角</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//指数函数方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> a)</span> : 用于获取e的a次方；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> a)</span> : 即lna</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> a)</span> : 即log10a</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a )</span>:用于取a的平方根；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">cbrt</span><span class="params">(<span class="keyword">double</span> a)</span> : 用于取a的立方根；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> : 用于求a的b次方；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//取整函数方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span>：返回大于等于a的整数值，返回值类型为<span class="keyword">double</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span> : 返回小于等于a的整数值，返回值类型为<span class="keyword">double</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rint</span><span class="params">(<span class="keyword">double</span> a)</span> : 返回与a最接近的整数值，返回值类型为<span class="keyword">double</span>；（如果两个同为整数且同样接近，选取偶数值的那个）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">( )</span>:返回带正号的 <span class="keyword">double</span> 值，该值大于等于 0.0 且小于 1.0。</span></span><br><span class="line"><span class="function"><span class="comment">//四舍五入函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a )</span>: 其值等于Math.<span class="title">floor</span><span class="params">(a + <span class="number">0.5</span>)</span>，返回值类型为<span class="keyword">long</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">float</span> a )</span>: 其值等于Math.<span class="title">floor</span><span class="params">(a + <span class="number">0.5</span>)</span>，返回值类型为<span class="keyword">int</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求绝对值运算和最值运算，这里的类型就是double，float，int和long类型</span></span><br><span class="line"><span class="keyword">static</span> 类型 abs(类型); 返回对应类型的绝对值</span><br><span class="line"><span class="keyword">static</span> 类型 max(类型<span class="number">1</span>,类型<span class="number">2</span>); 返回对应类型的最大值</span><br><span class="line"><span class="keyword">static</span> 类型 min(类型<span class="number">1</span>,类型<span class="number">2</span>); 返回对应类型的最小值</span><br></pre></td></tr></table></figure>

<h2 id="2-数值类型之间的合法自动转换"><a href="#2-数值类型之间的合法自动转换" class="headerlink" title="2. 数值类型之间的合法自动转换"></a>2. 数值类型之间的合法自动转换</h2><p><img src="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="类型转换"><br>其中6个实心箭头，表示无信息丢失的转换；有 3 个虚箭头，表示可能有精度损失的转换。当进行二元操作时，会将两个操作数自动转换为同一种类型，再进行计算，转换规则为：</p>
<ul>
<li>如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。</li>
<li>否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。</li>
<li>否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 </li>
<li>否则， 两个操作数都将被转换为 int 类型。</li>
</ul>
<h2 id="3-强制类型转换cast"><a href="#3-强制类型转换cast" class="headerlink" title="3. 强制类型转换cast"></a>3. 强制类型转换cast</h2><p>当存在信息丢失的可能时，需要进行强制类型转换才可以，比如long—&gt;int,强制类型转换会进行截断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(目标类型)变量; <span class="comment">//不要在 boolean 类型与任何数值类型之间进行强制类型转换， 这样可以防止发生错误。</span></span><br><span class="line">b?<span class="number">1</span>:<span class="number">0</span>;   <span class="comment">//极少情况下使用</span></span><br></pre></td></tr></table></figure>

<h2 id="4-结合赋值运算符"><a href="#4-结合赋值运算符" class="headerlink" title="4. 结合赋值运算符"></a>4. 结合赋值运算符</h2><p><code>+= -= *= /= %=</code><br><code>%</code>:<font color=Crmison>取模运算，结果的符号和被除数符号一致</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x += <span class="number">3.5</span>; <span class="comment">//等价 (int)(x+3.5) 运算符得到一个值， 其类型与左侧操作数的类型不同，就会发生强制类型转换。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-自增与自减运算符"><a href="#5-自增与自减运算符" class="headerlink" title="5. 自增与自减运算符"></a>5. 自增与自减运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">12</span>;</span><br><span class="line">n++;    <span class="comment">//由于这些运算符会改变变量的值，所以它们的操作数不能是数值。</span></span><br><span class="line">n--     <span class="comment">//不推荐使用++,容易产生bug。</span></span><br><span class="line">++n;</span><br><span class="line">--n;</span><br></pre></td></tr></table></figure>

<h2 id="6-关系运算符和boolean运算符"><a href="#6-关系运算符和boolean运算符" class="headerlink" title="6. 关系运算符和boolean运算符"></a>6. 关系运算符和boolean运算符</h2><ul>
<li>关系运算符：<br><code>== != &lt; &gt; &lt;= &gt;=</code></li>
<li>boolean运算符:<br><code>&amp;&amp; || ! ?:</code></li>
</ul>
<h2 id="7-位运算符"><a href="#7-位运算符" class="headerlink" title="7. 位运算符"></a>7. 位运算符</h2><p><code>&amp; | ^(异或) ~ &lt;&lt;(左移) &gt;&gt;(右移)</code></p>
<ol>
<li>利用 &amp; 并结合使用适当的 2 的幂， 可以把其他位掩掉， 而只保留其中的某一位。</li>
<li><font color=Crmison><code>&gt;&gt;&gt;</code> 运算符会用 0 填充高位，这与<code>&gt;&gt;</code>不同，它会用符号位填充高位。不存在<code>&lt;&lt;&lt;</code>运算符。</font></li>
<li><font color=Crmison>移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作数模 64 )。</font></li>
<li>C/C++中<code>&gt;&gt;</code>对于负数生成的结果可能会依赖于具体的实现。Java 则消除了这种不确定性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(n &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&lt;&lt;<span class="number">35</span>;  <span class="comment">//等价8或者1&lt;&lt;3</span></span><br></pre></td></tr></table></figure>

<h2 id="8-括号与运算符的优先级"><a href="#8-括号与运算符的优先级" class="headerlink" title="8. 括号与运算符的优先级"></a>8. 括号与运算符的优先级</h2><p><img src="%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A71.png" alt="运算符优先级1"><br><img src="%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A72.png" alt="运算符优先级2"></p>
<h2 id="9-枚举类型"><a href="#9-枚举类型" class="headerlink" title="9. 枚举类型"></a>9. 枚举类型</h2><p>用于变量的取值只在一个有限的集合内的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;; <span class="comment">//定义枚举类型</span></span><br><span class="line">Size s = Size.MEDIUM; <span class="comment">//声明变量，只能存储Size中给定的枚举值或null值，null 表示这个变量没有设置任何值。</span></span><br></pre></td></tr></table></figure>

<h1 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h1><blockquote>
<p>Java 字符串就是 Unicode 字符序列。<br>Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。<br>每个用双引号括起来的字符串都是 String类的一个实例。<br><font color=Crmison>String 类对象为不可变字符串，不能修改字符串中的任一字符，但是可以修改整个字符串变量，让它引用另外一个字符串。</font><br>字符串存放在一个公共存储池(堆)中，字符串变量指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同的字符。即：编译器可以让字符串共享。<br><font color=Crmison>Java 将自动地进行垃圾回收。 如果修改字符串变量后之前的字符串所占的一块内存不再使用了， 系统最终会将其回收。</font></p>
</blockquote>
<h2 id="1-String中的各种字符串操作"><a href="#1-String中的各种字符串操作" class="headerlink" title="1. String中的各种字符串操作"></a>1. String中的各种字符串操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting = <span class="string">"Hello"</span>;</span><br><span class="line">String expletive = <span class="string">"Expletive"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串 substring方法</span></span><br><span class="line">String s = greeting.substring(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">//"Hel"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接 +</span></span><br><span class="line">String message = expletive + greeting; <span class="comment">//当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串（任何一个 Java 对象都可以转换成字符串）。</span></span><br><span class="line">nt age = <span class="number">13</span>;</span><br><span class="line">String rating = <span class="string">"PC"</span> + age;   <span class="comment">//PG13</span></span><br><span class="line">System.out.println(<span class="string">"The answer is "</span> + answer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//join方法：把多个字符串放在一起， 用一个定界符分隔</span></span><br><span class="line">String all = String.join(<span class="string">" / "</span>, <span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>);  <span class="comment">//"S / H / L / XL"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改字符串变量，达到修改字符的效果</span></span><br><span class="line">greeting = greeting.substring(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">"p!"</span>; <span class="comment">//共享享带来的高效率远远胜过于提取、 拼接字符串所带来的低效率。因为对字符串进行的操作往往只是比较。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测字符串是否相等</span></span><br><span class="line">s.equals(t); </span><br><span class="line"><span class="string">"Hello"</span>.equals(greeting);</span><br><span class="line"><span class="string">"Hello"</span>.equalsIgnoreCase(<span class="string">"hel1o"</span>);   <span class="comment">//判断是否相等而不区分大小写</span></span><br><span class="line"><span class="keyword">if</span> (greeting.compareTo(<span class="string">"Hel1o"</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测字符串是否放置在同一个位置上</span></span><br><span class="line">greeting == <span class="string">"Hello"</span>;  <span class="comment">//可能正确也可能错误，因为实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = greeting.length(); <span class="comment">//返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。</span></span><br><span class="line"><span class="keyword">int</span> cpCount = greeting.codePointCount(<span class="number">0</span>, greeting.length()); <span class="comment">//得到实际的长度，即码点数量</span></span><br><span class="line"></span><br><span class="line">s.charAt(n); <span class="comment">//返回位置 n 的代码单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = greeting.offsetByCodePoints(<span class="number">0</span>, i);   <span class="comment">//得到第 i 个码点</span></span><br><span class="line"><span class="keyword">int</span> cp = greeting.codePointAt(index);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字符串的码点</span></span><br><span class="line"><span class="keyword">int</span>[] codePoints = str.codePointsO.toArray();</span><br><span class="line"><span class="comment">//把一个码点数组转换为一个字符串</span></span><br><span class="line">String str = <span class="keyword">new</span> String(codePoints, <span class="number">0</span>, codePoints.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个新字符串。 这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。</span></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个新字符串。这个字符串用 newString 代替原始字符串中所有的 oldString。可以用 String 或 StringBuilder 对象作为 CharSequence 参数。</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">( CharSequence oldString,CharSequence newString)</span></span></span><br></pre></td></tr></table></figure>
<p>Java 中的 String类包含了 50 多个方法。详参<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p>
<h2 id="2-空串与null串"><a href="#2-空串与null串" class="headerlink" title="2. 空串与null串"></a>2. 空串与null串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String e = <span class="string">""</span>; <span class="comment">// 空串,它是长度为0的字符串，有自己的内容(空)</span></span><br><span class="line">String str=<span class="keyword">null</span>; <span class="comment">//这表示目前没有任何对象与该变量关联</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>)  <span class="comment">//检查一个字符串是否为 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() != <span class="number">0</span>) <span class="comment">//检查一个字符串既不是 null 也不为空串，注意！首先要检查 str 不为 null。因为如果在一个 mill 值上调用方法， 会出现错误。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-使用StringBuilder类构建字符串"><a href="#3-使用StringBuilder类构建字符串" class="headerlink" title="3. 使用StringBuilder类构建字符串"></a>3. 使用StringBuilder类构建字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(ch); <span class="comment">// appends a single character</span></span><br><span class="line">bui1der.append(str); <span class="comment">// appends a string</span></span><br><span class="line">String completedString = builder.toString();</span><br></pre></td></tr></table></figure>
<ol>
<li>StringBuffer是StringBuilder的前身，其效率稍有些低， 但允许采用<font color=Crmison>多线程的方式</font>执行添加或删除字符的操作。</li>
<li>如果所有字符串在一个<font color=Crmison>单线程中编辑 （通常都是这样)，</font>则应该用 StringBuilder 替代它。</li>
</ol>
<h1 id="六、输入输出"><a href="#六、输入输出" class="headerlink" title="六、输入输出"></a>六、输入输出</h1><h2 id="1-读取输入"><a href="#1-读取输入" class="headerlink" title="1. 读取输入"></a>1. 读取输入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//当使用的类不是定义在基本java.lang 包中时，一定要使用import指示字将相应的包加载进来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Scanner 类的各种方法实现输入</span></span><br><span class="line">String name = in.nextLine();   <span class="comment">//nextLine()可读入空白符</span></span><br><span class="line">String firstName = in.next();  <span class="comment">//以空白符结束</span></span><br><span class="line"><span class="keyword">int</span> age = in.nextlnt();   <span class="comment">//读取一个整数</span></span><br><span class="line"><span class="keyword">double</span> num = nextDouble();  <span class="comment">//读取一个浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">( )</span> <span class="comment">//检测输人中是否还有其他单词。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//检测是否还有表示整数或浮点数的下一个字符序列。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNextDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用Console类从控制台读取密码</span></span></span><br><span class="line"><span class="function">Console cons </span>= System.console();</span><br><span class="line">String username = cons.readLine(<span class="string">"User name: "</span>)；</span><br><span class="line"><span class="keyword">char</span>[] passwd = cons.readPassword(<span class="string">"Password:"</span>);  <span class="comment">//为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示字符串 prompt 并且读取用户输入，直到输入行结束。args 参数可以用来提供输人格式。有关这部分内容将在下一节中介绍。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[] readPassword(String prompt, Object...args)</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readLine</span><span class="params">(String prompt, Object...args)</span></span></span><br></pre></td></tr></table></figure>
<p>采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有能够读取一个单词或一个数值的方法。</p>
<h2 id="2-格式化输出"><a href="#2-格式化输出" class="headerlink" title="2. 格式化输出"></a>2. 格式化输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">10000.0</span> / <span class="number">3.0</span>;</span><br><span class="line">System.out.print(x);</span><br><span class="line">System.out.printf(<span class="string">"%8.2f"</span>, x); <span class="comment">//Java SE5.0沿用了C中的printf方法用于对输出进行各种格式控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出</span></span><br><span class="line">String message = String.format(<span class="string">"Hello, %s. Next year, you'll be %d"</span>, name , age);</span><br></pre></td></tr></table></figure>
<p><img src="printf%E8%BD%AC%E6%8D%A2%E7%AC%A6.png" alt="printf转换符"><br>还可以在printf中给出控制格式化输出的各种标志:<br><img src="printf%E6%A0%87%E5%BF%97.png" alt="printf标志"><br>printf方法中日期与时间的格式化选项，格式包括两个字母， 以 t 开始， 以表中的任意字母结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%tc"</span>, <span class="keyword">new</span> Date());  <span class="comment">//打印当前完整的日期和时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用格式化的参数索引</span></span><br><span class="line">System.out.printf(<span class="string">"l$s %2$tB %2$te, %2$tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> DateQ);  <span class="comment">//%1$表示对第1个参数格式化， Due date: February 9, 2015</span></span><br><span class="line">System.out .printf(<span class="string">"%s %tB %&lt;te, %&lt;tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> DateO); <span class="comment">//&lt; 示前而格式说明中的参数将被再次使用</span></span><br></pre></td></tr></table></figure>
<p><img src="%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.png" alt="日期和时间"><br><img src="%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B41.png" alt="日期和时间"><br>以上有关printf方法中日期与时间的格式化选项已过时，新代码应使用java.time 包中的方法。<br>printf格式说明符的语法图：<br><img src="printf%E8%AF%AD%E6%B3%95.png" alt="printf语法"><br><font color=Crmison>许多格式化规则是本地环境特有的。例如，在德国，组分隔符是句号而不是逗号，Monday 被格式化为 Montag,java可以控制控制应用的国际化行为。</font></p>
<h2 id="3-文件输入与输出"><a href="#3-文件输入与输出" class="headerlink" title="3. 文件输入与输出"></a>3. 文件输入与输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若读取文件时不设置字符编码，则会使用运行该java程序的默认编码，若在不同的机器上运行可能会有不同的表现</span></span><br><span class="line"><span class="comment">//可使用Scannner的任意方法对文件进行读取</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">"myfile.txt"</span>), <span class="string">"UTF-8"</span>); <span class="comment">//如果文件名中包含反斜杠符号，需要在每个反斜杠之前再加一个额外的反斜杠：“ c:\\mydirectory\\myfile.txt ”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line"><span class="comment">//可以像输出到 System.out—样使用 print、 println 以及 printf命令。</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"myfile.txt"</span>, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p><font color=Crmison>如果用一个不存在的文件构造一个Scanner,或者用一个不能被创建的文件名构造一个PrintWriter,那么就会发生异常。Java 编译器认为这些异常比“被零除”异常更严重。</font></p>
<h1 id="七、控制流程"><a href="#七、控制流程" class="headerlink" title="七、控制流程"></a>七、控制流程</h1><h2 id="1-块作用域"><a href="#1-块作用域" class="headerlink" title="1. 块作用域"></a>1. 块作用域</h2><ol>
<li>块，即复合语句，是由一对大括号括起来的若干条简单的 Java 语句。</li>
<li>一个块可以嵌套在另一个块中。</li>
<li>但是，<font color=Crmison>不能在嵌套的两个块中声明同名的变量，否则无法通过编译。</font></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2. 条件语句"></a>2. 条件语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition1)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition3)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(condition);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x = <span class="number">0</span>; x != <span class="number">10</span>; x += <span class="number">0</span> .<span class="number">1</span>) <span class="comment">//由于浮点数的舍入误差，该循环永远不可能结束</span></span><br></pre></td></tr></table></figure>

<h2 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4. switch语句"></a>4. switch语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (choice) &#123;   <span class="comment">//case标签范围：类型为 char、byte、 short 或 int 的常量表达式。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">//枚举常量。</span></span><br><span class="line">        ...         <span class="comment">//从 Java SE 7开始， case 标签还可以是字符串字面量。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Size sz = . . .;</span><br><span class="line"><span class="keyword">switch</span> (sz) &#123;</span><br><span class="line">    <span class="keyword">case</span> SMALL: <span class="comment">// 无需使用Size.SMALL</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-中断控制流程语句"><a href="#5-中断控制流程语句" class="headerlink" title="5. 中断控制流程语句"></a>5. 中断控制流程语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不带标签的break语句，用于跳出当前循环</span></span><br><span class="line"><span class="keyword">while</span>(c)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带标签的break语句，用于跳出多重嵌套的循环语句,也可以应用到任何语句中。</span></span><br><span class="line"><span class="comment">//标签必须放在希望跳出的最外层循环之前， 并且必须紧跟一个冒号。</span></span><br><span class="line">read_data:</span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span> read_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">label:</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(condition) <span class="keyword">break</span> label;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continue语句跳过本次循环剩余部分，进入下一次循环</span></span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、大数值"><a href="#八、大数值" class="headerlink" title="八、大数值"></a>八、大数值</h1><p>Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算，类提供的方法参见java文档<a href="https://docs.oracle.com/javase/8/docs/api/。" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/。</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.*</span><br><span class="line"></span><br><span class="line">Biglnteger a = Biglnteger.valueOf(<span class="number">100</span>); <span class="comment">//将普通的数值转换为大数值</span></span><br><span class="line">Biglnteger c = a.add(b); <span class="comment">// c = a + b</span></span><br><span class="line">Biglnteger d = c.multiply(b.add(Biglnteger.valueOf(<span class="number">2</span>))); <span class="comment">// d = c * (b + 2) 大数值不能使用 + 和 *</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>与 C++ 不同， Java 没有提供运算符重载功能。 程序员无法重定义 <code>+</code> 和 <code>*</code> 运算符，虽然为字符串的连接重栽了<code>+</code> 运算符，但没有重载其他的运算符。</font></p>
<h1 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h1><h2 id="1-数组的创建-初始化-匿名数组"><a href="#1-数组的创建-初始化-匿名数组" class="headerlink" title="1. 数组的创建/初始化/匿名数组"></a>1. 数组的创建/初始化/匿名数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];  <span class="comment">//也可用int a[];声明数组，但是不推荐，创建一个数字数组则所有元素会被初始化为0</span></span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">100</span>]; <span class="comment">//元素初始化为 false</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">10</span>]; <span class="comment">//对象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> actualSize = . . .;</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[actualSize];   <span class="comment">//Java允许在运行时确定数组的大小。</span></span><br><span class="line"></span><br><span class="line">a.length; <span class="comment">//获取数组中元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] smallPrimes = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125;; <span class="comment">//创建数组的同时进行初始化</span></span><br><span class="line">small Primes = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;;  <span class="comment">//匿名数组初始化，可以在不创建新变量的情况下重新初始化一个数组</span></span><br><span class="line"><span class="keyword">new</span> elementType[<span class="number">0</span>];  <span class="comment">//创建一个长度为 0 的数组,与null不同。</span></span><br></pre></td></tr></table></figure>
<p>如果经常需要在运行过程中扩展数组的大小， 应该使用数组列表（array list)。</p>
<h2 id="2-数组的for-each循环"><a href="#2-数组的for-each循环" class="headerlink" title="2. 数组的for each循环"></a>2. 数组的for each循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> element : a)</span><br><span class="line">    System.out.println(element);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(a));  <span class="comment">//以[2,3,5,7,11,13]方式打印数组</span></span><br></pre></td></tr></table></figure>

<h2 id="3-数组拷贝"><a href="#3-数组拷贝" class="headerlink" title="3. 数组拷贝"></a>3. 数组拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] luckyNumbers = smallPrimes;  <span class="comment">//将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组</span></span><br><span class="line">luckyNumbers[<span class="number">5</span>] = <span class="number">12</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果数组元素是数值型，那么多余的元素将被赋值为 0 ; </span></span><br><span class="line"><span class="comment">//如果数组元素是布尔型，则将赋值为 false。</span></span><br><span class="line"><span class="comment">//相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</span></span><br><span class="line"><span class="keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length*<span class="number">2</span>); <span class="comment">//将一个数组的所有值拷贝到一个新的数组中去,第二个参数为新数组大小，该方法常用来增加数组大小</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>java中没有指针运算，不能通过 a+1 得到数组的下一个元素。[]被预定义为检查数组边界。</font></p>
<h2 id="4-命令行参数"><a href="#4-命令行参数" class="headerlink" title="4. 命令行参数"></a>4. 命令行参数</h2><p>main函数中的String[] args表明main 方法将接收一个字符串数组， 也就是命令行参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在命令行输入命令可读入内容到args数组中,程序名并没有存储在 args 数组中</span></span><br><span class="line">java Message -g cruel world   <span class="comment">//args[0]:"-g"  args[l]:"cruel"  args[2]:"cruel" "world"</span></span><br></pre></td></tr></table></figure>

<h2 id="4-数组排序"><a href="#4-数组排序" class="headerlink" title="4. 数组排序"></a>4. 数组排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(type[] a)</span> <span class="comment">//类型为 int、long、short、 char、 byte、boolean、float 或 double 的数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> type <span class="title">copyOf</span><span class="params">(type[]a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> type <span class="title">copyOfRange</span><span class="params">(type[]a , <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(type[] a)</span> <span class="comment">//采用优化的快速排序算法对数组进行排序。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[]a , type v)</span>    <span class="comment">//采用二分搜索算法查找值 v</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[]a, <span class="keyword">int</span> start, <span class="keyword">int</span> end, type v)</span>  <span class="comment">//类型为 int、 long、 short、 char、 byte、 boolean 、 float 或 double 的有序数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(type[]a , type v)</span> <span class="comment">//将数组的所有数据元素值设置为 V</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(type[]a, type[]b)</span> <span class="comment">//如果两个数组大小相同， 并且下标相同的元素都对应相等， 返回 true。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="5-多维数组"><a href="#5-多维数组" class="headerlink" title="5. 多维数组"></a>5. 多维数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">double</span>[][] balances = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>[][] magicSquare = &#123; &#123;<span class="number">16</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">13</span>&#125;， &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">8</span>&#125;, (<span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>&#125;, &#123;<span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span>[] row : a)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> value : row)</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速打印</span></span><br><span class="line">System.out.println(Arrays.deepToString(a)); <span class="comment">//输出[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换二维数组中的两行</span></span><br><span class="line"><span class="keyword">double</span>[] temp = balances[i];</span><br><span class="line">balances[i] = balances[i + <span class="number">1</span>];</span><br><span class="line">balances[i + <span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure>

<h2 id="6-不规则数组"><a href="#6-不规则数组" class="headerlink" title="6. 不规则数组"></a>6. 不规则数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先分配一个具有所含行数的数组</span></span><br><span class="line"><span class="keyword">int</span>[][] odds = <span class="keyword">new</span> <span class="keyword">int</span>[NMAX + <span class="number">1</span>][];</span><br><span class="line"><span class="comment">//接下来，分配这些行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= NMAX ; n++)</span><br><span class="line">    odds[n] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的对象与类</title>
    <url>/2020/04/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<p>Java 是完全面向对象(OOP)的，而面向对象更加适用于解决规模较大的问题。</p>
<h1 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h1><h2 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h2><p><strong>类</strong>：类是构造对象的模板或蓝图，由类<strong>构造对象</strong>的过程称为<strong>创建类的实例</strong>。<br><strong>封装</strong>: 从形式上看，封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。<br><strong>实例域</strong>：对象中的数据。<br><strong>方法</strong>：操纵数据的过程。<br><strong>状态</strong>：对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。<br>并不是所有的类都具有面向对象特征，例如Math类只封装了功能，它不需要也不必隐藏数据。</p>
<h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h2><p>三个主要特征：</p>
<ol>
<li>对象的行为（behavior)—可以对对象施加哪些操作，或可以对对象施加哪些方法。 </li>
<li>对象的状态（state )—对象状态的改变必须通过调用方法实现，否则会破坏封装性。 </li>
<li>对象标识（identity )—每个对象都有一个唯一的身份。</li>
</ol>
<p>对象与对象变量的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date deadline;  <span class="comment">//变量deadline不是一个对象， 实际上也没有引用对象,因此还不能将任何 Date 方法应用于这个变量上。</span></span><br><span class="line">deadline = <span class="keyword">new</span> Date();   <span class="comment">//一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</span></span><br><span class="line">                        <span class="comment">//表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 deadline 中。</span></span><br><span class="line">Date birthday = <span class="keyword">new</span> Date();</span><br><span class="line">deadline = birthday;   </span><br><span class="line"></span><br><span class="line">deadline = <span class="keyword">null</span>;  <span class="comment">//显式地将对象变量设置为 null,表明这个对象变量目前没有引用任何对象。该对象不能使用任何方法。</span></span><br><span class="line">                <span class="comment">//局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。</span></span><br></pre></td></tr></table></figure>


<h2 id="3-类之间的关系"><a href="#3-类之间的关系" class="headerlink" title="3. 类之间的关系"></a>3. 类之间的关系</h2><ol>
<li>依赖（“uses-a”）:一个类的方法操纵另一个类的对象，即一个类依赖于另一个类。又称为<font color=Crmison>耦合度</font>，实际开发中应让这种耦合最小。</li>
<li>聚合（“has-a”） :类 A 的对象包含类 B 的对象。</li>
<li>继承（“is-a”）:用于表示特殊与一般关系。如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。</li>
</ol>
<p>表示关系的UML符号：<br><img src="UML.png" alt="UML"></p>
<h1 id="二、使用预定义类"><a href="#二、使用预定义类" class="headerlink" title="二、使用预定义类"></a>二、使用预定义类</h1><h2 id="1-Java类库中的LocalDate类"><a href="#1-Java类库中的LocalDate类" class="headerlink" title="1. Java类库中的LocalDate类"></a>1. Java类库中的LocalDate类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Local Date.now(); <span class="comment">//使用类中的静态工厂方法</span></span><br><span class="line">LocalDate.of(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>); <span class="comment">//提供年、 月和日来构造对应一个特定日期的对象：</span></span><br><span class="line"></span><br><span class="line">LocalDate newYearsEve = Local Date.of(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>); <span class="comment">//将构造的对象保存在一个对象变量中供再次使用。</span></span><br><span class="line">LocalDate aThousandDaysLater = newYearsEve.plusDays(<span class="number">1000</span>); <span class="comment">//得到距当前对象指定天数的一个新日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function">LocalDate <span class="title">minusDays</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//生成当前日期之后或之前 n 天的日期。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMonthValue</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDayOfMonth</span><span class="params">( )</span> <span class="comment">//得到当前日期的年、 月和日。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">DayOfWeek getDayOfWeek</span>; <span class="comment">//得到当前日期是星期几， 作为 DayOfWeek 类的一个实例返回。 调用 getValue 来得到1 ~ 7 之间的一个数， 表示这是星期几， 1 表示星期一， 7 表示星期日。</span></span><br></pre></td></tr></table></figure>
<h2 id="2-CregorianCalendar类"><a href="#2-CregorianCalendar类" class="headerlink" title="2. CregorianCalendar类"></a>2. CregorianCalendar类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CregorianCalendar someDay = <span class="keyword">new</span> CregorianCalendar(<span class="number">1999</span>, <span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">someDay.add(Calendar.DAY_0F_M0NTH, <span class="number">1000</span>);  <span class="comment">//更改器方法</span></span><br><span class="line">year = someDay.get(Calendar.YEAR); <span class="comment">//访问器方法</span></span><br><span class="line">month = someDay.get(Calendar.MONTH)+ <span class="number">1</span>; </span><br><span class="line">day = someDay.get(Ca1endar.DAY_0F_M0NTH);</span><br></pre></td></tr></table></figure>

<h1 id="三、用户自定义类"><a href="#三、用户自定义类" class="headerlink" title="三、用户自定义类"></a>三、用户自定义类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//私有数据域</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">  <span class="keyword">private</span> Local Date hireDay;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器与类同名</span></span><br><span class="line"><span class="comment">//构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的，否则会产生编译错误。</span></span><br><span class="line"><span class="comment">//每个类可以有一个以上的构造器</span></span><br><span class="line"><span class="comment">//构造器可以有 0 个、1 个或多个参数，没有返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span> <span class="params">(String n , <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month , <span class="keyword">int</span> day)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    salary = s;</span><br><span class="line">    hireDay = Local Date,of(year, month, day);   <span class="comment">//注意， 不要在构造器中定义与实例域重名的局部变量。否则实例域会被覆盖从而使构造器失效。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//域访问器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Local Date <span class="title">getHireDay</span><span class="params">()</span> <span class="comment">//注意不要编写返回引用可变对象的访问器方法。否则会破坏封装性，由第三方改变类中的私有状态。该方法就违反了这个设计原则</span></span></span><br><span class="line"><span class="function"></span>&#123;                               <span class="comment">//如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone )。</span></span><br><span class="line">    <span class="comment">//return hireDay;</span></span><br><span class="line">    <span class="keyword">return</span> (Date)hireDay.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//域更改器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span>   <span class="comment">//raiseSalary 方法有两个参数。 第一个参数称为隐式参数， 是出现在方法名前的Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;  <span class="comment">//关键字 this 表示隐式参数</span></span><br><span class="line"> salary += raise;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-多个源文件的使用"><a href="#1-多个源文件的使用" class="headerlink" title="1. 多个源文件的使用"></a>1. 多个源文件的使用</h2><p>在开发中习惯于将每一个类存在一个单独的源文件中，这时既可以显式编译也可以隐式编译。当 Java 编译器发现 EmployeeTest.java 使用 Employee 类时会查找名为 Employee.class 的文件。如果没有找到这个文件， 就会自动地搜索 Employee.java, 然后，对它进行编译。如果 Employee,java 版本较已有的 Employee.class 文件版本新，Java 编译器就会自动地重新编译这个文件。</p>
<h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h2><p>封装一个类一般提供下面三项内容：</p>
<ol>
<li>私有的数据域；</li>
<li>公有的域访问器方法；</li>
<li>一个公有的域更改器方法。</li>
</ol>
<h2 id="3-基于类的访问权限"><a href="#3-基于类的访问权限" class="headerlink" title="3. 基于类的访问权限"></a>3. 基于类的访问权限</h2><p><font color=Crmison>类中的方法可以访问所属类对象的私有特性, 而不仅限于访问隐式参数的私有特性。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-私有方法"><a href="#4-私有方法" class="headerlink" title="4. 私有方法"></a>4. 私有方法</h2><p>绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。有些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密， 或者需要一个特别的协议以及一个特别的调用次序。在 Java 中，为了实现一个私有的方法， 只需将关键字 public 改为 private 即可。只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方法是公有的， 就不能将其删去，因为其他的代码很可能依赖它。</p>
<h2 id="5-final-实例域"><a href="#5-final-实例域" class="headerlink" title="5. final 实例域"></a>5. final 实例域</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类）。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">//必须确保在每一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于可变的类， 使用 final 修饰符可能会对读者造成混乱</span></span><br><span class="line">    <span class="comment">//final 关键字只是表示存储在 evaluations 变量中的对象引用不会再指示其他 StringBuilder对象。不过这个对象可以更改。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringBuiIcier evaluations;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、静态域与静态方法"><a href="#四、静态域与静态方法" class="headerlink" title="四、静态域与静态方法"></a>四、静态域与静态方法</h1><h2 id="1-静态域"><a href="#1-静态域" class="headerlink" title="1. 静态域"></a>1. 静态域</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextld = <span class="number">1</span>;  <span class="comment">//如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="2. 静态常量"></a>2. 静态常量</h2><p>静态变量使用得比较少，但静态常量却使用得比较多。静态常量可以被设置为public，因为final常量不允许被修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out = . . .; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h2><p>使用静态方法的两种情况：</p>
<ol>
<li>一 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow)。</li>
<li>一个方法只需要访问类的静态域。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法不能访问实例域， 因为它不能操作对象。但是，静态方法可以访问自身类中的静态域</span></span><br><span class="line"><span class="comment">//可以认为静态方法是没有 this 参数的方法。</span></span><br><span class="line"><span class="comment">//可以使用对象调用静态方法但没必要。因为静态方法与对象实例域毫无关系。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextId; <span class="comment">// returns static field  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类名调用该方法</span></span><br><span class="line"><span class="keyword">int</span> n = Employee.getNextld();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color=Crmison>如果一个域是静态的基本数据类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化的值就是null。static关键字不能应用于局部变量，因此它只能作用于域。</font></p>
</blockquote>
<h2 id="4-工厂方法"><a href="#4-工厂方法" class="headerlink" title="4. 工厂方法"></a>4. 工厂方法</h2><p>工厂方法是静态方法的另一种常见用途，类似 LocalDate 和 NumberFormat 的类使用静态工厂方法来构造对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NumberFormat currencyFormatter = NumberFormat.getCurrencylnstance();</span><br><span class="line">NumberFormat percentFormatter = NumberFormat.getPercentlnstance()；</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.1</span>;</span><br><span class="line">System.out.println(currencyFormatter.format(x)); <span class="comment">// prints $O.10</span></span><br><span class="line">System.out.println(percentFomatter.format(x)); <span class="comment">// prints 10%</span></span><br></pre></td></tr></table></figure>
<p>使用工厂方法的两个原因：</p>
<ol>
<li>无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例和百分比实例采用不用的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而 Factory 方法将返回一个 DecimalFormat类对象，这是 NumberFormat 的子类。</li>
</ol>
<h2 id="5-main方法"><a href="#5-main方法" class="headerlink" title="5. main方法"></a>5. main方法</h2><ol>
<li>main方法也是一种静态方法，不能操作所在类的实例域。静态的main 方法将执行并创建程序所需要的对象。</li>
<li>每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。可独立的对类进行测试。</li>
</ol>
<h1 id="五、方法参数"><a href="#五、方法参数" class="headerlink" title="五、方法参数"></a>五、方法参数</h1><ol>
<li><strong>按值调用</strong>：表示方法接收的是调用者提供的值，即形参为实参的一个拷贝，对形参的修改不能改变实参的值。</li>
<li><strong>按引用调用</strong>：表示方法接收的是调用者提供的变量地址。</li>
<li>Java 总是采用<font color=Crmison>按值调用</font>，方法不能修改传递给它的任何参数变量的内容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripieValue</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// doesn't work</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x = <span class="number">3</span> * x;      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;  </span><br><span class="line">tripieValue(percent);    <span class="comment">//一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span> <span class="params">(Employee x)</span> <span class="comment">// works</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x.raiseSa1ary(<span class="number">200</span>);  </span><br><span class="line">&#125;</span><br><span class="line">harry = <span class="keyword">new</span> Employee(. . .);</span><br><span class="line">tripleSalary(harry);     <span class="comment">//一个方法可以改变一个对象参数的状态。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x , Employee y)</span> <span class="comment">// doesn't work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee temp = x; </span><br><span class="line">    x = y; </span><br><span class="line">    y = temp;        <span class="comment">//一个方法不能让对象参数引用一个新的对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、对象构造"><a href="#六、对象构造" class="headerlink" title="六、对象构造"></a>六、对象构造</h1><h2 id="1-重载"><a href="#1-重载" class="headerlink" title="1. 重载"></a>1. 重载</h2><ol>
<li><strong>方法签名</strong>：要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名。返回类型不是方法签名的一部分。</li>
<li><strong>重载</strong>：多个方法有相同的名字、 不同的参数，便产生了重载。不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。</li>
<li><strong>重载解析</strong>:通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误。</li>
</ol>
<h2 id="2-默认域初始化"><a href="#2-默认域初始化" class="headerlink" title="2. 默认域初始化"></a>2. 默认域初始化</h2><ol>
<li>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。</li>
<li><font color=Crmison>域与局部变量不同，</font>必须明确地初始化方法中的局部变量。</li>
</ol>
<h2 id="3-无参数的构造器"><a href="#3-无参数的构造器" class="headerlink" title="3. 无参数的构造器"></a>3. 无参数的构造器</h2><ol>
<li>如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。</li>
<li>如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。此时必须显式提供一个不带参数的构造器才可以将所有的实例域设置为默认值。</li>
</ol>
<h2 id="4-显式域初始化"><a href="#4-显式域初始化" class="headerlink" title="4. 显式域初始化"></a>4. 显式域初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始值为常量值，用在当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时。</span></span><br><span class="line">    <span class="comment">//在执行构造器之前，先执行赋值操作。</span></span><br><span class="line">    <span class="keyword">private</span> String name =<span class="string">""</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始值不一定是常量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;  <span class="comment">//静态域在类加载时即被加载且未被赋初值的会被赋予默认值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用初始化块</span></span><br><span class="line">    <span class="comment">//在一个类的声明中，可以包含多个代码块</span></span><br><span class="line">    <span class="comment">//首先运行初始化块，然后才运行构造器的主体部分。</span></span><br><span class="line">    <span class="comment">//不常见</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextld;</span><br><span class="line">        nextld++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类第一次加载的时候， 将会进行静态域的初始化</span></span><br><span class="line">    <span class="comment">//所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">        nextld = generator.nextInt(lOOOO); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 Java SE 7 以后，java 程序首先会检查是否有一个 main 方法。</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Hel1o, World"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>域初始化的顺序很复杂，调用构造器的具体处理步骤：</p>
<ol>
<li>初始化父类中的静态成员变量和静态代码块 ； </li>
<li>初始化子类中的静态成员变量和静态代码块 ； </li>
<li>初始化父类的普通成员变量和代码块，再执行父类的构造方法；</li>
<li>初始化子类的普通成员变量和代码块，再执行子类的构造方法；</li>
</ol>
<h2 id="5-参数名"><a href="#5-参数名" class="headerlink" title="5. 参数名"></a>5. 参数名</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String aNaie, <span class="keyword">double</span> aSalary)</span> </span>&#123;</span><br><span class="line">    name = aName ;</span><br><span class="line">    salary = aSalary; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String naie, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>,sal ary = salary; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-利用this调用同一个类中的另一个构造器"><a href="#6-利用this调用同一个类中的另一个构造器" class="headerlink" title="6. 利用this调用同一个类中的另一个构造器"></a>6. 利用this调用同一个类中的另一个构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可有效减少代码重复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123; <span class="comment">// calls Employee(String, double)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Employee #"</span> + nextld, s);</span><br><span class="line">    nextld++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、包"><a href="#七、包" class="headerlink" title="七、包"></a>七、包</h1><p>使用包的主要原因是确保类名的唯一性，而不会产生冲突。</p>
<h2 id="1-类的导入"><a href="#1-类的导入" class="headerlink" title="1. 类的导入"></a>1. 类的导入</h2><p>一个类可以使用所属包中的所有类， 以及其他包中的公有类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.time.LocalDate today = java.tine.LocalDate.now();  <span class="comment">//繁琐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//import 语句应该位于源文件的顶部(但位于 package 语句的后面)。</span></span><br><span class="line"><span class="comment">//只能使用星号（*) 导入一个包， 而不能使用 import java.* 或import java.*.* 导入以 java 为前缀的所有包。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">LocalDate today = Local Date.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时若在程序直接使用 Date 类的时候， 就会出现一个编译错误，因为二者均包含Date类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可明确指出使用哪个包中的Date</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若两个Date均需要使用应添加上完整包名</span></span><br><span class="line">java.util.Date deadline = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">java.sql.Date today = <span class="keyword">new</span> java.sql.Date(...);</span><br></pre></td></tr></table></figure>
<h2 id="2-静态导入"><a href="#2-静态导入" class="headerlink" title="2. 静态导入"></a>2. 静态导入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line">out.println(<span class="string">"Goodbye, World!"</span>); <span class="comment">// System.out</span></span><br><span class="line">exit(<span class="number">0</span>); <span class="comment">//System.exit</span></span><br></pre></td></tr></table></figure>

<h2 id="3-将类放入包中"><a href="#3-将类放入包中" class="headerlink" title="3. 将类放入包中"></a>3. 将类放入包中</h2><p>如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包(没有名字)中。<br><img src="%E5%8C%85%E7%9B%AE%E5%BD%95.png" alt="包目录"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstmann.corejava;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line">javac PackageTest.java</span><br><span class="line">javac com/horstmann/corejava/Employee.java</span><br></pre></td></tr></table></figure>
<p><font color=Crmison>编译器在编译源文件的时候不检查目录结构。</font>如果源文件不在指定package中且不依赖于其他包， 就不会出现编译错误。但是， 最终的程序将无法运行，因为虚拟机找不到类。</p>
<h2 id="4-包作用域"><a href="#4-包作用域" class="headerlink" title="4. 包作用域"></a>4. 包作用域</h2><ol>
<li>标记为 public 的部分可以被任意的类使用；</li>
<li>标记为 private 的部分只能被定义它们的类使用。</li>
<li>如果没有指定 public 或 private , 这个部分（类、方法或变量）可以被同一个包中的所有方法访问。</li>
</ol>
<h1 id="八、类路径"><a href="#八、类路径" class="headerlink" title="八、类路径"></a>八、类路径</h1><p>类路径是所有包含类文件的路径的集合。<br>类路径包含三种情况：</p>
<ol>
<li>基目录 /home/user/classdir 或 c:\classes</li>
<li>当前目录 (.); </li>
<li>JAR 文件 /home/user/archives/archive.jar 或c:\archives\archive.jar</li>
</ol>
<p>类路径所列出的目录和归档文件是搜寻类的起始点。</p>
<h2 id="1-虚拟机搜寻类文件的过程"><a href="#1-虚拟机搜寻类文件的过程" class="headerlink" title="1. 虚拟机搜寻类文件的过程"></a>1. 虚拟机搜寻类文件的过程</h2><ol>
<li>首先要查看存储在 jre/lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。</li>
<li>若找不到相应类文件，再查看类路径。</li>
</ol>
<blockquote>
<p>/home/user/classdir/com/horstmann/corejava/Employee.class<br>com/horstmann/corejava/Employee.class 从当前目录开始<br>com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</p>
</blockquote>
<h2 id="2-编译器搜寻类文件的过程"><a href="#2-编译器搜寻类文件的过程" class="headerlink" title="2. 编译器搜寻类文件的过程"></a>2. 编译器搜寻类文件的过程</h2><ol>
<li>如果引用了一个类，而没有指出这个类所在的包， 那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。</li>
<li>如果找到了一个以上的类， 就会产生编译错误。</li>
<li>编译器还要查看源文件是否比类文件新，如果是这样的话，那么源文件就会被自动地重新编译。</li>
</ol>
<h2 id="3-设置类路径"><a href="#3-设置类路径" class="headerlink" title="3. 设置类路径"></a>3. 设置类路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用 -classpath (或 -cp) 选项指定类路径</span></span><br><span class="line">java -classpath /home/user/dassdir: .:/home/user/archives/archive.jar HyProg</span><br><span class="line">java -classpath c:\classdir; .;c:\archives\archive.jar MyProg</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 CLASSPATH 环境变量</span></span><br><span class="line">export CLASSPATH=/home/user/classdir:.:/ home/user/archives/archive.jar  <span class="comment">//Bourne Again shell ( bash)</span></span><br><span class="line">set CLASSPATH=c:\classdir;.;c:\archives\archive.jar <span class="comment">//Windows shell</span></span><br></pre></td></tr></table></figure>

<h1 id="九、文档注释"><a href="#九、文档注释" class="headerlink" title="九、文档注释"></a>九、文档注释</h1><p>利用JDK中的javadoc命令工具，可以由源文件生成一个 HTML 注释(/** */)文档。文档注释与源代码在同一个文件中，在修改源代码的同时， 重新运行 javadoc 就可以轻而易举地保持两者的一致性。</p>
<h2 id="1-注释的插入"><a href="#1-注释的插入" class="headerlink" title="1. 注释的插入"></a>1. 注释的插入</h2><p>javadoc抽取信息生成文档的位置如下，也应当在这些位置编写注释：</p>
<ol>
<li>包 </li>
<li>公有类与接口</li>
<li>公有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ol>
<p>文档注释的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自由格式文本：标记如<span class="doctag">@author</span>或 <span class="doctag">@param</span>等</span></span><br><span class="line"><span class="comment">* 第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽取出来形成概要页。</span></span><br><span class="line"><span class="comment">* 在自由格式文本中，可以使用 HTML 修饰符，如&lt;em&gt;&lt;/em&gt;等</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-类注释"><a href="#2-类注释" class="headerlink" title="2. 类注释"></a>2. 类注释</h2><p>类注释必须放在 import 语句之后，类定义之前。</p>
<h2 id="3-方法注释"><a href="#3-方法注释" class="headerlink" title="3. 方法注释"></a>3. 方法注释</h2><p>每一个方法注释必须放在所描述的方法之前。可以使用以下标记：<br><code>@param</code>:对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。<br><code>@return</code>:这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。<br><code>©throws</code>:这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。</p>
<h2 id="4-域注释"><a href="#4-域注释" class="headerlink" title="4. 域注释"></a>4. 域注释</h2><p>只需要对公有域（通常指的是静态常量）建立文档。</p>
<h2 id="5-通用注释"><a href="#5-通用注释" class="headerlink" title="5. 通用注释"></a>5. 通用注释</h2><p>用于类文档的注释中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 姓名</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@deprecated</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@see</span> 引用   <span class="doctag">@see</span> com.horstraann.corejava.Employee#raiseSalary(double) </span></span><br><span class="line"><span class="comment">            <span class="doctag">@see</span> &lt;a href="m«w.horstmann . com/corejava. htinl "&gt;The Core ]ava home page&lt;/a&gt;</span></span><br><span class="line"><span class="comment">            Isee "Core Java 2 volume 2n</span></span><br><span class="line"><span class="comment">&#123;<span class="doctag">@link</span> package.class#feature label &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-包与概述注释"><a href="#6-包与概述注释" class="headerlink" title="6. 包与概述注释"></a>6. 包与概述注释</h2><p>要想产生包注释，就需要在每一个包目录中添加一个单独的文件。有两种方式添加：</p>
<ol>
<li>提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;—&lt;/body&gt; 之间的所有文本都会被抽取出来。</li>
<li>提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** 和 */ 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。</li>
</ol>
<p>还可以为所有的源文件提供一个概述性的注释。名为overview,html 的文件中，这个文件位于包含所有源文件的父目录中。标记&lt;body&gt;—&lt;/body&gt;间的所有文本将被抽取出来。</p>
<h2 id="7-注释的抽取"><a href="#7-注释的抽取" class="headerlink" title="7. 注释的抽取"></a>7. 注释的抽取</h2><p>详见<a href="http://docs.oracle.com/javase/8/docs/guides/javadoc" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/guides/javadoc</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//docDirectory为HTML文件的存放目录</span></span><br><span class="line"><span class="number">1</span>. 切换到包含想要生成文档的源文件目录。</span><br><span class="line"><span class="number">2</span>. javadoc -d docDirectory nameOfPackage   <span class="comment">//如果省略了 -d docDirectory 选项， 那 HTML 文件就会被提取到当前目录下。</span></span><br><span class="line"><span class="number">3</span>. javadoc -d docDirectory nameOfPackage1 nameOfPackage2 . . .</span><br><span class="line"><span class="number">4</span>. javadoc -d docDirectory *.java  <span class="comment">//文件在默认包中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用 -author 和 -version 选项在文档中包含@author 和@version 标记（默认情况下，这些标记会被省略)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用-link为标准类添加超链接</span></span><br><span class="line">javadoc -link http:<span class="comment">//docs.oracle.eom/:javase/8/docs/api *.java  //所有的标准类库类都会自动地链接到 Oracle 网站的文档。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 -linksource 选项，则每个源文件被转换为 HTML (不对代码着色，但包含行编号) 并且每个类和方法名将转变为指向源代码的超链接。</span></span><br></pre></td></tr></table></figure>

<h1 id="十、类设计技巧"><a href="#十、类设计技巧" class="headerlink" title="十、类设计技巧"></a>十、类设计技巧</h1><ol>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型</li>
<li>不是所有的域都需要独立的域访问器和域更改器</li>
<li>将职责过多的类进行分解</li>
<li>类名和方法名要能够体现它们的职责</li>
<li>优先使用不可变的类</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的继承</title>
    <url>/2020/05/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="一、类、超类和子类"><a href="#一、类、超类和子类" class="headerlink" title="一、类、超类和子类"></a>一、类、超类和子类</h1><h2 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="1. 定义子类"></a>1. 定义子类</h2><p>已存在的类称为超类、基类或父类; 新类称为子类、派生类或孩子类。在设计类时，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> //在 <span class="title">Java</span> 中， 所有的继承都是公有继承</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//定义子类特有数据域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义子类特有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;  <span class="comment">//属于 Employee 类的对象不能使用该方法，但Manager 类自动地继承了超类 Employee 中的方法。</span></span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus; </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖超类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();  <span class="comment">//子类不能直接访问超类的私有域，应通过关键字super调用超类的域访问器来访问。</span></span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。</span></span><br><span class="line">        <span class="comment">//如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器， 则 Java 编译器将报告错误。</span></span><br><span class="line">        <span class="comment">//调用构造器的语句只能作为另一个构造器的第一条语句出现。</span></span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);  <span class="comment">//通过 super调用超类构造器实现对超类私有域进行初始化</span></span><br><span class="line">        bonus = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Manager boss = <span class="keyword">new</span> Manager(<span class="string">"Carl Cracker"</span> , <span class="number">80000</span>, <span class="number">1987</span>, <span class="number">12</span> , <span class="number">15</span>);</span><br><span class="line">boss.setBonus(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;  <span class="comment">//变量 staff[0] 与 boss 引用同一个对象。但编译器将 staff[0]看成 Employee 对象。故staff[0]不能调用子类特有方法setBonus()</span></span><br><span class="line">staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, <span class="number">50000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">"Tony Tester"</span> , <span class="number">40000</span>, <span class="number">1990</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Employee e : staff)         <span class="comment">//e 既可以引用 Employee 类型的对象，也可以引用 Manager 类型的对象。</span></span><br><span class="line">    System.out.println(e.getName() + <span class="string">" "</span> + e.getSalary());  <span class="comment">//虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。</span></span><br></pre></td></tr></table></figure>
<ol>
<li>super关键字与this引用不同，它不是一个对象引用，它表示的是当前对象的当前类的父类对象。</li>
<li>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。</li>
<li>在覆盖方法时， 一定要保证返回类型的兼容性。<font color=Crmison>允许子类将覆盖方法的返回类型定义为原返回类型的子类型。</font>称该方法具有<strong>可协变的返回类型</strong></li>
<li><font color=Crmison>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</font> </li>
<li><font color=Crmison>子类对象引用调用的方法始终都是实例化的子类中的重写方法，只有明确调用了super.xxx关键词或者是子类中没有该方法时，才会去调用父类相同的同名方法。</font></li>
</ol>
<blockquote>
<p><strong>多态</strong>：一个对象变量可以指示多种实际类型的现象被称为多态。<br><strong>动态绑定</strong>：在<strong>运行时</strong>能够自动地选择调用哪个方法的现象称为动态绑定。<br><strong>静态绑定</strong>：如果是 private 方法、 static 方法、 final 方法或者构造器， 那么<strong>编译器</strong>将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定。</p>
</blockquote>
<h2 id="2-继承层次"><a href="#2-继承层次" class="headerlink" title="2. 继承层次"></a>2. 继承层次</h2><p><strong>继承层次</strong>：由一个公共超类派生出来的所有类的集合被称为继承层次。<br><strong>继承链</strong>：从某个特定的类到其祖先的路径被称为该类的继承链。<br><font color=Crmison>Java 不支持多继承(extends)。</font></p>
<h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h2><ol>
<li>即超类变量既可以引用一个超类对象， 也可以引用一个超类的任何一个子类的对象。</li>
<li>不能将一个超类的引用赋给子类变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 Java 中，子类数组的引用可以转换成超类数组的引用， 而不需要采用强制类型转换。</span></span><br><span class="line">Manager[] managers = <span class="keyword">new</span> Manager[<span class="number">10</span>];</span><br><span class="line">Employee[] staff = managers; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有数组都要牢记创建它们的元素类型， 并负责监督仅将类型兼容的引用存储到数组中。</span></span><br><span class="line"><span class="comment">//这里使用 new managers[10] 创建的数组是一个经理数组。如果试图存储一个 Employee 类型的引用就会引发 ArrayStoreException 异常。</span></span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, . . .); <span class="comment">//ArrayStoreException 异常</span></span><br></pre></td></tr></table></figure>

<h2 id="4-理解方法调用"><a href="#4-理解方法调用" class="headerlink" title="4. 理解方法调用"></a>4. 理解方法调用</h2><p>x.f(param)调用过程：</p>
<ol>
<li>编译器査看对象的声明类型和方法名。编译器将会一一列举所有x所声明类中名为f的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）。</li>
<li>编译器进行重载解析。以获得需要调用的方法名字和参数类型。</li>
<li>编译器采用静态绑定或动态绑定方式生成一条调用f(param)的指令。</li>
<li>当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x <strong>所引用对象的实际类型</strong>最合适的那个类的方法。若没有则在其超类中寻找。</li>
</ol>
<p>虚拟机预先为每个类创建了一个方法表, 其中列出了所有方法(包括继承的方法)的签名和实际调用的方法。这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。</p>
<h2 id="5-阻止继承：final-类和方法"><a href="#5-阻止继承：final-类和方法" class="headerlink" title="5. 阻止继承：final 类和方法"></a>5. 阻止继承：final 类和方法</h2><p>不允许扩展的类被称为 final 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Executive</span> <span class="keyword">extends</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  <span class="comment">//final方法不能被覆盖</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-强制类型转换"><a href="#6-强制类型转换" class="headerlink" title="6. 强制类型转换"></a>6. 强制类型转换</h2><p>将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检査。但是只有引用子类变量的超类引用可以被强制类型转换为子类引用。一般只有在会使用到 Manager 中特有的方法时才需要进行类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能在继承层次内进行类型转换。 </span></span><br><span class="line"><span class="comment">//在将超类转换成子类之前，应该使用instanceof进行检查。</span></span><br><span class="line">Manager boss = (Manager)staff[<span class="number">0</span>];   <span class="comment">//ok</span></span><br><span class="line">Manager boss = (Manager)staff[<span class="number">1</span>]; <span class="comment">// Error  //若未捕获ClassCastException 异常，程序就会终止执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager) </span><br><span class="line">&#123;</span><br><span class="line">    boss = (Manager)staff[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x <span class="keyword">instanceof</span> C  <span class="comment">//若x为null则不会产生异常只是返回false。</span></span><br></pre></td></tr></table></figure>

<h2 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7. 抽象类"></a>7. 抽象类</h2><p>抽象类一般作为派生其他类的基类，而不作为想使用的特定的实例类。通常它只包含一些通用的属性和方法，而这些通用方法往往只是一个定义不需要具体的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用abstract关键字修饰方法就无需实现该方法</span></span><br><span class="line"><span class="comment">//包含一个或多个抽象方法的类本身必须被声明为抽象的。</span></span><br><span class="line"><span class="comment">//抽象类的子类也可以为抽象类</span></span><br><span class="line"><span class="comment">//类即使不含抽象方法，也可以将类声明为抽象类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;  <span class="comment">//抽象类不能有函数体</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不能被实例化。可以定义一个抽象类的对象变量，但是不能构造抽象类对象，它只能引用非抽象子类的对象。</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student(<span class="string">"Vinee Vu"</span> , <span class="string">"Economics"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="8-受保护访问"><a href="#8-受保护访问" class="headerlink" title="8. 受保护访问"></a>8. 受保护访问</h2><ol>
<li>由于类中的私有域对所有其他类包括子类都是不可见的，因此若子类的方法想访问超类的某个域或方法，可将超类中的方法或域声明为protected。但子类方法中只能访问属于该类的对象的protected方法而不能访问其它子类对象的受保护方法。</li>
<li>不过<font color=Crmison>子类中的方法只能够访问子类对象中继承的超类的受保护域，而不能访问超类对象中的这个域，如此可避免滥用受保护机制。</font></li>
<li>在实际应用中，要谨慎使用 <strong>protected 属性</strong>。因为有可能会违背OOP提倡的数据封装原则。</li>
<li><strong>受保护的方法</strong>更具有实际意义。它对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。</li>
</ol>
<h2 id="9-控制可见性的4个访问修饰符"><a href="#9-控制可见性的4个访问修饰符" class="headerlink" title="9. 控制可见性的4个访问修饰符"></a>9. 控制可见性的4个访问修饰符</h2><p><strong>private</strong>:仅对本类可见。<br><strong>public</strong>:对所有类可见。<br><strong>protected</strong>:对本包和所有子类可见。<br><strong>默认</strong>：对本包可见。<br>其中只有public和默认可用于修饰类。</p>
<h1 id="二、Object是所有类的超类"><a href="#二、Object是所有类的超类" class="headerlink" title="二、Object是所有类的超类"></a>二、Object是所有类的超类</h1><ol>
<li>可以使用 Object 类型的变量引用任何类型的对象。</li>
<li>在 Java 中，只有基本类型不是对象。</li>
<li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, <span class="number">35000</span>);</span><br><span class="line">Employee e = (Employee)obj ;</span><br><span class="line"></span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">obj = staff; <span class="comment">// OK</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="1. equals方法"></a>1. equals方法</h2><p>是基类Object中的一个可覆盖方法，在基类中，该方法与<code>==</code>运算符等价，比较的都是对象的内存地址， 可在子类中覆盖改写该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//equals方法改写原则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//若引用同一个对象则返回true,实际是比较两个对象的默认hashcode是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//若显示参数为null则返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测。</span></span><br><span class="line">        <span class="comment">//如果所有的子类都拥有统一的语义，就使用 instanceof 检测。</span></span><br><span class="line">        <span class="comment">//if (!(otherObject instanceof ClassName)) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//若两个对象所属的类不同则返回false，getClass 方法将返回一个对象所属的类</span></span><br><span class="line">                                                                </span><br><span class="line">        <span class="comment">//比较两个相同类的不为null的对象的数据域是否相等</span></span><br><span class="line">        Employee other = (Employee)otherObject; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果两个参数都为 null， Objects.equals(a，b) 调用将返回 true; 如果其中一个参数为 null ,则返回 false ; 否则， 如果两个参数都不为 null，则调用 a.equals(b)</span></span><br><span class="line">        <span class="comment">// //使用 =比较基本类型域，使用 equals 比较对象域。</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name,other.name) &amp;&amp; salary == other.salary </span><br><span class="line">                &amp;&amp; Object.equals(hireDay,other.hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(otherObject)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//在子类中定义 equals 方法时，首先调用超类的 equals,若检测失败对象就不可能相等。</span></span><br><span class="line">        Manager other = (Manager)otherObject;          </span><br><span class="line">        <span class="keyword">return</span> bonus == other.bonus; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-相等测试与继承"><a href="#2-相等测试与继承" class="headerlink" title="2. 相等测试与继承"></a>2. 相等测试与继承</h2><p>设计equals方法的原则：<br><strong>自反性：</strong>对于任何非空引用 x, x.equals(x) 应该返回 true。<br><strong>对称性：</strong>对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true , x.equals(y) 也应该返回 true。<br><strong>传递性：</strong>对于任何引用 x、y 和 z, 如果 x.equals(y) 返回 true， y.equals(z) 返回 true, x.equals(z) 也应该返回 true。<br><strong>一致性：</strong>如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。<br>对于任意非空引用 x, x.equals(null) 应该返回 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(type[]a , type[] b)</span>   <span class="comment">//如果两个数组长度相同， 并且在对应的位置上数据元素也均相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span>  <span class="comment">//如果a和b都为null，返回true;如果只有其中之一为 null，则返回false;否则返回a.equals(b)。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-hashCode方法"><a href="#3-hashCode方法" class="headerlink" title="3. hashCode方法"></a>3. hashCode方法</h2><p>由于 hashCode方法定义在 Object 类中， 因此每个对象都有一个默认的散列码，其值为对象的存储地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String的散列码是由内容导出的</span></span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length0；i++)</span><br><span class="line">    hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder 类中没有定义hashCode 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在重写hashcode方法时可以调用 Objects.hash并提供多个参数，这个方法会对各个参数调用 Objects.hashCode，并组合这些散列值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects,hash(name, salary, hireDay); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object . .. objects)</span> <span class="comment">//返回一个散列码，由提供的所有对象的散列码组合而得到。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a )</span>  <span class="comment">//如果 a 为 null 返回 0， 否则返回 a.hashCode()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">((int11ong|<span class="keyword">short</span>|<span class="keyword">byte</span>|<span class="keyword">double</span>|f1oat|<span class="keyword">char</span>|<span class="keyword">boolean</span>)</span> value) <span class="comment">//返回给定值的散列码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(type[] a )</span> <span class="comment">//计算数组 a 的散列码。这个散列码由数组元素的散列码组合得到。</span></span></span><br></pre></td></tr></table></figure>
<p>java规定<font color=Crmison>如果重新定义 equals方法，就必须重新定义 hashCode 方法。</font>因为Hashcode是用于散列数据的快速存取的，如利用 HashSet/HashMap/HashTable类来存储数据时，都是根据存储对象的hashcode值来判断是否相同。如果我们对一个对象重写了 equals方法，意思是只要对象的成员变量的值相等那么equals就返回true，但不重写hashcode方法，那么我们再new一个新的对象的时候，当原对象.equals(新对象)等于true的时候，两者的hashcode值是不相等的。由此产生了理解上的不一致，比如在存储散列集合（如Set类）的时候，将会存储了两个一样的对象，导致混淆，因此，<font color=Crmison>也就必须重写hashcode方法,且Equals与hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( )就必须与 y.hashCode( ) 具有相同的值。</font></p>
<h2 id="4-toString方法"><a href="#4-toString方法" class="headerlink" title="4. toString方法"></a>4. toString方法</h2><p>Object 类定义了 toString 方法， 用来打印输出对象所属的类名和散列码即<code>类名@散列码</code>。toString方法是一种非常有用的调试工具。在标准类库中，许多类都定义了 toString方 法， 以便用户能够获得一些有关对象状态的必要信息。因此java建议为自定义的每一个类增加 toString 方法。<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.out);  <span class="comment">//因为 PrintStream 类的设计者没有覆盖 toString方法故得到java.io.PrintStream@2f6684的结果。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()  <span class="comment">//getClaSS( ).getName( ) 获得类名的字符</span></span><br><span class="line">串</span><br><span class="line">        + <span class="string">"[name="</span> + name</span><br><span class="line">        + <span class="string">",salary="</span> + salary</span><br><span class="line">        + <span class="string">",hireDay="</span> + hireDay</span><br><span class="line">        + <span class="string">"]"</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString()</span><br><span class="line">        + <span class="string">"[bonus="</span> + bonus</span><br><span class="line">        + <span class="string">"]"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);          </span><br><span class="line">String message = <span class="string">"The current position is "</span> + p;  <span class="comment">//此处编译器会自动的调用p.toString()方法，以便获得这个对象的字符串描述。</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span>+x;  <span class="comment">//可替代x.toString()的调用，与 toString 不同的是，如果 x 是基本类型，这条语句照样能够执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] luckyNumbers = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125; ;  </span><br><span class="line">String s = <span class="string">""</span> + luckyNumbers;       <span class="comment">//[I@la46e30（前缀 [I 表明是一个整型数组）。</span></span><br><span class="line">String s = Arrays.toString(luckyNumbers);   <span class="comment">//[2,3,5,7,11,13]</span></span><br><span class="line"></span><br><span class="line">Arrays.deepToString;  <span class="comment">//打印多维数组</span></span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getSuperclass</span><span class="params">( )</span></span>;  <span class="comment">//以 Class 对象的形式返回这个类的超类信息。</span></span><br></pre></td></tr></table></figure></p>
<h1 id="三、泛型数组列表ArrayList"><a href="#三、泛型数组列表ArrayList" class="headerlink" title="三、泛型数组列表ArrayList"></a>三、泛型数组列表ArrayList</h1><ol>
<li>ArrayList 是一个采用类型参数的泛型类,它在添加或删除元素时， 具有自动调节数组容量的功能。<font color=Crmison>&lt;&gt;中的类型不能是基本数据类型。</font></li>
<li><font color=Crmison>元素在集合中有序，指的是元素插入过程中记录了元素的插入顺序。</font><h2 id="1-创建ArrayList"><a href="#1-创建ArrayList" class="headerlink" title="1. 创建ArrayList"></a>1. 创建ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();  <span class="comment">//构造一个空数组列表</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//可以结合new操作符使用“菱形”语法,编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，编译器会检査这个变量、 参数或</span></span><br><span class="line">                                                <span class="comment">//方法的泛型类型，然后将这个类型放在&lt;&gt;中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 Java SE 5.0 以后的版本中， 没有后缀 &lt;...&gt; 仍然可以使用ArrayList, 它将被认为是一个删去了类型参數的“ 原始” 类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象</span></span><br><span class="line">staff.add(<span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, ...)); <span class="comment">//在数组列表的尾端添加一个元素，如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</span></span><br><span class="line"></span><br><span class="line">staff.ensureCapacity(l00);  <span class="comment">//可以指定数组大小，则在100次调用add之间不用重新分配空间。</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;(l00); <span class="comment">//可以把初始容量传递给 ArrayList 构造器。表明它拥有保存100个元素的潜力，重新分配空间的话会超过100</span></span><br><span class="line"></span><br><span class="line">staff.size();  <span class="comment">//返回数组列表中包含的实际元素数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">( )</span>  <span class="comment">//将数组列表的存储容量削减到当前尺寸。垃圾回收器将回收多余的存储空间。应该在确认不会添加任何元素时，再调用该方法否则添加元素时需要花时间再次移动存储块。</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-访问数组列表元素"><a href="#2-访问数组列表元素" class="headerlink" title="2. 访问数组列表元素"></a>2. 访问数组列表元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.set(i, harry);  <span class="comment">//设置第i个元素，只有i小于或等于数组列表中当前实际元素个数时才可以调用。</span></span><br><span class="line"></span><br><span class="line">Employee e = staff.get(i);  <span class="comment">//获得数组列表的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//灵活扩展数组</span></span><br><span class="line">ArrayList&lt;X&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (. . .) </span><br><span class="line">&#123; </span><br><span class="line">    x = . .;</span><br><span class="line">    list.add(x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方便访问数组</span></span><br><span class="line">X[] a = <span class="keyword">new</span> X[list.size()];</span><br><span class="line">list.toArray(a); </span><br><span class="line"></span><br><span class="line">staff.add(i,e);  <span class="comment">//在数组列表的中间插入元素</span></span><br><span class="line">Employee e = staff.remove(i);  <span class="comment">//从数组列表中间删除一个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Employee e : staff)   <span class="comment">//可以使用“ foreach” 循环遍历数组列表：</span></span><br></pre></td></tr></table></figure>

<h2 id="3-类型化与原始数组列表的兼容性"><a href="#3-类型化与原始数组列表的兼容性" class="headerlink" title="3. 类型化与原始数组列表的兼容性"></a>3. 类型化与原始数组列表的兼容性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ArrayList list)</span> </span>&#123; . . . &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">find</span><span class="params">(String query)</span> </span>&#123; . . . &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee〉staff = . . .;   <span class="comment">//可以将一个类型化的数组列表传递给 update 方法,无需任何类型转换，但是这样不安全</span></span><br><span class="line">employeeDB.update(staff);   <span class="comment">//也可以将 staff 对象传递给 update 方法。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) ArrayList&lt;Employee&gt; result = employeeDB.find(query);  <span class="comment">//将一个原始 ArrayList 赋给一个类型化 ArrayList 会得到一个警告。一旦能确保不会造成严重的后果，可以用@SuppressWamings("unchecked") 标注来标记这个变量能够接受类型转换。</span></span><br></pre></td></tr></table></figure>

<h1 id="四、对象包装器与自动装箱"><a href="#四、对象包装器与自动装箱" class="headerlink" title="四、对象包装器与自动装箱"></a>四、对象包装器与自动装箱</h1><ol>
<li><strong>包装器：</strong>所有的基本类型都有一个与之对应的类，称为包装器。Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean (前 6 个类派生于公共的超类 Number)。<font color=Crmison>对象包装器是不可变的，不可改变其值，还是final的，不可定义其子类。</font></li>
<li>自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到<strong>固定的对象</strong>中。此时若用<code>==</code>比较两个值相同的包装器对象则一定为true。</li>
<li>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   <span class="comment">//效率远低于int[],仅在构造小型集合时使用它。</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">3</span>);  <span class="comment">//自动装箱；会自动变换为list.add(Integer.valueOf(3));</span></span><br><span class="line"><span class="keyword">int</span> n = list.get(i);  <span class="comment">//自动拆箱；会自动翻译成 int n = list.get(i).intValue();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//算术表达式中也能自动装箱和拆箱</span></span><br><span class="line">Integer n = <span class="number">3</span>;</span><br><span class="line">n++;    <span class="comment">//编译器会自动地插入一条对象拆箱的指令， 然后进行自增计算， 最后再将结果装箱。</span></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">1000</span>;</span><br><span class="line">Integer b = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b)    <span class="comment">//一般为false，而java中若将经常出现的值包装到同一个对象中，这种比较就有可能成立。为了避免这种不确定性，一般在两个包装器对象比较时调用 equals 方法。</span></span><br><span class="line"></span><br><span class="line">Integer n = <span class="keyword">null</span>;  <span class="comment">//可以引用null</span></span><br><span class="line">System.out.println(<span class="number">2</span> * n);  <span class="comment">//会抛出一个 NullPointerException 异常</span></span><br><span class="line"></span><br><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">Double x = <span class="number">2.0</span>;</span><br><span class="line">System.out.println(<span class="keyword">true</span> ? n : x);  <span class="comment">//输出1.0；如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱，提升为 double, 再装箱为 Double。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = Integer.parseInt(s);  <span class="comment">//将字符串转换成整型。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">(IntHolder x)</span>   <span class="comment">//org.omg.CORBA 包中定义的持有者类型， 包括 IntHolder、BooleanHolder 等，都包含一个公有域值，可以改变x的值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     x.value = <span class="number">3</span> * x.value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i )</span>  <span class="comment">//以一个新 String 对象的形式返回给定数值 i 的十进制表示。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> radix )</span>  <span class="comment">//返回数值 i 的基于给定 radix 参数进制的表示。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Static Integer <span class="title">valueOf</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Number <span class="title">parse</span><span class="params">(String s)</span>  <span class="comment">//返回数字值，假设给定的 String 表示了一个数值。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="五、参数数量可变的方法"><a href="#五、参数数量可变的方法" class="headerlink" title="五、参数数量可变的方法"></a>五、参数数量可变的方法</h1><p>也称为变参方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//printf方法的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String fmt , Object... args)</span>   <span class="comment">//... 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除 fmt参数之外）。Object…参数类型与 Object[]完全一样。</span></span></span><br><span class="line"><span class="function">        </span>&#123;                                                   <span class="comment">//如果调用者提供的是整型数组或者其他基本类型的值，自动装箱功能将把它们转换成对象。</span></span><br><span class="line">            <span class="keyword">return</span> format(fmt, args);                       <span class="comment">//现在将扫描 fmt 字符串， 并将第 i 个格式说明符与 args[i] 的值匹配起来。</span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"%d %s"</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">new</span> Integer(n), <span class="string">"widgets"</span> &#125; ); <span class="comment">//编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上，并在必要的时候进行自动装箱.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义变参方法:计算若干个数值的最大值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span> <span class="params">(<span class="keyword">double</span>... values)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> largest = Double.NECATIVEJNFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> v : values) </span><br><span class="line">        <span class="keyword">if</span> (v &gt; largest) largest = v;</span><br><span class="line">    <span class="keyword">return</span> largest; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> m = max(<span class="number">3.1</span>, <span class="number">40.4</span>, -<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span></span><br></pre></td></tr></table></figure>
<p>允许将一个数组传递给可变参数方法的<strong>最后一个参数</strong>,因此，可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。</p>
<h1 id="六、枚举类"><a href="#六、枚举类" class="headerlink" title="六、枚举类"></a>六、枚举类</h1><p>所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL , MEDIUM, LARGE, EXTRAJARGE &#125;;  <span class="comment">//实际上定义了一个类刚好有4个实例，由于Enum中equlas方法直接用==实现，故在比较两个枚举变量值时直接使用==即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在枚举类型中添加一些构造器、 方法和域。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size</span><br><span class="line">&#123;</span><br><span class="line">    SMALL(<span class="string">"S"</span>), MEDIUM(<span class="string">"M"</span>), LARGE(<span class="string">"L"</span>), EXTRA_LARGE(<span class="string">"XL"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span> </span>&#123; <span class="keyword">this</span>,abbreviation = abbreviation; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> abbreviation; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Size.SMALL.toString();  <span class="comment">//返回字符串"SMALL"。</span></span><br><span class="line">Size s = Enum.valueOf(Size,class, "SMALL");  //将 s 设置成 Size.SMALL</span><br><span class="line"></span><br><span class="line">Size[] values = Size.values();  <span class="comment">//返回一个包含全部枚举值的数组。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordinal</span> <span class="params">()</span>  <span class="comment">//返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( E other )</span> <span class="comment">//如果枚举常量出现在 Other 之前， 则返回一个负值；如果 this=other，则返回 0; 否则，返回正值。枚举常量的出现次序在 enum 声明中给出。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h1><p>能够分析类能力的程序称为反射，反射库提供了一个非常丰富且精心设计的工具集，使用它的主要人员是工具构造者，而不是应用程序员。反射的功能：</p>
<ol>
<li>在运行时分析类的能力。</li>
<li>在运行时查看对象，例如，编写一个 toString 方法供所有类使用。</li>
<li>实现通用的数组操作代码。</li>
<li>利用 Method 对象， 这个对象很像C++中的函数指针。</li>
</ol>
<h2 id="1-Class类"><a href="#1-Class类" class="headerlink" title="1. Class类"></a>1. Class类</h2><p>Class类中保存着Java 运行时系统始终为所有对象维护的一个被称为运行时的类型标识，虚拟机利用运行时类型信息选择相应的方法执行。通过Class类可以访问这些信息。一个Class对象将表示<strong>一个特定类的属性</strong>。<br>Class 类实际上是一个<strong>泛型类</strong>。例如， Employee.class 的类型是 Class&lt;Employee&gt;,但是它将已经抽象的概念更加复杂化了。在大多数实际问题中， 可以忽略类型参数， 而使用原始的 Class 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">Class cl = e.getClass(); <span class="comment">//返回一个 Class 类型的实例。</span></span><br><span class="line"></span><br><span class="line">System.out.println(e.getClass().getName() + <span class="string">" "</span> + e.getName()); <span class="comment">//Class的 getName返回类的名字。返回 Employee Harry Hacker或Manager Harry Hacker</span></span><br><span class="line"></span><br><span class="line">Random generator = <span class="keyword">new</span> Random():</span><br><span class="line">Class cl = generator.getClass();</span><br><span class="line">String name = cl.getName(); <span class="comment">// "java.util .Random"。如果类在一个包里，包的名字也作为类名的一部分</span></span><br><span class="line"></span><br><span class="line">String className = <span class="string">"java.util.Random"</span>;</span><br><span class="line">Class cl = Class.forName(className);   <span class="comment">//获得类名对应的 Class 对象。</span></span><br><span class="line">                                        <span class="comment">//这个方法只有在 dassName 是类名或接口名时才能够执行。否则将抛出一个 checked exception(已检查异常），在使用时必须提供一个异常处理器。</span></span><br><span class="line"></span><br><span class="line">Class dl = Random<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// if you import java.util</span></span><br><span class="line">Class cl <span class="number">2</span> = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;   <span class="comment">//一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。</span></span><br><span class="line">Class cl <span class="number">3</span> = Double[]<span class="class">.<span class="keyword">class</span></span>;   <span class="comment">//通过T.class获得Class对象。</span></span><br><span class="line"></span><br><span class="line">Double[ ] class.getName( ) //返回 [Ijava.lang.Double;</span><br><span class="line">int[ ].class.getName( ) //返回 [I  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e.getClass() == Employee<span class="class">.<span class="keyword">class</span>)  //可以使用</span>==比较两个Class对象</span><br><span class="line"></span><br><span class="line">e.getClass().newInstance(); <span class="comment">//来动态地创建一个与类e具有相同类型的实例</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">"java.util.Random"</span>;</span><br><span class="line">Object m = Class.forName(s).newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p>若程序中没有提供捕获异常的处理器对异常情况进行处理，程序在运行时发生异常就会终止执行，并在控制台上打印一条信息给出异常类型。<br><strong>已检查异常</strong>：编译器将会检查是否为调用了抛出已检查异常方法的相关代码提供了异常处理器，否则将不能通过编译。<br><strong>未检查异常</strong>：编译器不要求强制处置的异常，虽然你有可能出现错误，但是我不会在编译的时候检查，需要自己精心编写代码来避免。例如访问 null 引用等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    String name = . . .; </span><br><span class="line">    Class cl = Class.forName(name); <span class="comment">//如果类名不存在， 则将跳过 try 块中的剩余代码，程序直接进人 catch 子句，否则跳过catch子句的处理器代码。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) </span><br><span class="line">&#123;</span><br><span class="line">     e.printStackTrace();   <span class="comment">//利用Throwable 类（Exception类的超类）的 printStackTrace 方法打印出栈的轨迹。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-利用反射分析类的能力"><a href="#3-利用反射分析类的能力" class="headerlink" title="3. 利用反射分析类的能力"></a>3. 利用反射分析类的能力</h2><p>在 java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、方法和构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Class;</span><br><span class="line"></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name )</span>   <span class="comment">//返回指定名称的公有域</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span>  <span class="comment">//返回类中声明的给定名称的域， 或者包含声明的全部域的数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果类中没有域， 或者 Class 对象描述的是基本类型或数组类型， 这些方法将返回一个长度为 0 的数组。</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span>  <span class="comment">//getFields 方法将返回一个包含 Field 对象的数组， 这些对象记录了这个类或其超类的公有域。</span></span></span><br><span class="line"><span class="function">Filed[] <span class="title">getDeclaredFie1ds</span><span class="params">()</span>  <span class="comment">//getDeclaredField 方法也将返回包含 Field 对象的数组， 这些对象记录了这个类的全部域。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回包含 Method 对象的数组</span></span></span><br><span class="line"><span class="function"><span class="comment">//getMethods 将返回所有的公有方法， 包括从超类继承来的公有方法；</span></span></span><br><span class="line"><span class="function"><span class="comment">//getDeclaredMethods 返回这个类或接口的全部方法， 但不包括由超类继承了的方法。</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclareMethods</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回包含 Constructor 对象的数组</span></span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getConstructors</span><span class="params">()</span>  <span class="comment">//返回公有构造器</span></span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span>  <span class="comment">//返回所有构造器</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getDeclaringClass</span><span class="params">( )</span>  <span class="comment">//返冋一个用于描述类中定义的构造器、 方法或域的 Class 对象。</span></span></span><br><span class="line"><span class="function">Class[] <span class="title">getExceptionTypes</span> <span class="params">( )</span> <span class="comment">//( 在 Constructor 和 Method 类中）返回一个用于描述方法抛出的异常类型的 Class 对象数组。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">( )</span>  <span class="comment">//返回一个用于描述构造器、 方法或域的修饰符的整型数值。使用 Modifier 类中的这个方法可以分析这个返回值。用不同的位开关描述 public 和 static 这样的修饰符使用状况</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">( )</span> <span class="comment">//返冋一个用于描述构造器、 方法或域名的字符串。</span></span></span><br><span class="line"><span class="function">Class[] <span class="title">getParameterTypes</span> <span class="params">( )</span> <span class="comment">//( 在 Constructor 和 Method 类 中）返回一个用于描述参数类型的 Class 对象数组。 </span></span></span><br><span class="line"><span class="function">Class <span class="title">getReturnType</span><span class="params">( )</span>  <span class="comment">//( 在 Method 类中）返回一个用于描述返H类型的 Class 对象。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> modifiers )</span> <span class="comment">//返回对应 modifiers 中设置的修饰符的字符串表示。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这些方法将检测方法名中对应的修饰符在 modifiers 值中的位，即方法和构造器是否是public、 private 或 final。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFinal</span> <span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">islnterface</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNative</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrivate</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProtected</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPublic</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStrict</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSynchronized</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVolati1e</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-在运行时使用反射分析对象"><a href="#4-在运行时使用反射分析对象" class="headerlink" title="4. 在运行时使用反射分析对象"></a>4. 在运行时使用反射分析对象</h2><ol>
<li>在编写程序时， 如果知道想要査看的域名和类型，查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域,从而<font color=Crmison>进一步查看运行时数据域的实际内容。</font></li>
<li>反射机制的默认行为受限于 Java 的访问控制。除非拥有访问权限，否则Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。可利用需要调用 Field、 Method 或Constructor 对象的 setAccessible 方法来覆盖访问控制。</li>
<li>当调用get方法获得域值时参数为基本数据类型，则反射机制将会自动地将这个域值打包到相应的对象包装器中。也可以调用Field 类中的 getDouble 等方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, <span class="number">35000</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1989</span>);</span><br><span class="line">Class cl = harry.getClass; </span><br><span class="line">Field f = cl .getDeclaredField(<span class="string">"name"</span>); </span><br><span class="line"></span><br><span class="line">f.setAtcessible(<span class="keyword">true</span>);   <span class="comment">//覆盖访问控制</span></span><br><span class="line"></span><br><span class="line">Object v = f.get(harry);  <span class="comment">//获得name域运行时的具体值为"Harry Hacker"</span></span><br><span class="line">f.set(obj,value);  <span class="comment">//将 obj 对象的 f 域设置成新值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ObjectAnalyzer().toString(<span class="keyword">this</span>);  <span class="comment">//利用ObjectAnalyzer类的toString方法可为每个自定义类重写一个通用的toString方法，很方便。将打印类的所有信息，包括运行时的具体域值。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">( )</span>  <span class="comment">//返回反射对象的可访问标志的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(AccessibleObject[] array,<span class="keyword">boolean</span> flag)</span>  <span class="comment">//是一种设置对象数组可访问标志的快捷方法。</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-使用反射编写泛型数组代码"><a href="#5-使用反射编写泛型数组代码" class="headerlink" title="5. 使用反射编写泛型数组代码"></a>5. 使用反射编写泛型数组代码</h2><p>将一个 Employee[]临时地转换成 Object[] 数组， 然后再把它转换回来是可以的，但一从开始就是 Object[] 的数组却永远不能转换成 Employee[] 数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，这个 CopyOf 方法可以用来扩展任意类型的数组， 而不仅是对象数组。</span></span><br><span class="line"><span class="comment">//应该将 goodCopyOf 的参数声明为 Object 类型，而不要声明为对象型数组（Object[])。整型数组类型 int[] 可以被转换成 Object，但不能转换成对象数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cl = a.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Class componentType = cl.getComponentType();</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    Object newArray = Array.newInstance(componentType, newLength):</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">get</span><span class="params">(Object array,<span class="keyword">int</span> index)</span>  <span class="comment">//( xxx 是 boolean、byte、 char、 double、 float、 int、 long、 short 之中的一种基本类型。)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> xxx <span class="title">getXxx</span><span class="params">(Object array,<span class="keyword">int</span> index)</span> <span class="comment">//这些方法将返回存储在给定位置上的给定数组的内容。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object array,<span class="keyword">int</span> index,Object newValue)</span>  <span class="comment">//( xxx 是 boolean、 byte、char、double、float、 int、 long、 short 之中的一种基本类型。)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">setXxx</span><span class="params">(Object array,<span class="keyword">int</span> index,xxx newValue)</span>      <span class="comment">//这些方法将一个新值存储到给定位置上的给定数组中。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Object array)</span>  <span class="comment">//返回数组的长度。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class componentType,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class componentType,<span class="keyword">int</span>[] lengths)</span>  <span class="comment">//返回一个具有给定类型、给定维数的新数组。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="6-利用反射调用任意方法"><a href="#6-利用反射调用任意方法" class="headerlink" title="6. 利用反射调用任意方法"></a>6. 利用反射调用任意方法</h2><p>利用反射中的Method类的invoke方法可以回调任意对象的任意方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  <span class="comment">//第一个参数是隐式参数， 其余的对象提供了显式参数，对于静态方法，第一个参数可以被忽略， 即可以将它设置为 null。</span></span></span><br><span class="line"><span class="function">                                           <span class="comment">//如果返回类型是基本类型， invoke 方法会返回其包装器类型。必须相应地完成类型转换。</span></span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class... parameterTypes)</span>  <span class="comment">//利用Class类中的getMethod方法获得Method对象</span></span></span><br><span class="line"><span class="function">                                                        <span class="comment">//也可以通过调用 getDeclareMethods 方法， 然后对返回的 Method 对象数组进行查找， 直到发现想要的方法为止。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">Method ml = Employee.class.getMethod("getName");</span><br><span class="line">Method m2 = Employee.class.getMethod("raiseSalary", double.class);</span><br><span class="line"></span><br><span class="line">String n = (String) ml.invoke(harry);  </span><br><span class="line"><span class="keyword">double</span> s = (Double) m2.invoke(harry);</span><br><span class="line">f.invoke(<span class="keyword">null</span>, x);          <span class="comment">//有可能存在若干个相同名字的方法，鉴于此，还必须提供想要的方法的参数类型。</span></span><br></pre></td></tr></table></figure>
<p>反射的优缺点：</p>
<ol>
<li>反射对于编写系统程序来说极其实用，但是通常不适于编写应用程序。</li>
<li>如果在调用方法的时候提供了一个错误的参数，那么 invoke 方法将会抛出一个异常；</li>
<li>且使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。</li>
<li>反射是很脆弱的，即编译器很难帮助人们发现程序中的错误， 因此只有在运行时才发现错误并导致异常。</li>
</ol>
<p>因此建议仅在必要的时候才使用 Method 对象，而最好使用接口以及 Java SE8 中 的 lambda 表达式，它们的代码的执行速度更快，更易于维护。</p>
<h1 id="八、继承的设计技巧"><a href="#八、继承的设计技巧" class="headerlink" title="八、继承的设计技巧"></a>八、继承的设计技巧</h1><ol>
<li>将公共操作和域放在超类；</li>
<li>不要使用受保护的域；</li>
<li>使用继承实现<strong>严格</strong>“ is-a” 关系，即超类中不能存在子类不需要的域；</li>
<li>除非<strong>所有</strong>继承的方法都有意义，否则不要使用继承；</li>
<li>在覆盖方法时，不要改变预期的行为；</li>
<li>使用多态(具有动态邦迪机制)，而非类型信息；</li>
<li>不要过多地使用反射。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的接口、lambda 表达式与内部类</title>
    <url>/2020/05/21/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h1><h2 id="1-接口概念"><a href="#1-接口概念" class="headerlink" title="1. 接口概念"></a>1. 接口概念</h2><p>接口<strong>不是类</strong>，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义，即<font color=Crmison>必须实现</font>接口中定义的所有方法。一个类可以实现（implement)—个或多个接口，并在需要接口的地方,随时使用实现了相应接口的对象。</p>
<ol>
<li>接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字public。<font color=Crmison>不过，在实现接口时，必须把方法声明为 public;</font>否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。</li>
<li>接口中的域将被自动设为 public static final。接口绝不能含有实例域。java SE8之后，接口可以定义和实现静态方法(public static)以及默认方法(default)。</li>
<li>Java是一种<font color=Crmison>强类型语言</font>：在调用方法的时候，编译器将会检查这个方法是否存在。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Comparable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;s</span><br><span class="line">    <span class="comment">////实现该接口的类必须实现此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;  <span class="comment">//实现该方法附加要求：在调用X.compareTo(y)的时候，这个方法必须确实比较两个对象的内容，并返回比较的结果。当x小于y时，返回一个负数；当x等于 时，返回0；</span></span><br><span class="line">                                 <span class="comment">//否则返回一个正数。 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object otherObject)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee other = (Employee) otherObject;  <span class="comment">//需要进行强制类型转换，不推荐</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 JavaSE 5.0 中，Comparable 接口已经改进为泛型类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;    //推荐方式</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);  <span class="comment">//x &lt; y 时，Double.compare(x, y) 调用会返回 -1 ; 如果 x &gt; y 则返回 1。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求对象所属的类必须实现了 Comparable 接口，因为要向 sort 方法提供对象的比较方式。 </span></span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee (<span class="string">"Harry Hacker"</span> , <span class="number">35000</span>);</span><br><span class="line">staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee (<span class="string">"Carl Cracker"</span> , <span class="number">75000</span>);</span><br><span class="line">staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee (<span class="string">"Tony Tester"</span> , <span class="number">38000</span>);</span><br><span class="line">Arrays.sort(staff) ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">( Object[] a )</span> <span class="comment">//使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了Comparable 接口的类， 并且元素之间必须是可比较的。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span> <span class="comment">//用这个对象与 other 进行比较。如果这个对象小于 other 则返回负值； 如果相等则返回0；否则返回正值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span> <span class="comment">//如果 x &lt; y 返回一个负整数；如果 x 和 y 相等，则返回 0; 否则返回一个负整数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span> x , <span class="keyword">double</span> y)</span> <span class="comment">//如果 x &lt; y 返回一个负数；如果 x 和 y 相等则返回 0; 否则返回一个负数</span></span></span><br></pre></td></tr></table></figure>

<p><font color=Crmison>与 equals 方法一样，compareTo方法在继承过程中有可能会出现子类父类对象混合比较的问题。</font>修改方式和equals一样，有两种不同情况，即根据子类语义是否改变来决定是用getClass方法还是instanceof方法检查类型是否一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != other.getClass()) <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();  <span class="comment">//若子类语义发生改变</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-接口的特性"><a href="#2-接口的特性" class="headerlink" title="2. 接口的特性"></a>2. 接口的特性</h2><ol>
<li>接口不是类，尤其不能使用 new 运算符实例化一个接口,但可以声明接口的变量，接口变量<strong>必须</strong>引用实现了接口的类对象。</li>
<li>与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。</li>
<li>接口可以只定义常量而不定义方法，但这样应用接口似乎有点偏离了接口概念的初衷，最好不要这样使用它。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口的声明和引用</span></span><br><span class="line">Comparable x;</span><br><span class="line">x = <span class="keyword">new</span> Employee(...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) &#123; . . . &#125;  <span class="comment">//可以使用instance 检查一个对象是否实现了某个特定的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口的继承或扩展</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Powered</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">milesPerGallon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">double</span> SPEED.LIHIT = <span class="number">95</span>; <span class="comment">//接口不能包含实例域或静态方法，但却可以包含常量</span></span><br><span class="line">                            <span class="comment">//接口中的域将被自动设为 public static final。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Comparable</span>  //类可以实现多个接口，却只能拥有一个超类</span></span><br></pre></td></tr></table></figure>

<h2 id="3-接口与抽象类"><a href="#3-接口与抽象类" class="headerlink" title="3. 接口与抽象类"></a>3. 接口与抽象类</h2><p>接口与抽象类的区别在于一个类可以实现多个接口，而一个类只能扩展一个抽象类，Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂，效率也会降低。而接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h2 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4. 静态方法"></a>4. 静态方法</h2><p>在 Java SE 8 中，允许在接口中增加静态方法，但是认为这有违于将接口作为抽象规范的初衷，通常的做法都是将静态方法放在伴随类中，例如java标准库中出现的Collection/Collections 或 Path/Paths等成对的接口和实用工具类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以为 Path 接口增加静态方法，如此伴随类paths就不再必要了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">get</span><span class="params">(String first, String... more)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileSystems.getDefault().getPath(first, more);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-默认方法"><a href="#5-默认方法" class="headerlink" title="5. 默认方法"></a>5. 默认方法</h2><p>可以为接口方法提供一个默认实现。必须用 default 修饰符标记，默认方法可以调用任何其他方法，<strong>实现该接口的类继承该方法且无需覆盖默认方法</strong>。有些情况下，默认方法可能很有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection 接口可以定义一个默认方法isEmpty，这样实现 Collection 的程序员就不用操心实现 isEmpty 方法了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// An abstract method</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有太大用处， 因为 Comparable 的每一个实际实现都要覆盖这个方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//所有元素都相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> <span class="keyword">implements</span> <span class="title">Collection</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认方法的一个重要用法是<strong>“接口演化”</strong>,假设之后为Collection接口又增加了一个 stream 非默认方法，那么 Bag 类将不能编译，即为接口增加一个非默认方法不能保证<font color=Crmison>“源代码兼容”</font>。不过， 假设不重新编译这个类，而只是使用原先的一个包含这个类的 JAR 文件。这个类仍能正常加载，程序仍然可以正常构造 Bag 实例，不会出现编译错误(<font color=Crmison>即为接口增加方法可以保证“二进制兼容”</font>)，不过如果程序在运行时在一个 Bag 实例上调用 stream方法，就会出现一个 AbstractMethodError。</li>
<li>将方法实现为一个默认方法就可以正常编译Bag类，另外如果没有重新编译而直接加载这个类， 并在一个 Bag 实例上调用 stream 方法， 将调用 Collection.stream 方法。</li>
</ul>
<h2 id="6-解决默认方法冲突"><a href="#6-解决默认方法冲突" class="headerlink" title="6. 解决默认方法冲突"></a>6. 解决默认方法冲突</h2><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，java解决该冲突的规则为：</p>
<blockquote>
<ol>
<li><font color=Crmison>超类优先</font>。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。即”类优先”规则。</li>
<li><font color=Crmison>接口冲突</font>。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li>
</ol>
</blockquote>
<p>若两个接口都没有为<strong>共享方法</strong>提供默认实现，则不会存在冲突。由于“java的类优先规则”，千万不要让一个接口中的默认方法重新定义 Object 类中的某个方法，因为这样的方法绝对无法超越 Object.toString 或 Objects.equals。</p>
<h1 id="二、接口示例"><a href="#二、接口示例" class="headerlink" title="二、接口示例"></a>二、接口示例</h1><h2 id="1-接口与回调"><a href="#1-接口与回调" class="headerlink" title="1. 接口与回调"></a>1. 接口与回调</h2><p>回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">10000</span>, listener);   <span class="comment">//定时器需要知道调用哪一个方法，并要求传递的对象所属的类实现了java.awt.event 包的 ActionListener 接口。</span></span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();   <span class="comment">//发出一声铃响。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timer(<span class="keyword">int</span> interval , ActionListener listener)  <span class="comment">//构造一个定时器， 每隔 interval 毫秒通告 listener—次</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Comparator-接口"><a href="#2-Comparator-接口" class="headerlink" title="2. Comparator 接口"></a>2. Comparator 接口</h2><p>利用Arrays.sort的数组和比较器(comparator)版本可以改变String类的比较规则，其中比较器是实现了 Comparator 接口的类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparators</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first, T second)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first, String second)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] friends = &#123; <span class="string">"Peter"</span>, <span class="string">"Paul"</span>, <span class="string">"Mary"</span> &#125;;</span><br><span class="line">Arrays,sort(friends, <span class="keyword">new</span> LengthComparator());</span><br></pre></td></tr></table></figure>

<h2 id="3-对象克隆-Cloneable-接口"><a href="#3-对象克隆-Cloneable-接口" class="headerlink" title="3. 对象克隆(Cloneable 接口)"></a>3. 对象克隆(Cloneable 接口)</h2><ol>
<li>这个接口从超类Object类中继承了一个安全的 clone 方法，它没有指定clone 方法。只是作为一个标记接口，指示类设计者了解克隆过程。</li>
<li>clone 方法是 Object 的一个 protected 方法，只能由其子类对象克隆其自己，即子类的方法中只能调用其所属类的clone方法，而不能调用其它子类对象的clone方法。</li>
<li>默认的克隆操作是<font color=Crmison>浅拷贝</font>，并没有克隆对象中引用的其他对象，这样一来，原对象和克隆的对象仍然会<strong>共享一些域信息</strong>。</li>
<li>如果原对象和浅克隆对象共享的子对象是不可变的(或子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用)，那么这种共享就是安全的。</li>
<li>不过，通常子对象都是可变的，必须重新定义 clone 方法来建立一个<font color=Crmison>深拷贝</font>，同时克隆所有子对象。</li>
<li>即使 clone 的默认（浅拷贝）实现能够满足要求， 还是需要实现 Cloneable 接口， 将 clone重新定义为 public，再调用 super.clone(),否则会生成一个受査异常CloneNotSupportedException。</li>
<li>子类只能调用受保护的 clone 方法来克隆它自己的对象。 必须重新定义 clone 为 public 才能允许所有方法克隆对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//如果在一个对象上调用 clone, 但这个对象的类并没有实现 Cloneable 接口，Object 类 的 clone 方法就会拋出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// call Object.clone()</span></span><br><span class="line">        Employee cloned = (Employee) <span class="keyword">super</span>.clone() ; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// clone mutable fields</span></span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有数组类型都有一个 public 的 clone 方法， 而不是 protected: 可以用这个方法建立一个新数组， 包含原数组所有元素的副本。</span></span><br><span class="line"><span class="keyword">int</span>[] luckyNumbers = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] cloned = luckyNumbers.done();</span><br><span class="line">cloned[<span class="number">5</span>] = <span class="number">12</span>; <span class="comment">// 不会改变luckyNumbers[5]</span></span><br></pre></td></tr></table></figure>

<h1 id="三、lambda-表达式"><a href="#三、lambda-表达式" class="headerlink" title="三、lambda 表达式"></a>三、lambda 表达式</h1><h2 id="1-为什么引入-lambda-表达式"><a href="#1-为什么引入-lambda-表达式" class="headerlink" title="1. 为什么引入 lambda 表达式"></a>1. 为什么引入 lambda 表达式</h2><p> lambda 表达式是一个可传递的代码块，该代码块可传递到某个对象，可以在以后执行一次或多次，实现回调，类似以上ActionListener 的 actionPerformed方法。Java 是一种面向对象语言，不能直接传递代码段，必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码，利用lambda表达式可以让这种形式的代码块表达的更加简洁。</p>
<h2 id="2-lambda-表达式的语法"><a href="#2-lambda-表达式的语法" class="headerlink" title="2. lambda 表达式的语法"></a>2. lambda 表达式的语法</h2><p>带参数变量的表达式就被称为 lambda 表达式，lambda 表达式就是一个代码块， 以及必须传入代码的变量规范。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数， 箭头（-&gt;) 以及一个表达式。无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是会由上下文推导得出。</span></span><br><span class="line">(String first, String second) -&gt; first.length() - second.length()  <span class="comment">//可以在需要 int 类型结果的上下文中使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 &#123;&#125;中，并包含显式的 return语句。</span></span><br><span class="line">(String first, String second) -&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>;i &gt;= <span class="number">0</span>;i-- ) System.out.println(i);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。</span></span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); <span class="comment">//编译器可以推导出 first 和 second 必然是字符串，因为这个 lambda 表达式将赋给一个字符串比较器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果方法只有一个参数， 而且这个参数的类型可以推导得出，那么甚至还可以省略小括号</span></span><br><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">"The time is "</span> + <span class="keyword">new</span> Date()<span class="string">");</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//labmda表达式的应用</span></span><br><span class="line">Arrays.sort(planets, (first, second) -&gt; first.length() - second .length());</span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println (<span class="string">"The time is "</span> + <span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">ActionListener listener = event -&gt; </span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(text);</span><br><span class="line">    Toolkit.getDefaultToolkitO.beep();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Timer(delay, listener).start();</span><br></pre></td></tr></table></figure>
<p><font color=Crmison>如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，这是不合法的。</font></p>
<h2 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h2><ol>
<li>对于<strong>只有一个抽象方法的接口</strong>，需要这种接口的<strong>对象</strong>时，就可以提供一个 lambda 表达式，这种接口称为函数式接口。</li>
<li>最好把 lambda 表达式看作是一个函数，而不是一个对象， 另外要接受 lambda 表达式可以传递到函数式接口。</li>
<li>在 Java 中，对 lambda 表达式所能做的也只是能转换为函数式接口。java保持了接口概念而没有增加函数类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此包中定义了很多非常通用的函数式接口。</span></span><br><span class="line"><span class="keyword">import</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在底层， Arrays.sort 方法会接收实现了 Comparator&lt;String&gt; 的某个类的对象。在这个对象上调用 compare 方法会执行这个 lambda 表达式的体。</span></span><br><span class="line">Arrays.sort (words, (first, second) -&gt; first.length() - second.length()) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口BiFunction&lt;T, U, R&gt; 描述了参数类型为 T 和 U 而且返回类型为 R 的函数。可以将lambda表达式保存在该类型的变量中。</span></span><br><span class="line">BiFunction&lt;String, String, Integer&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口 Predicate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>; </span><br><span class="line">    <span class="comment">// Additional default and static methods   //可以有其它非抽象方法，但抽象方法只能有一个。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ArrayList 类有一个 removeIf 方法， 它的参数就是一个 Predicate。这个接口专门用来传递lambda 表达式。</span></span><br><span class="line">list.removeIf(e -&gt; e == <span class="keyword">null</span>);  <span class="comment">//从一个数组列表删除所有 null 值。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><ol>
<li>有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作，故可直接将该方法的表达式传递到此处，该表达式称为方法引用，要用<code>::</code> 操作符分隔方法名与对象或类名。</li>
<li>类似于 lambda 表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。</li>
<li>如果有多个同名的重载方法， 编译器就会尝试从上下文中找出你指的那一个方法。</li>
<li>可以在方法引用中使用 this 参数，使用super也是合法的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法引用的格式有三种</span></span><br><span class="line"><span class="comment">//方法引用等价于提供方法参数的 lambda 表达式。</span></span><br><span class="line">object::instanceMethod </span><br><span class="line">Class::staticMethod</span><br><span class="line">Class::instanceMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法引用的应用</span></span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, System.out::println);  <span class="comment">//System.out::println 等价于 lambda 表达式  x -&gt; System.out.println(x)</span></span><br><span class="line">Math::pow;  <span class="comment">//等价于（x，y) -&gt; Math.pow(x, y)。</span></span><br><span class="line">Arrays.sort(strings，String::conpareToIgnoreCase)   <span class="comment">//String::conpareToIgnoreCase等同于 (x, y) -&gt; x.compareToIgnoreCase(y)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>::equals <span class="comment">//等同于 x -&gt; this.equals(x)。</span></span><br><span class="line"><span class="keyword">super</span>::instanceMethod</span><br></pre></td></tr></table></figure>

<h2 id="5-构造器引用"><a href="#5-构造器引用" class="headerlink" title="5. 构造器引用"></a>5. 构造器引用</h2><ol>
<li>构造器引用与方法引用很类似，只不过方法名为 new,编译器会根据上下文调用某个确定的构造器。</li>
<li>可以用数组类型建立构造器引用。</li>
<li>Java 有一个限制，无法构造泛型类型 T 的数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Person&gt; people = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[]::<span class="keyword">new</span> <span class="comment">//等价于 lambda 表达式 x -&gt; new int[x]</span></span><br><span class="line"></span><br><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h2 id="6-变量作用域"><a href="#6-变量作用域" class="headerlink" title="6. 变量作用域"></a>6. 变量作用域</h2><ol>
<li>lambda 表达式由3部分组成：一个代码块；参数；自由变量的值，指非参数而且不在代码中定义的变量。</li>
<li>自由变量被lambda表达式捕获：表示 lambda 表达式的数据结构必须存储自由变量的值。可以把一个 lambda 表达式转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中。</li>
<li>在 Java 中，lambda 表达式就是<strong>闭包</strong>。</li>
<li>要确保所捕获的变量是<strong>最终变量</strong>，在 lambda 表达式中，只能引用值不会改变的变量(不论是在lambda中改变还是在外部改变)，否则并发执行多个动作时就会不安全。</li>
<li>lambda 表达式的体与嵌套块有相同的作用域。在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</li>
<li>在一个 lambda 表达式中使用 this 关键字时， 是指创建这个 lambda 表达式的方法的 this参数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ActionListener listener = event -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(text);    <span class="comment">//在这里，text 总是指示同一个 String 对象，所以捕获这个变量是合法的。</span></span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Path first = Paths.get(<span class="string">"usr/bin"</span>);</span><br><span class="line">Couparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ActionListener listener * event -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="function">print <span class="title">n</span><span class="params">(<span class="keyword">this</span>.toString()</span>)</span>; <span class="comment">//this.toString() 会调用 Application 对象的 toString方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-处理lambda表达式"><a href="#7-处理lambda表达式" class="headerlink" title="7. 处理lambda表达式"></a>7. 处理lambda表达式</h2><p>使用 lambda 表达式的重点是<font color=Crmison>延迟执行</font>，需要延迟执行的原因如下：</p>
<blockquote>
<p>在一个单独的线程中运行代码；<br>多次运行代码；<br>在算法的适当位置运行代码（例如， 排序中的比较操作；）<br>发生某种情况时执行代码（如， 点击了一个按钮， 数据到达， 等等；）<br>只在必要时才运行代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n, Runnable action)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) action.run();   <span class="comment">//调用 action.run() 时会执行这个 lambda 表达式的主体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntConsumer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n, IntConsumer action)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) action.accept(i); <span class="comment">//告诉这个动作它出现在哪一次迭代中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大多数标准函数式接口都提供了非抽象方法来生成或合并函数。</span></span><br><span class="line">Predicate.isEqual(a);  <span class="comment">//等同于 a::equals</span></span><br><span class="line">Predicate.isEqual(a).or(Predicate.isEqual(b)); <span class="comment">//等同于 x -&gt; a.equals(x) || b.equals(x)</span></span><br></pre></td></tr></table></figure>
<p>如果使用注解@FunctionalInterface标记一个自己设计的接口，该接口只有一个抽象方法，则若无意中增加了另一个非抽象方法， 编译器会产生一个错误消息。另外 javadoc 页里会指出你的接口是一个函数式接口。<br><img src="%E6%8E%A5%E5%8F%A31.png" alt="常用函数式接口"></p>
<hr>
<p><img src="%E6%8E%A5%E5%8F%A32.png" alt="常用函数式接口"></p>
<h2 id="8-再谈-Comparator"><a href="#8-再谈-Comparator" class="headerlink" title="8. 再谈 Comparator"></a>8. 再谈 Comparator</h2><p>Comparator 接口包含很多方便的静态方法来创建比较器。 这些方法可以用于 lambda 表达式或方法引用。静态 comparing 方法取一个“键提取器” 函数，它将类型 T 映射为一个可比较的类型。(如 String)。对要比较的对象应用这个函数， 然后对返回的键完成比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(people,Comparator.comparing(Person::getName)); <span class="comment">//按名字对这些对象排序</span></span><br><span class="line">Arrays.sort(people,Comparator.comparing(Person::getlastName).thenConiparing(Person::getFirstName)); <span class="comment">//如果两个人的姓相同， 就会使用第二个比较器。</span></span><br><span class="line">Arrays.sort(people, Comparator.comparing(Person::getName, (s, t) -&gt; Integer.compare(s.length(), t.length())));  <span class="comment">//根据人名长度完成排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//comparing 和 thenComparing 方法都有变体形式，可以避免 int、 long 或 double 值的装箱。</span></span><br><span class="line">Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));  </span><br><span class="line"></span><br><span class="line">Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder())));  <span class="comment">//使用nullsFirst 和 nullsLast 适配器可使在遇到 null 值时不会抛出异常</span></span><br><span class="line">naturalOrder().reversed(); <span class="comment">//让比较器逆序比较</span></span><br></pre></td></tr></table></figure>

<h1 id="四、内部类"><a href="#四、内部类" class="headerlink" title="四、内部类"></a>四、内部类</h1><p>使用内部类的主要原因：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</li>
</ol>
<h2 id="1-使用内部类访问对象状态"><a href="#1-使用内部类访问对象状态" class="headerlink" title="1. 使用内部类访问对象状态"></a>1. 使用内部类访问对象状态</h2><ol>
<li>内部类位于外部类的内部，但<font color=Crmison>不是每个外部类对象都有一个内部类对象的实例域，内部类对象是由外部类的方法构造的。</font></li>
<li>内部类既可以访问自身的数据域，也可以直接访问创建它的外围类对象的所有成员(包括private成员和静态成员)。即使用内部类可以不必提供仅用于访问其他类的访问器。</li>
<li>外部类只能通过创建成员内部类的对象，再通过指向这个对象的引用来访问。</li>
<li>只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。若内部类声明为私有的，则只有外部类的方法才能够构造内部类对象。</li>
</ol>
<hr>
<p>内部类能够访问外部类成员的原因是内部类的对象总有一个隐式引用，它指向了创建它的外部类对象，这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。因为 TimePrinter 类没有定义构造器，所以编译器为这个类生成了一个默认的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interval = interval;</span><br><span class="line">        <span class="keyword">this</span>.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ActionListener listener = <span class="keyword">new</span> TimePrinter();   <span class="comment">//当在 start 方法中创建了 TimePrinter 对象后，编译器就会将 this 引用传递给当前的语音时钟的构造器:</span></span><br><span class="line">                                                            <span class="comment">//ActionListener listener = new TimePrinter(this);</span></span><br><span class="line">        Timer t = <span class="keyword">new</span> Timer(interval, listener); t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span>   <span class="comment">//因为 TimePrinter 类没有定义构造器，所以编译器为这个类生成了一个默认的构造器：</span></span></span><br><span class="line"><span class="function">        </span>&#123;                                                <span class="comment">//public TimePrinter(TalkingGock clock)&#123;outer = clock;&#125;</span></span><br><span class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();   <span class="comment">//if(beep)等价于outer.beep  outer 不是 Java 的关键字,只是用它说明内部类中的机制</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-内部类的特殊语法规则"><a href="#2-内部类的特殊语法规则" class="headerlink" title="2. 内部类的特殊语法规则"></a>2. 内部类的特殊语法规则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用外围类引用的正规语法</span></span><br><span class="line">OuterClass.<span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TalkingClock.<span class="keyword">this</span>.beep) Toolkit.getDefaultToolkit().beep(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//明确地编写内部对象的构造器语法规则</span></span><br><span class="line">outerObject.<span class="keyword">new</span> InnerClass(construction parameters)</span><br><span class="line"></span><br><span class="line">ActionListener listener = <span class="keyword">this</span>.<span class="keyword">new</span> TimePrinter();  <span class="comment">//this 限定词是多余的,不过，可以通过显式地命名将外围类引用设置为其他的对象。</span></span><br><span class="line"></span><br><span class="line">TalkingClock jabberer = <span class="keyword">new</span> TalkingClock(<span class="number">1000</span>, <span class="keyword">true</span>);</span><br><span class="line">TalkingClock.TimePrinter listener = jabberer.<span class="keyword">new</span> TimePrinter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在外围类的作用域之外，可以这样引用内部类：</span></span><br><span class="line">OuterClass.InnerClass</span><br></pre></td></tr></table></figure>

<ol>
<li>内部类中声明的所有静态域都必须是 final,因为对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是 final,它可能就不是唯一的。</li>
<li><font color=Crmison>内部类不能有 static 方法。</font></li>
</ol>
<h2 id="3-内部类是否有用、必要和安全"><a href="#3-内部类是否有用、必要和安全" class="headerlink" title="3. 内部类是否有用、必要和安全"></a>3. 内部类是否有用、必要和安全</h2><p>当使用了内部类的时候，编译器做了这样一件事：它在外围类添加了一个静态方法 <code>static boolean access$0(外部类);</code>内部类方法将调用这个函数。这个是有风险的，因为任何人都可以通过access$0方法很容易的读取到外围类的私有域。黑客可以使用十六进制编辑器轻松创建一个用虚拟机指令调用这个函数的类文件。即如果内部类访问了私有数据域，就有可能通过附加在外围类所在的包中的其他类访问它们，应慎用。</p>
<h2 id="4-局部内部类"><a href="#4-局部内部类" class="headerlink" title="4. 局部内部类"></a>4. 局部内部类</h2><ol>
<li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。局部类有一个优势， 即对外部世界可以完全地隐藏起来。</li>
<li>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit.beep(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener); </span><br><span class="line">    t.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-由外部方法访问变量"><a href="#5-由外部方法访问变量" class="headerlink" title="5. 由外部方法访问变量"></a>5. 由外部方法访问变量</h2><p>//局部类不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须<font color=Crmison>事实上为</font> final，一旦赋值就绝不会改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"At the tone, the tiie is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit.beep(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener); </span><br><span class="line">    t.start();  <span class="comment">//将调用actionPerformed方法，此时局部变量beep已经被销毁，因此编译器会在局部类内部自动生成一个beep的拷贝final boolean val$beep;当创建一个对象的时候，beep 就会</span></span><br><span class="line">                <span class="comment">//被传递给构造器，并存储在 val$beep 域中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6. 匿名内部类"></a>6. 匿名内部类</h2><ol>
<li>如果只创建这个类的一个对象，就不必命名了，称为匿名内部类。</li>
<li>匿名内部类没有类名故不能有构造器，而是将构造器参数传递给超类构造器。<font color=Crmison>且在内部类实现接口的时候，不能有任何构造参数。</font></li>
<li>使用匿名内部类的解决方案比较简短、更切实际、更易于理解。</li>
<li>使用匿名内部类可以实现事件监听器和其他回调，但不如lambda表达式简洁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> ActionListener() <span class="comment">//创建一个实现 ActionListener 接口的类的新对象，需要实现的方法 actionPerformed 定义在括号内。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date())；</span><br><span class="line">            <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener); </span><br><span class="line">    t.start(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用语法</span></span><br><span class="line"><span class="keyword">new</span> SuperType(construction parameters) </span><br><span class="line">&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span>   //<span class="title">SuperType</span> 可以是接口也可以是类。若是接口则必须实现它，若是类，则内部类就要扩展它。</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Person</span> <span class="title">queen</span> </span>= <span class="keyword">new</span> Person(<span class="string">"Mary"</span>); <span class="comment">// 一个Person对象</span></span><br><span class="line">Person count = <span class="keyword">new</span> Person(<span class="string">"Dracula"</span>) &#123; . . . &#125;;<span class="comment">// 一个扩展了Person类的内部类对象</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>双括号初始化技巧</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果不再需要这个数组列表，最好让它作为一个匿名列表。</span></span><br><span class="line">invite(<span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123; add(<span class="string">"Harry"</span>); add(<span class="string">"Tony"</span>); &#125;&#125;);  <span class="comment">//外层括号建立了 ArrayList 的一个匿名子类。内层括号则是一个对象构造块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成日志或调试消息时， 通常希望包含当前类的类名</span></span><br><span class="line"><span class="comment">//静态方法没有 this，在静态方法中获取所在类的类名方式如下：</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;&#125;.getClass().getEnclosingClass();  <span class="comment">//new Object()&#123;&#125; 会建立 Object 的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类。</span></span><br></pre></td></tr></table></figure>

<h2 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7. 静态内部类"></a>7. 静态内部类</h2><ol>
<li>静态内部类使用static关键字声明，就不会对外部类对象产生引用，使用静态内部类通常只是为了把一个类隐藏在另外一个类的内部。</li>
<li>只有内部类可以声明为 static。</li>
<li>静态内部类对象是在静态方法中构造的。</li>
<li>与常规内部类不同，静态内部类可以有静态域和方法。</li>
<li>声明在接口中的内部类自动成为 static 和 public 类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            first = f;</span><br><span class="line">            second = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">minmax</span><span class="params">(doublet[] values)</span>  <span class="comment">//ArrayAlg.Pair p = ArrayAlg.minmax(d);</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">double</span> min = Double.POSITIVE_NFINITY;</span><br><span class="line">            <span class="keyword">double</span> max = Double.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> v : values)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; v) min = v;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; v) max = v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(min, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、代理"><a href="#五、代理" class="headerlink" title="五、代理"></a>五、代理</h1><h2 id="1-何时使用代理"><a href="#1-何时使用代理" class="headerlink" title="1. 何时使用代理"></a>1. 何时使用代理</h2><ol>
<li>代理类可以实现指定的接口，可以在运行时创建全新的类。这样就可以在编译时获得一个表示接口对象的确切类型。</li>
<li>不能在运行时定义<font color=Crmison>指定接口和Object类中的全部方法</font>，而是要提供一个调用处理器。调用处理器是实现了 InvocationHandler 接口的类对象。</li>
<li>无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用，并向其传递Method 对象和原始的调用参数。 调用处理器必须给出处理调用的方式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  <span class="comment">//实现调用处理器接口中的方法</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-创建代理对象"><a href="#2-创建代理对象" class="headerlink" title="2. 创建代理对象"></a>2. 创建代理对象</h2><p>创建代理对象需要使用Proxy 类的 newProxylnstance 方法，它包含三个参数</p>
<ul>
<li>一个类加载器，用 null 可表示使用默认的类加载器。</li>
<li>一个 Class 对象数组， 每个元素都是需要实现的接口。</li>
<li>一个调用处理器。</li>
</ul>
<p>使用代理可机制可解决的问题，例：</p>
<ul>
<li>路由对远程服务器的方法调用。</li>
<li>在程序运行期间，将用户接口事件与动作关联起来。</li>
<li>为调试， 跟踪方法调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceHandler</span><span class="params">(Object t)</span> </span>&#123;</span><br><span class="line">        target = t;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span> <span class="params">(Object proxy, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">        </span>&#123;    <span class="comment">// 打印方法名和参数</span></span><br><span class="line">            System.out.print(target);  <span class="comment">//打印隐式参数</span></span><br><span class="line">            System,out.print(<span class="string">"."</span> + m.getName() + <span class="string">"("</span>);  <span class="comment">//打印方法名</span></span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;   <span class="comment">//打印显式参数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) </span><br><span class="line">                &#123;</span><br><span class="line">                    System,out.print(args[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; args.length - <span class="number">1</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System,out.println(<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用真正的方法</span></span><br><span class="line">            <span class="keyword">return</span> m.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造用于跟踪方法调用的代理对象</span></span><br><span class="line">Object value = ...</span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> TraceHandler(value) ; <span class="comment">// 为一个或多个接口构造代理</span></span><br><span class="line">Class[] interfaces = <span class="keyword">new</span> Class[] &#123;Comparable<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">Object proxy = Proxy.newProxylnstance(<span class="keyword">null</span> , interfaces, handler); <span class="comment">//无论何时用 proxy 调用某个方法， 这个方法的名字和参数就会打印出来，之后再用 value 调用它。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应用：使用代理对象对二分查找过程进行跟踪。</span></span><br><span class="line">Object[] elements = <span class="keyword">new</span> Object[<span class="number">1000</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i ++) </span><br><span class="line">&#123;</span><br><span class="line">    Integer value = i + <span class="number">1</span>;  <span class="comment">//Integer 类实现了 Comparable 接口。代理对象属于在运行时定义的类（它有一个名字， 如 $ProxyO) 这个类也实现了Comparable 接口,且会调用代理对象处理器的invoke方法。</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> TraceHandler(value);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(<span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123; Comparable<span class="class">.<span class="keyword">class</span> &#125;,<span class="title">handler</span>)</span>;</span><br><span class="line">    elements[i] = proxy <span class="comment">//数组代理</span></span><br><span class="line">&#125;</span><br><span class="line">Integer key = <span class="keyword">new</span> Random().nextlnt(elements.length) + <span class="number">1</span>;   </span><br><span class="line"><span class="keyword">int</span> result = Arrays.binarySearch(elements, key) ; <span class="comment">//查找元素,由于数组中填充了代理对象， 所以 compareTo 调用了 TraceHander 类中的 invoke 方法。这个方法打印出了方法名和参数，之后用包装好的 </span></span><br><span class="line">                                                <span class="comment">//Integer 对象调用 compareTo。</span></span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) System.out.println(elements[result]); <span class="comment">//打印元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">500</span>.compareTo(<span class="number">288</span>) <span class="number">2</span>SO.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">375</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">312</span>. compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">281</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">296</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">288</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">288</span>.toString()   <span class="comment">//即使不属于 Comparable 接口，toString 方法也被代理，实际上有相当一部分的Object 方法都被代理。</span></span><br></pre></td></tr></table></figure>
<p>Integer 类实际上实现了<code>Comparable&lt;Integer&gt;</code>。然而，在运行时，所有的泛型类都被取消，代理将它们构造为原 <code>Comparable</code> 类的类对象。</p>
<h2 id="3-代理类的特性"><a href="#3-代理类的特性" class="headerlink" title="3. 代理类的特性"></a>3. 代理类的特性</h2><ol>
<li>代理类是在程序运行过程中创建的，一旦被创建，就变成了常规类。</li>
<li>所有的代理类都扩展于 Proxy 类。一个代理类只有一个实例域———调用处理器，它定义在 Proxy 的超类中。</li>
<li>为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。</li>
<li>所有的代理类都覆盖了 Object 类中的方法 toString、 equals 和 hashCode。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的 invoke，Object 类中的其他方法（如 clone和 getClass) 没有被重新定义。</li>
<li>没有定义代理类的名字，Sun 虚拟机中的 Proxy类将生成一个以字符串 $Proxy 开头的类名。</li>
<li>对于特定的类加载器和预设的一组接口来说，只能有一个代理类。</li>
<li>代理类一定是 public 和 final。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler</span><br><span class="line"><span class="comment">//如果使用同一个类加载器和接口数组调用两次 newProxylustance方法的话， 那么只能够得到同一个类的两个对象</span></span><br><span class="line">Class proxyClass = Proxy.getProxyClass(<span class="keyword">null</span>, interfaces);  <span class="comment">//可以利用 getProxyClass方法获得这个类</span></span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span>  <span class="comment">//定义了代理对象调用方法时希望执行的动作。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class&lt;?&gt;...interfaces)</span>  <span class="comment">//返回实现指定接口的代理类。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</span>  <span class="comment">//构造实现指定接口的代理类的一个新实例。所有方法会调用给定处理器对象的 invoke 方法。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span>  <span class="comment">//如果 cl 是一个代理类则返回 true。</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的异常、断言和日志</title>
    <url>/2020/05/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="一、处理错误"><a href="#一、处理错误" class="headerlink" title="一、处理错误"></a>一、处理错误</h1><h2 id="1-异常分类"><a href="#1-异常分类" class="headerlink" title="1. 异常分类"></a>1. 异常分类</h2><p>所有的异常都是由 Throwable 继承而来的，异常的继承层次如下：<br><img src="%E5%BC%82%E5%B8%B8.png" alt="异常"></p>
<ol>
<li><strong>Error</strong>: 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。<font color=Crmison>应用程序不应该抛出这种类型的对象,因为我们对其没有任何控制能力。</font></li>
<li><strong>Exception</strong>：由程序错误导致的异常属于 RuntimeException ; 而程序本身没有问题， 但由于像 I/O 错误这类问题导致的异常属于其他异常。</li>
<li><strong>派生于RuntimeException的异常</strong>：错误的类型转换;数组访问越界;访问 null 指针。<font color=Crmison>这些异常也不该声明，因为这些运行时错误完全在我们的控制之下。</font></li>
<li><strong>不是派生于RuntimeException的异常</strong>: 试图在文件尾部后面读取数据; 试图打开一个不存在的文件; 试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在。</li>
<li><strong>非受查异常</strong>：派生于Error类或 RuntimeException 类的所有异常称为非受查异常。</li>
<li><strong>受查异常</strong>: 所有其它异常。编译器将核查是否为所有的受査异常提供了异常处理器。否则代码不能通过编译。</li>
</ol>
<h2 id="2-声明受查异常"><a href="#2-声明受查异常" class="headerlink" title="2. 声明受查异常"></a>2. 声明受查异常</h2><ol>
<li>一个方法必须声明(<strong>throws</strong>)所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生（ RuntimeException)。</li>
<li>若方法在运行时真的抛出了一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理它。</li>
<li>如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用和更多。</li>
<li>如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。而是必须捕获所有受查异常。</li>
<li>抛出异常的情况有4种：</li>
</ol>
<ul>
<li>调用一个抛出受査异常的方法；</li>
<li>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常；</li>
<li>程序出现错误，例如，a[-1]=0 会抛出一个 ArraylndexOutOfBoundsException 这样的非受查异常。</li>
<li>Java 虚拟机和运行时库出现的内部错误。</li>
</ul>
<ol start="6">
<li>如果类中的一个方法声明将会抛出一个异常， 而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常， 或者这个类的任意一个子类的异常。</li>
<li>在 Java中，没有 throws 说明符的方法将不能抛出任何受查异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">loadlmage</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException,FileNotFoundException,EOFException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-如何抛出异常"><a href="#3-如何抛出异常" class="headerlink" title="3. 如何抛出异常"></a>3. 如何抛出异常</h2><ol>
<li>找到一个合适的异常类。</li>
<li>创建这个类的一个对象。</li>
<li>使用<strong>throw</strong>关键字将对象抛出。</li>
</ol>
<p>如果只是抛出异常而不在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。即一旦方法抛出了异常，这个方法就不可能返回到调用者，除非进行异常捕获。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException  <span class="comment">//声明异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (…) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();  <span class="comment">//抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-创建异常类"><a href="#4-创建异常类" class="headerlink" title="4. 创建异常类"></a>4. 创建异常类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFormatException</span> <span class="keyword">extends</span> <span class="title">IOException</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">(String gripe)</span>   <span class="comment">//超类 Throwable 的 toString 方法将会打印出这些详细信息， 这在调试中非常有用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(gripe); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(BufferedReader in)</span> <span class="keyword">throws</span> FileFormatException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (…) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileFornatException();  <span class="comment">//抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Throwable常用API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Throwable;</span><br><span class="line"></span><br><span class="line">Throwable( ) <span class="comment">//构造一个新的 Throwabie 对象， 这个对象没有详细的描述信息。</span></span><br><span class="line">Throwable(String message ) <span class="comment">//构造一个新的 throwable 对象， 这个对象带有特定的详细描述信息。习惯上，所有派生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器。</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">( )</span>  <span class="comment">//获得 Throwable 对象的详细描述信息。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="二、捕获异常"><a href="#二、捕获异常" class="headerlink" title="二、捕获异常"></a>二、捕获异常</h1><h2 id="1-捕获异常"><a href="#1-捕获异常" class="headerlink" title="1. 捕获异常"></a>1. 捕获异常</h2><p>如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> Filei叩utStream(filename);</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()<span class="number">3</span> != -<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            process input</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException exception) </span><br><span class="line">    &#123;</span><br><span class="line">        exception.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果在try语句块中的任何代码抛出了一个在 catch 子句中说明的异常类,则程序将跳过 try语句块的其余代码并执行catch 子句中的处理器代码，否则将跳过 catch 子句。</li>
<li>如果方法中的任何代码拋出了一个在 catch 子句中没有声明的异常类型，或者仅仅是声明了可能抛出的异常，那么这个异常就会传递给调用者进行处理。</li>
<li>如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递。</li>
<li>如果想传递一个异常， 就必须在方法的首部添加一个 throws 说明符， 以便告知调用者这个方法可能会抛出异常。</li>
<li>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。</li>
</ol>
<h2 id="2-捕获多个异常"><a href="#2-捕获多个异常" class="headerlink" title="2. 捕获多个异常"></a>2. 捕获多个异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might throwexceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> missing files</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnknownHostException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> unknown hosts</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> all other I/O problems</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当捕获的异常类型彼此之间不存在子类关系且多个异常的处理动作一样时，同一个 catch 子句中可以捕获多个异常类型。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e)  <span class="comment">//捕获多个异常不仅会让你的代码看起来更简单，还会更高效。</span></span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> missing files and unknown hosts  <span class="comment">//捕获多个异常时， 异常变量隐含为 final 变量。即不能在此处为e赋不同的值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> all other I/O problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-再次抛出异常与异常链"><a href="#3-再次抛出异常与异常链" class="headerlink" title="3. 再次抛出异常与异常链"></a>3. 再次抛出异常与异常链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//再次抛出异常的基本方法</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException e) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"database error: "</span> + e.getMessage()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原始异常设置为新异常的“原因”,这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">    Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Throwable e = se.getCause();  <span class="comment">//当捕获到异常时， 就可以使用下面这条语句重新得到原始异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只想记录一个异常， 再将它重新抛出，而不做任何改变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateRecord</span><span class="params">()</span> <span class="keyword">throws</span> SQLException  <span class="comment">//抛出的异常比声明的异常更通用时，Java SE7之前编译器会指出这个方法可以抛出任何 Exception 而不只是 SQLException。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        access the database</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)  <span class="comment">//Java SE7之后，编译器会跟踪到 e 来自 try块。假设这个 try 块中仅有的已检査异常是 SQLException 实例，另外，假设 e 在catch 块中未改变，将外围方法声明为 throws </span></span><br><span class="line">                        <span class="comment">//SQLException 就是合法的。</span></span><br><span class="line">    &#123;</span><br><span class="line">        logger.log(level, message, e);</span><br><span class="line">        <span class="keyword">throw</span> e; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-finally-子句"><a href="#4-finally-子句" class="headerlink" title="4. finally 子句"></a>4. finally 子句</h2><p>在需要关闭资源时，通常需要使用finally子句。<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(. . .);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//可能抛出异常的代码</span></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="comment">//展示异常信息</span></span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure><br> 代码执行顺序有三种情况：</p>
<ol>
<li>代码没有抛出异常：执行顺序为 1，2，5，6。</li>
<li>抛出一个在 catch 子句中捕获的异常：</li>
</ol>
<ul>
<li>当catch字句没有抛出异常将执行 1，3，4，5，6。</li>
<li>当catch字句抛出了一个异常，在执行完1，3，5之后异常将被抛回这个方法的调用者。</li>
</ul>
<ol start="3">
<li><p>代码抛出了一个异常， 但这个异常不是由 catch 子句捕获的：在执行 1，5 后将异常抛给这个方法的调用者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//try 语句可以只有 finally 子句，而没有 catch 子句。</span></span><br><span class="line">InputStream in = . .</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might throwexceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    in.close();  <span class="comment">//不论try中是否遇到异常，该语句都将被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解耦合 try/catch 和 try/finally 语句块</span></span><br><span class="line">InputStrean in = . . .;</span><br><span class="line"><span class="comment">//外层的try语句块仅确保报告出现的错误。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 内层的try语句块仅确保关闭输入流。</span></span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;</span><br><span class="line">        code that might throwexceptions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        in.close();   <span class="comment">//若try语句中和finally语句中同时抛出异常则finally语句中的异常将会覆盖原始异常，转而抛出close方法的异常，此时需要用到带资源的try语句进行处理。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在try-catch-finally语句中使用return语句会带来的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = n * n;</span><br><span class="line">        <span class="keyword">return</span> r;    <span class="comment">//在方法返回前，finally 子句的内容将被执行。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n = <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这个返回值覆盖了原始的返回值。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-带资源的-try-语句"><a href="#5-带资源的-try-语句" class="headerlink" title="5. 带资源的 try 语句"></a>5. 带资源的 try 语句</h2><ol>
<li>若资源属于一个实现了 AutoCloseable 接口(close方法声明抛出Exception异常)或其子接口 Closeable 接口(close方法声明抛出IOException异常)的类，则try块退出时，会自动调用 <code>resource.close()</code>。</li>
<li>带资源的try语句会抛出原来的异常，而 close方法抛出的异常会“ 被抑制”，被抑制的异常将自动捕获，并由 <code>addSuppressed</code> 方法增加到原来的异常。可以调用 <code>getSuppressed</code> 方法得到从 close 方法抛出并被抑制的异常列表。</li>
<li>带资源的 try 语句自身也可以有 catch 子句和一个 finally 子句。这些子句会在关闭资源之后执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不论正常退出还是存在异常，都会调用resource.close()方法，就好像使用了fianlly块。</span></span><br><span class="line"><span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"usr/share/dict/words"</span>), <span class="string">"UTF-8"</span>);  <span class="comment">//可指定多个资源，不论块如何退出，in和out都会关闭而避免嵌套2个try-finally语句。</span></span><br><span class="line">    PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"out.txt"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        out.println(in.next().toUpperCase());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-分析堆栈轨迹元素"><a href="#6-分析堆栈轨迹元素" class="headerlink" title="6. 分析堆栈轨迹元素"></a>6. 分析堆栈轨迹元素</h2><p>堆栈轨迹是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述信息</span></span><br><span class="line">Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">StringWriter out = <span class="keyword">new</span> <span class="function">StringWri <span class="title">ter</span><span class="params">()</span></span>; </span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> PrintWriter(out));</span><br><span class="line">String description = out.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 getStackTrace 方法， 它会得到 StackTraceElement 对象的一个数组，可以在程序中分析这个对象数组。</span></span><br><span class="line">Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement frame : frames)</span><br><span class="line">    analyze frame</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态的 Thread.getAllStackTrace 方法， 它可以产生所有线程的堆栈轨迹 </span></span><br><span class="line">Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();</span><br><span class="line"><span class="keyword">for</span> (Thread t : map.keySet()) &#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    analyze frames</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、使用异常机制的技巧"><a href="#三、使用异常机制的技巧" class="headerlink" title="三、使用异常机制的技巧"></a>三、使用异常机制的技巧</h1><ol>
<li>异常处理不能代替简单的测试；</li>
<li>不要过分地细化异常；</li>
<li>利用异常层次结构(应该寻找更加适当的子类或创建自己的异常类)；</li>
<li>不要压制异常(应该将很大概率不会抛出的异常关闭)；</li>
<li><strong>早抛出：</strong>在检测错误时，“ 苛刻 ” 要比放任更好;</li>
<li><strong>晚捕获：</strong>不要羞于传递异常(传递给高层要比捕获异常更加合适)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// code that threatens to throw checked exceptions</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)  <span class="comment">//即使发生了异常也会被忽略。</span></span><br><span class="line">    &#123;&#125; <span class="comment">// so there</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、使用断言"><a href="#四、使用断言" class="headerlink" title="四、使用断言"></a>四、使用断言</h1><h2 id="1-断言的概念"><a href="#1-断言的概念" class="headerlink" title="1. 断言的概念"></a>1. 断言的概念</h2><p>断言(assert)机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//均对表达式进行检测，若结果为 false, 则抛出一个 AssertionError 异常。</span></span><br><span class="line"><span class="keyword">assert</span> 条件;</span><br><span class="line"><span class="keyword">assert</span> 条件:表达式;  <span class="comment">//表达式将被传入 AssertionError 的构造器，并转换成一个消息字符串(表达式的唯一目的)，表达式的值不会被存储。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span>; <span class="comment">//断言 x 是一个非负数值</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若希望条件也生成错误报告的一部分，就必须将它以字符串的形式传递给 AssertionError 对象。</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">"x &gt;= 0"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-启用和禁用断言"><a href="#2-启用和禁用断言" class="headerlink" title="2. 启用和禁用断言"></a>2. 启用和禁用断言</h2><ol>
<li>在默认情况下，断言被禁用。</li>
<li>在启用或禁用断言时不必重新编译程序，因为这是类加载器的功能，当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。</li>
<li>可以在某个类或整个包中使用断言。</li>
<li>有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。</li>
<li>启用和禁用所有断言的 -ea 和 -da 开关不能应用到那些没有类加载器的“系统类” 上,此时应使用 -enablesystemassertions/-esa 开关启用断言。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -enableassertions MyApp</span><br><span class="line">java -ea:MyClass -ea:com.mycompany.mylib...  MyApp <span class="comment">//开启 MyClass 类以及在 com.mycompany.mylib 包和它的子包中的所有类的断言。</span></span><br><span class="line"></span><br><span class="line">java -ea:... -da:MyClass MyApp  <span class="comment">//用选项 -disableassertions 或 -da 禁用某个特定类和包的断言</span></span><br></pre></td></tr></table></figure>

<h2 id="3-使用断言完成参数检查"><a href="#3-使用断言完成参数检查" class="headerlink" title="3. 使用断言完成参数检查"></a>3. 使用断言完成参数检查</h2><ol>
<li>断言失败是致命的、不可恢复的错误，有时候会拋出一个断言错误，有时候会产生一个 null 指针异常，这完全取决于类加载器的配置。</li>
<li>断言检查只用于开发和测阶段。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> a != <span class="keyword">null</span>; <span class="comment">//检查参数是否非空</span></span><br></pre></td></tr></table></figure>

<h2 id="4-为文档假设使用断言"><a href="#4-为文档假设使用断言" class="headerlink" title="4. 为文档假设使用断言"></a>4. 为文档假设使用断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// (i % 3 == 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为以上注释使用断言</span></span><br><span class="line"><span class="keyword">assert</span> i &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span> i % <span class="number">3</span> == <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ClassLoader;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultAssertionStatus</span><span class="params">( <span class="keyword">boolean</span> b )</span> <span class="comment">//对于通过类加载器加载的所有类来说， 如果没有显式地说明类或包的断言状态， 就启用或禁用断言。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCIassAssertionStatus</span><span class="params">(String className , <span class="keyword">boolean</span> b )</span> <span class="comment">//对于给定的类和它的内部类，启用或禁用断言。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPackageAssertionStatus</span><span class="params">( String packageName , bool ean b )</span> <span class="comment">//对于给定包和其子包中的所有类，启用或禁用断言。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAssertionStatus</span><span class="params">()</span> <span class="comment">//移去所有类和包的显式断言状态设置， 并禁用所有通过这个类加载器加载的类的断言。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="五、记录日志"><a href="#五、记录日志" class="headerlink" title="五、记录日志"></a>五、记录日志</h1><h2 id="1-基本日志"><a href="#1-基本日志" class="headerlink" title="1. 基本日志"></a>1. 基本日志</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用全局日志记录器生成简单的日志记录</span></span><br><span class="line">Logger.getClobal().info(<span class="string">"File-&gt;Open menu item selected"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在适当的地方（如 main 开始）调用将会取消所有的日志</span></span><br><span class="line">Logger.getClobal().setLevel(Level.OFF);</span><br></pre></td></tr></table></figure>

<h2 id="2-高级日志"><a href="#2-高级日志" class="headerlink" title="2. 高级日志"></a>2. 高级日志</h2><ol>
<li>不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义日志记录器。</li>
<li>未被任何变量引用的日志记录器可能会被垃圾回收，因此需要用一个静态变量存储日志记录器的一个引用。</li>
<li>日志记录器名也具有层次结构,父与子之间将会共享某些属性，例如，若对父日志记录器设置了日志级别，它的子记录器也会继承这个级别。</li>
<li>默认的日志配置记录了 INFO 或更高级别的所有记录，如果将记录级别设计为 INFO 或者更低， 则需要修改日志处理器的配置。</li>
<li>应该使用 CONFIG、FINE, FINER 和 FINEST 级别来记录那些有助于诊断，但对于程序员又没有太大意义的调试信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建或获取记录器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger myLogger = Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7 个日志记录器级别</span></span><br><span class="line">SEVERE</span><br><span class="line">WARNING</span><br><span class="line">INFO</span><br><span class="line">CONFIG</span><br><span class="line">FINE</span><br><span class="line">FINER</span><br><span class="line">FINEST</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况下，只记录前三个级别。 也可以设置其他的级別，还可以使用Level.ALL 开启所有级别的记录， 或者使用 Level.OFF 关闭所有级别的记录</span></span><br><span class="line">logger.setLevel(Level.FINE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志记录方法</span></span><br><span class="line">logger.warning(message);</span><br><span class="line">logger.fine(message);</span><br><span class="line">logger.log(Level.FINE, message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的日志记录将显示包含日志调用的类名和方法名,但是,如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以调用 logp 方法获得调用类和方法的确切位置。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logp</span><span class="params">(Level l, String className, String methodName, String message)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用来跟踪执行流的方法,将生成 FINER 级别和以字符串 ENTRY 和 RETURN 开始的日志记录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entering</span><span class="params">(String dassName , String methodName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entering</span><span class="params">(String className , String methodName , Object param)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entering</span><span class="params">(String className , String methodName , Object[] params)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exiting</span><span class="params">(String className , String methodName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exiting</span><span class="params">(String className , String methodName , Object result)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="comment">//记录日志的常见用途是记录那些不可预料的异常。</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOException exception = <span class="keyword">new</span> IOException(<span class="string">". . ."</span>);</span><br><span class="line">    logger.throwing(<span class="string">"com•mycompany.mylib.Reader"</span>, <span class="string">"read"</span>, exception); <span class="comment">//调用 throwing 可以记录一条 FINER 级别的记录和一条以 THROW 开始的信息。</span></span><br><span class="line">    <span class="keyword">throw</span> exception; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>).log(Level.WARNING , <span class="string">"Reading image"</span>, e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-修改日志管理器配置"><a href="#3-修改日志管理器配置" class="headerlink" title="3. 修改日志管理器配置"></a>3. 修改日志管理器配置</h2><ol>
<li>可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下，配置文件存在于：<code>jre/lib/1ogging.properties</code>。</li>
<li>也可将 <code>java.util.logging.config.file</code> 特性设置为配置文件的存储位置来使用另一个配置文件。</li>
<li>日志记录并不将消息发送到控制台上，这是处理器的任务。</li>
<li>在曰志管理器配置的属性设置不是系统属性，不会对日志记录器产生任何影响。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//日志管理器在 VM 启动过程中初始化，这在 main 执行之前完成</span></span><br><span class="line">System.setProperty(<span class="string">"java.util.logging.config.file"</span>,file);  <span class="comment">//在main中调用该方法后也会调用 `LogManager.readConfiguration()` 来重新初始化曰志管理器。</span></span><br><span class="line"></span><br><span class="line">java -Djava.util.logging.config.file=configFile MainClass  <span class="comment">//使用另一个配置文件启动应用程序</span></span><br><span class="line"></span><br><span class="line">.level=INFO  <span class="comment">//编辑配置文件，修改默认的日志记录级别</span></span><br><span class="line">com.mycompany.myapp.level=FINE  <span class="comment">//指定自己的日志记录级别</span></span><br><span class="line"></span><br><span class="line">java.util.logging.ConsoleHandler.level=FINE  <span class="comment">//设置处理器级别以在控制台上看到 FINE 级别的消息</span></span><br></pre></td></tr></table></figure>

<h2 id="4-本地化"><a href="#4-本地化" class="headerlink" title="4. 本地化"></a>4. 本地化</h2><ol>
<li>本地化的应用程序包含资源包中的本地特定信息,资源包由各个地区的映射集合组成，日志消息本地化后让全球的用户都可以阅读它。。</li>
<li>每个资源包都有一个名字，要想将映射添加到一个资源包中，需要为每个地区创建一个文件(例如com/mycompany/logmessages_en.properties)，这些文件都是纯文本文件。</li>
<li>可以将这些文件与应用程序的类文件放在一起， 以便 ResourceBundle 类自动地对它们进行定位。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源包中的映射</span></span><br><span class="line">readingFile=Achtung! Datei wird eingelesen</span><br><span class="line">renamingFile=Datei wird umbenannt</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求日志记录器时指定一个资源包</span></span><br><span class="line">Logger logger = Logger.getLogger(loggerName , <span class="string">"com.mycompany.logmessages"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为日志消息指定资源包的关键字</span></span><br><span class="line">logger.info(<span class="string">"readingFile"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若需要在本地化的消息中增加一些参数， 因此，消息应该包括占位符&#123;0&#125;、&#123;1&#125;</span></span><br><span class="line">Reading file &#123;<span class="number">0</span>&#125;.</span><br><span class="line">Achtung! Datei &#123;<span class="number">0</span>&#125; wird eingelesen.</span><br><span class="line"><span class="comment">//调用下面的一个方法向占位符传递具体的值</span></span><br><span class="line">logger.log(Level.INFO, <span class="string">"readingFile"</span>, fileName);</span><br><span class="line">logger.log(Level.INFO, <span class="string">"renamingFile"</span>, <span class="keyword">new</span> Object[] &#123; oldName , newName &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-处理器"><a href="#5-处理器" class="headerlink" title="5. 处理器"></a>5. 处理器</h2><ol>
<li>默认情况下日志记录器将记录发送到 ConsoleHandler 中， 并由它输出到 System.err流中。</li>
<li>其他情况下，日志记录器还会将记录发送到父处理器中，而最终的处理器（命名为“ ”,所有日志记录器的父类）有一个 ConsoleHandler。</li>
<li>对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//日志管理器配置文件设置的默认控制台处理器的日志记录级别</span></span><br><span class="line">java.util.logging.ConsoleHandler.level =INFO</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改配置文件中的默认日志记录级别和处理器级别来改变处理器的默认设置</span></span><br><span class="line">Logger logger = Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>);</span><br><span class="line">logger.setLevel(Level.FINE); </span><br><span class="line">logger.setUseParentHandlers(<span class="keyword">false</span>); <span class="comment">//原始日志记录器将会把所有等于或高于 INFO 级別的记录发送到控制台,为了避免看到重复记录，应该将useParentHandlers 属性设置为 false。</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> ConsoleHandler();</span><br><span class="line">handler.setLevel(Level.FINE); </span><br><span class="line">logger.addHandler(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接将记录发送到默认文件的处理器，即用户主目录的 javan.log 文件中， n 是文件名的唯一编号。也可发送到其他地方，但需要添加其它的处理器，如FileHandler(特定文件)、SocketHandler(特定主机)。</span></span><br><span class="line"><span class="comment">//默认情况下， 记录被格式化为 XML</span></span><br><span class="line">FileHandler handler = <span class="keyword">new</span> FileHandler(); </span><br><span class="line">logger.addHandler(handler);</span><br></pre></td></tr></table></figure>

<h2 id="6-过滤器"><a href="#6-过滤器" class="headerlink" title="6. 过滤器"></a>6. 过滤器</h2><ol>
<li>默认情况下，过滤器根据日志记录的级别进行过滤。每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤。</li>
<li>也可自定义过滤器，并调用setFilter 方法将一个过滤器安装到一个日志记录器或处理器中，注意一时刻最多只能有一个过滤器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过实现 Filter 接口并定义下列方法来自定义过滤器。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLoggable</span><span class="params">(LogRecord record)</span>  <span class="comment">//可以利用自己喜欢的标准，对日志记录进行分析，返回 true 表示这些记录应该包含在日志中。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="7-格式化器"><a href="#7-格式化器" class="headerlink" title="7. 格式化器"></a>7. 格式化器</h2><p>对日志记录自定义格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩展 Formatter 类并覆盖下面这个方法实现自定义日志记录的格式</span></span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(LogRecord record)</span>  <span class="comment">//根据自己的愿望对记录中的信息进行格式化，并返冋结果字符串。</span></span></span><br><span class="line"><span class="function">String <span class="title">formatMessage</span><span class="params">(LogRecord record)</span>  <span class="comment">//这个方法对记录中的部分消息进行格式化、 参数替换和本地化应用操作，可在format方法中调用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//要覆盖下面两个方法，实现在已格式化的记录的前后加上一个头部和尾部</span></span></span><br><span class="line"><span class="function">String <span class="title">getHead</span> <span class="params">(Handler h)</span></span></span><br><span class="line"><span class="function">String <span class="title">getTail</span> <span class="params">(Handler h)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//最后，调用 setFormatter 方法将格式化器安装到处理器中。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六、调试技巧"><a href="#六、调试技巧" class="headerlink" title="六、调试技巧"></a>六、调试技巧</h1><ol>
<li>可以调用合适的方法打印或记录任意变量的值；</li>
<li>在每一个类中放置一个单独的 main方法对每一个类进行单元测试；</li>
<li>使用JUnit单元测试框架，详见<a href="http://junit.org" target="_blank" rel="noopener">http://junit.org</a> </li>
<li>使用日志代理截获方法调用， 并进行日志记录，然后调用超类中的方法。</li>
<li>利用 Throwable 类提供的 printStackTace 方法。</li>
<li>—般来说，堆栈轨迹显示在 System.err 上。也可以利用 <code>printStackTrace(PrintWriter s)</code>方法将它发送到一个文件中，还可将其捕获到一个字符串中。</li>
<li>将一个程序中的错误信息保存在一个文件中。</li>
<li>不让非捕获异常的堆栈轨迹出现在 System.err 中。</li>
<li>用 -verbose 标志启动 Java 虚拟机观察类的加载过程有助于诊断由于类路径引发的问题。</li>
<li>-Xlint 选项告诉编译器对一些普遍容易出现的代码逻辑问题进行检査。</li>
<li>java 虚拟机增加了对 Java 应用程序进行监控和管理的支持，例如jconsole 图形工具，对于像应用程序服务器这样大型的、 长时间运行的 Java 程序来说特别重要。</li>
<li>使用 jmap 实用工具获得一个堆的转储并进行探查，其中显示了堆中的每个对象。</li>
<li>使用 -Xprof 标志运行 Java 虚拟机，就会运行一个基本的剖析器来跟踪那些代码中经常被调用的方法。剖析信息将发送给 System.out。输出结果中还会显示哪些方法是由即时编译器编译的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">Logger.getClobal().info(<span class="string">"nx="</span> + x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志代理</span></span><br><span class="line">Random generator = <span class="keyword">new</span></span><br><span class="line">Random() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span>    <span class="comment">//当调用 nextDouble 方法时， 就会产生一个日志消息。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="keyword">super</span>.nextDouble()</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.getClobal().info(<span class="string">"nextDouble: "</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread.duapStack();  <span class="comment">//无须捕获异常，在代码的任何位置插入下面这条语句就可以获得堆栈轨迹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将对战轨迹捕获到一个字符串中</span></span><br><span class="line">StringWriter out = <span class="keyword">new</span> StringWriter();</span><br><span class="line"><span class="keyword">new</span> Throwable().printStackTrace(<span class="keyword">new</span> PrintWriter(out));</span><br><span class="line">String description = out.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个程序中的错误信息保存在一个文件中。</span></span><br><span class="line">java MyProgram <span class="number">2</span>&gt; errors.txt <span class="comment">//捕获错误流</span></span><br><span class="line">java MyProgram <span class="number">1</span>&gt; errors.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span> <span class="comment">//在同一个文件中同时捕获 System.en•和 System.out</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改变非捕获异常的处理器</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">    <span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            save information in logfile</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对代码的简单逻辑进行检查</span></span><br><span class="line">javac -Xlint:fallthrough</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示虚拟机性能的统计结果</span></span><br><span class="line">jconsole processID</span><br><span class="line"></span><br><span class="line"><span class="comment">//转储堆中的内容进行探查</span></span><br><span class="line">jmap -dump:format=b, file=dumpFileName processID</span><br><span class="line">jhat dumpFileName</span><br><span class="line"><span class="comment">//通过浏览器进人丨oCalhOSt:7000, 将会运行一个网络应用程序，借此探查转储对象时堆的内容。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的泛型程序设计</title>
    <url>/2020/05/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一、定义简单泛型类"><a href="#一、定义简单泛型类" class="headerlink" title="一、定义简单泛型类"></a>一、定义简单泛型类</h1><ol>
<li>一个泛型类就是具有一个或多个<strong>类型变量</strong>的类。</li>
<li>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。</li>
<li>类型变量使用大写形式，变量 E 表示集合的元素类型，K 和 V 分别表示表的关键字与值的类型，T 可表示任意类型。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，换句话说，泛型类可看作普通类的工厂。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义简单泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; first = <span class="keyword">null</span> ; second = <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123; <span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123; first = newValue; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123; second = newValue; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入多个类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123; . . . &#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、泛型方法"><a href="#二、泛型方法" class="headerlink" title="二、泛型方法"></a>二、泛型方法</h1><ol>
<li>可以定义一个带有类型参数的简单方法，称为泛型方法。</li>
<li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>
<li>当调用一个泛型方法时,在方法名前的尖括号中放入具体的类型,有些情况下具体类型可省略。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span> <span class="comment">//参数类型放在方法返回值前面</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用泛型方法</span></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>, <span class="string">"Q"</span>, <span class="string">"Public"</span>);</span><br><span class="line"><span class="comment">//编译器能够用 names 的类型（即 String[ ]) 与泛型类型 T[ ]进行匹配并推断出 T 一定是 String。故在这种情况下可省略类型参数。</span></span><br><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">"John"</span>, <span class="string">"Q"</span>, <span class="string">"Public"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器将会自动打包参数为 1 个Double 和 2 个 Integer 对象，而后寻找这些类的共同超类型为Number 和 Comparable 接口，此时会得到一个错误报告提示可以将结果赋给Number 或 Comparable 接口。</span></span><br><span class="line"><span class="comment">//可以使用这种方式有目的地引入一个错误，并研究编译器对一个泛型方法调用最终推断出哪种类型</span></span><br><span class="line"><span class="keyword">double</span> middle = ArrayAlg.getMiddle(<span class="number">3.14</span>, <span class="number">1729</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="三、类型变量的限定"><a href="#三、类型变量的限定" class="headerlink" title="三、类型变量的限定"></a>三、类型变量的限定</h1><ol>
<li>利用关键字extends来限定类型变量，一个类型变量或通配符可以有多个限定，用<code>&amp;</code>分隔，而逗号用来分隔类型变量。</li>
<li><font color=Crmison>可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。</font></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//对T进行限定：表明泛型的min方法只能被实现了 Comparable 接口的类（如 String、 LocalDate 等）的数组调用。否则会产生一个编译错误。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparab1e&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> <span class="comment">// almost correct</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">null</span> || a.length = <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        T smallest = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (smallest.compareTo(a[i]) &gt; <span class="number">0</span>) smallest = a[i];</span><br><span class="line">        <span class="keyword">return</span> smallest; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个类型变量或通配符可以有多个限定，&amp;隔开</span></span><br><span class="line">T extends Comparable &amp; Serializable</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a = <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    T min = a[<span class="number">0</span>];</span><br><span class="line">    T max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inin.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i]; &lt;<span class="number">2</span> <span class="keyword">if</span> (max .coinpareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、泛型代码和虚拟机"><a href="#四、泛型代码和虚拟机" class="headerlink" title="四、泛型代码和虚拟机"></a>四、泛型代码和虚拟机</h1><h2 id="1-类型擦除"><a href="#1-类型擦除" class="headerlink" title="1. 类型擦除"></a>1. 类型擦除</h2><p>虚拟机没有泛型类型对象—所有对象都属于普通类。Java中的泛型是用擦除实现的，即仅于编译时类型检查，在运行时擦除类型信息，这样可以避免运行时代码膨胀。</p>
<ol>
<li>无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型。</li>
<li>原始类型就是擦除类型变量, 并替换为限定类型（无限定的变量用 Object 替换）后的普通类型。</li>
<li>原始类型用第一个限定的类型变量来替换， 如果没有给定限定就用 Object 替换。</li>
<li>为了提高效率，应该将标签接口（即没有方法的接口）放在边界列表的末尾。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span>  //可以实现接口</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span> <span class="params">(T first, T second)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; lower = second; upper = first; &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的原始类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span> <span class="params">(Comparable first, Comparable second)</span> </span>&#123; . . . &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-翻译泛型表达式"><a href="#2-翻译泛型表达式" class="headerlink" title="2. 翻译泛型表达式"></a>2. 翻译泛型表达式</h2><ol>
<li>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。</li>
<li>当存取一个泛型域时也要插入强制类型转换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译器把这个方法调用翻译为两条虚拟机指令：对原始方法 Pair.getFirst 的调用;  将返回的 Object 类型强制转换为 Employee 类型。</span></span><br><span class="line">Pair&lt;Employee&gt; buddies = . .</span><br><span class="line">Employee buddy = buddies.getFirst();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//假设Pair 类的 first 域和 second 域都是公有的</span></span><br><span class="line">Employee buddy = buddies.first; <span class="comment">//会在结果字节码中插人强制类型转换。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-翻译泛型方法"><a href="#3-翻译泛型方法" class="headerlink" title="3. 翻译泛型方法"></a>3. 翻译泛型方法</h2><ol>
<li>类型擦除之前认为泛型方法为一个方法族，而擦除类型之后，只剩下一个方法。</li>
<li>类型擦除与多态发生了冲突，要想多态正确的发挥作用，需要编译器在 Datelnterval 类中生成一个桥方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Datelnterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.compareTo(getFirst()) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">super</span>.setSecond(second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成桥方法来保持多态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span> </span>&#123; setSecond((Date) second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Datelnterval interval = <span class="keyword">new</span> Datelnterval(. . .);</span><br><span class="line">Pair&lt;Loca1Date&gt; pair = interval; </span><br><span class="line">pair.setSecond(aDate); </span><br><span class="line"></span><br><span class="line"><span class="comment">//对于可协变返回类型的方法不能生成桥方法，因为在虚拟机中，用参数类型和返回类型确定一个方法。虚拟机能够正确处理这一情况。</span></span><br><span class="line"><span class="function">LocalDate <span class="title">getSecond</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Object <span class="title">getSecond</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>有关 Java 泛型转换的事实:</p>
<ol>
<li>虚拟机中没有泛型，只有普通的类和方法。</li>
<li>所有的类型参数都用它们的限定类型替换。</li>
<li>桥方法被合成来保持多态。 </li>
<li>为保持类型安全性，必要时插入强制类型转换。</li>
</ol>
<h2 id="4-调用遗留代码"><a href="#4-调用遗留代码" class="headerlink" title="4. 调用遗留代码"></a>4. 调用遗留代码</h2><ol>
<li>Java允许泛型代码和遗留代码之间能够互操作。</li>
<li>当利用原始类型操作泛型对象时以及由遗留的类得到一个原始类型的对象时都会产生一个警告，若在设计代码时可以确保不会发生错误，则可以使用注解<code>@SuppressWarnings(&quot;unchecked&quot;)</code>消除这些警告。</li>
</ol>
<h1 id="五、约束与局限性"><a href="#五、约束与局限性" class="headerlink" title="五、约束与局限性"></a>五、约束与局限性</h1><p>在使用泛型时需要考虑一些限制，大多数限制都是由类型擦除引起的。</p>
<h2 id="1-不能用基本类型实例化类型参数"><a href="#1-不能用基本类型实例化类型参数" class="headerlink" title="1. 不能用基本类型实例化类型参数"></a>1. 不能用基本类型实例化类型参数</h2><ol>
<li>不能用基本类型实例化类型参数的原因是类型擦除，擦除之后原始类型中含有Object类型的域，而 Object 不能存储基本类型的值。</li>
<li>这并不是一个致命的缺陷，它与Java 语言中基本类型的独立状态相一致。</li>
</ol>
<h2 id="2-运行时类型查询只适用于原始类型"><a href="#2-运行时类型查询只适用于原始类型" class="headerlink" title="2. 运行时类型查询只适用于原始类型"></a>2. 运行时类型查询只适用于原始类型</h2><p>因为虚拟机中没有泛型类型，而是总有一个特定的非泛型类型，故运行时类型查询只适用于原始类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f(a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">// 会得到一个编译器错误</span></span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; <span class="comment">//会得到一个警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//getClass 方法总是返回原始类型。</span></span><br><span class="line">Pair&lt;String&gt; stringPair = . .</span><br><span class="line">Pair&lt;Employee&gt; employeePair = . .</span><br><span class="line"><span class="keyword">if</span> (stringPair.getClass() == employeePair.getClass()) <span class="comment">//比较的结果是 true, 这是因为两次调用 getClass 都将返回 Pair.class。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-不能创建参数化类型的数组"><a href="#3-不能创建参数化类型的数组" class="headerlink" title="3. 不能创建参数化类型的数组"></a>3. 不能创建参数化类型的数组</h2><ol>
<li><font color=Crmison>因为类型擦除会让数组能够记住它的元素类型的机制失效，往参数化类型数组中添加各种类型后就能够通过数组检查，这违背了泛型设计的原则，故不能创建参数化类型的数组。</font></li>
<li>只是不允许创建这些数组，而声明类型为 <code>Pair&lt;String&gt;[]</code> 的变量仍是合法的,只是不能通过<code>new Pair&lt;String&gt;[10]</code> 初始化这个变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//table 的类型是 Pair[] 可以把它转换为 Object[] </span></span><br><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// 不能创建参数化类型的数组</span></span><br><span class="line">Object[] objarray = table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型擦除使数组能够记住它的元素类型的机制失效了，即以下赋值能够通过存储检查，</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="string">"Hello"</span>;  <span class="comment">//运行时会导致一个类型错误，违背了泛型设计的原则。</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以声明通配类型的数组， 然后进行类型转换,但这样是不安全的</span></span><br><span class="line"><span class="comment">//如果在 table[0] 中存储一个 Pair&lt;Employee&gt;, 然后对 table[0].getFirst() 调用一个 String 方法， 会得到一个 ClassCastException 异常。</span></span><br><span class="line">Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) <span class="keyword">new</span> Pair&lt;?&gt;[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//收集参数化类型对象的唯一安全有效的方法</span></span><br><span class="line">ArrayList:ArrayList&lt;Pair&lt;String&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-Varargs-警告"><a href="#4-Varargs-警告" class="headerlink" title="4. Varargs 警告"></a>4. Varargs 警告</h2><ol>
<li>向参数个数可变的方法传递一个泛型类型的实例时，Java 虚拟机必须建立一个 <code>Pair&lt;String&gt;</code> 数组，这就违反了虚拟机中没有泛型的规则，但是对于这种情况只会得到一个警告而不是错误。</li>
<li>可增加注解<code>@SuppressWamings(&quot;unchecked&quot;。)</code>或<code>@SafeVarargs</code>来抑制这个警告，之后就可以提供泛型类型来调用这个方法了。</li>
<li>对于只需要读取参数数组元素的所有方法，都可以使用这两个注解。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collections coll, T... ts)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (t : ts) coll.add(t);</span><br><span class="line">&#125;</span><br><span class="line">Col1ection&lt;Pair&lt;String&gt;&gt; table = . . .;</span><br><span class="line">Pair&lt;String&gt; pairl = . . .;</span><br><span class="line">Pair&lt;String&gt; pair2 = . .</span><br><span class="line">addAll(table, pairl, pair2);</span><br><span class="line"></span><br><span class="line"><span class="meta">@SafeVarargs</span> <span class="keyword">static</span> &lt;E&gt; E[] array(E... array) &#123; <span class="keyword">return</span> array;&#125;</span><br><span class="line">Pair&lt;String&gt;[] table = array(pairl, pair2);</span><br><span class="line">Object[] objarray = table;</span><br><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();  <span class="comment">//能顺利运行而不会出现 ArrayStoreException 异常（因为数组存储只会检查擦除的类型) 但在处理 table[0] 时会在别处得到一个异常。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-不能实例化类型变量"><a href="#5-不能实例化类型变量" class="headerlink" title="5. 不能实例化类型变量"></a>5. 不能实例化类型变量</h2><ol>
<li>不能使用像 <code>new T(...)</code> <code>new T[...]</code> 或 <code>T.class</code> 这样的表达式中的类型变量。</li>
<li>解决办法是让调用者提供一个构造器表达式或者通过反射调用 <code>Class.newInstance</code> 方法来构造泛型对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; first = <span class="keyword">new</span> T(); second = <span class="keyword">new</span> T(); &#125;</span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">first = T<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>; </span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> Pair(cl.newInstance(), cl.newInstance()); &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125; </span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-不能构造泛型数组"><a href="#6-不能构造泛型数组" class="headerlink" title="6. 不能构造泛型数组"></a>6. 不能构造泛型数组</h2><p>因为数组中的类型在虚拟机中会被擦除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉 T[] minmax(T[] a) &#123; T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>]; . . . &#125;  <span class="comment">//类型擦除会让这个方法永远构造 Comparable[2] 数组。</span></span><br><span class="line"><span class="comment">//Error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmax(T... a) &#123;</span><br><span class="line">Object[] mm = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> (T[]) mm; <span class="comment">// compiles with warning</span></span><br><span class="line">&#125;</span><br><span class="line">String[] ss = ArrayAlg.minmax(<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="comment">//用户提供一个数组构造器表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmax(IntFunction&lt;TD&gt; constr, T... a) </span><br><span class="line">&#123; </span><br><span class="line">    T[] mm = constr.apply(<span class="number">2</span>); </span><br><span class="line">&#125;</span><br><span class="line">String口 ss = ArrayAlg.minmax (String[]::<span class="keyword">new</span>，<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</span><br><span class="line"><span class="comment">//利用反射构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt;T[] minmax(T... a) </span><br><span class="line">&#123; </span><br><span class="line">    T[] mm = (T[]) Array.newlnstance(a.getClass().getComponentType(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//toArray方法</span></span><br><span class="line">Object[] toArray()</span><br><span class="line">T[] toArray(T[] result) <span class="comment">//如果数组足够大， 就使用这个数组。 否则， 用 result 的成分类型构造一个足够大的新数组。</span></span><br></pre></td></tr></table></figure>

<h2 id="7-泛型类的静态上下文中类型变量无效"><a href="#7-泛型类的静态上下文中类型变量无效" class="headerlink" title="7. 泛型类的静态上下文中类型变量无效"></a>7. 泛型类的静态上下文中类型变量无效</h2><p>不能在静态域或方法中引用类型变量。因为由于类型擦除静态域的特定功能也会消失。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance; <span class="comment">// Error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span> <span class="comment">// Error</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleinstance == <span class="keyword">null</span>) </span><br><span class="line">            construct <span class="keyword">new</span> instance of T</span><br><span class="line">        <span class="keyword">return</span> singlelnstance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-不能抛出或捕获泛型类的实例"><a href="#8-不能抛出或捕获泛型类的实例" class="headerlink" title="8. 不能抛出或捕获泛型类的实例"></a>8. 不能抛出或捕获泛型类的实例</h2><ol>
<li>既不能抛出也不能捕获泛型类对象。</li>
<li>泛型类扩展 Throwable 是不合法的。</li>
<li>catch 子句中不能使用类型变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error 不能扩展Throwable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* . . . */</span> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//Error 不能编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (T e) <span class="comment">// Error 不能捕获类型变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        Logger,global.info(...) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在异常规范中使用类型变量是允许的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T <span class="comment">// OK</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable realCause) </span><br><span class="line">    &#123; </span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-可以消除对受查异常的检查"><a href="#9-可以消除对受查异常的检查" class="headerlink" title="9. 可以消除对受查异常的检查"></a>9. 可以消除对受查异常的检查</h2><ol>
<li>泛型可以消除java异常处理中必须为所有受查异常提供一个处理器的限制，可利用注解<code>@SupressWarnings(&quot;unchecked&quot;)</code>来实现。</li>
<li>通过使用泛型类、擦除和 <code>@SuppressWarnings</code> 注解， 就能消除 Java 类型系统的部分基本限制。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">toThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   <span class="comment">//run方法不会介意受查异常Exception</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    body();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable t) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//以下代码会把所有异常都转换为编译器所认为的非受查异常。</span></span><br><span class="line">                    Block.&lt;RuntimeException&gt;throwAs(t); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> (T) e; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Block()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileC<span class="string">'ququx") , "UTF-8");</span></span><br><span class="line"><span class="string">                while (in.hasNext())</span></span><br><span class="line"><span class="string">                System.out.println(in.next()); </span></span><br><span class="line"><span class="string">            &#125; </span></span><br><span class="line"><span class="string">        &#125; </span></span><br><span class="line"><span class="string">        .toThread().start(); </span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-注意擦除后的冲突"><a href="#10-注意擦除后的冲突" class="headerlink" title="10. 注意擦除后的冲突"></a>10. 注意擦除后的冲突</h2><ol>
<li>泛型类在擦除后可能会与Object类中的方法产生冲突，解决方法是重新命名引发错误的方法。</li>
<li>要想支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑Pair&lt;String&gt;，它有两个equals方法，这两个方法在方法擦除后会产生冲突</span></span><br><span class="line"><span class="comment">//解决方法是重新命名equals</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span> <span class="comment">// 定义在Pair&lt;T&gt;中，擦除后变为boolean equals(Object)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span> <span class="comment">// 继承自Object</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Error，因为Manager 会实现 Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt;, 这是同一接口的不同参数化。</span></span></span><br><span class="line"><span class="function"><span class="comment">//实现了 C0mpamble&lt;X&gt; 的类可以获得一个桥方法，对于不同类型的 X 不能有两个这样的方法。</span></span></span><br><span class="line"><span class="function">class Employee implements Comparable&lt;Employee&gt; </span>&#123; . . . &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Manager</span>&gt; </span>&#123; . . . &#125; <span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123; <span class="keyword">return</span> compareTo((X) other); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、泛型类型的继承规则"><a href="#六、泛型类型的继承规则" class="headerlink" title="六、泛型类型的继承规则"></a>六、泛型类型的继承规则</h1><ol>
<li>处于类型安全的考虑，Java规定无论 S 与 T 有什么联系，通常，Pair<S> 与 Pair<T>没有什么联系。</li>
<li>泛型类可以扩展或实现其他的泛型类。如ArrayList<T> 类实现 List<T> 接口。这意味着， 一个 ArrayList<Manager> 可以被转换为一个 List<Manager>。但是，一个 ArrayList<Manager> 不是一个ArrayList<Employee> 或 List<Employee>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Manager&gt; managerBuddies = <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair&lt;Employee&gt; employeeBuddies = managerBuddies; <span class="comment">// 非法</span></span><br><span class="line">employeeBuddies.setFirst(lowlyEmployee);</span><br><span class="line"></span><br><span class="line">Pair&lt;Manager&gt; managerBuddies = <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair rawBuddies = managerBuddies; <span class="comment">// OK</span></span><br><span class="line">rawBuddies.setFirst(<span class="keyword">new</span> File(<span class="string">". . ."</span>)); <span class="comment">// 只会出现编译警告</span></span><br></pre></td></tr></table></figure>

<h1 id="七、通配符类型"><a href="#七、通配符类型" class="headerlink" title="七、通配符类型"></a>七、通配符类型</h1><h2 id="1-通配符的概念"><a href="#1-通配符的概念" class="headerlink" title="1. 通配符的概念"></a>1. 通配符的概念</h2><ol>
<li>通配符类型中，允许类型参数变化。</li>
<li>通配符限定与类型变量限定十分类似，而且还可以指定一个超类型限定。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示任何泛型 Pair 类型， 它的类型参数是 Employee 的子类</span></span><br><span class="line"><span class="comment">//类型 Pair&lt;Manager&gt; 和Pair&lt;Manager&gt; 是 Pair&lt;? extends Employee&gt; 的子类型</span></span><br><span class="line"><span class="comment">//但是类型 Pair&lt;Manager&gt; 和Pair&lt;Manager&gt;之间没有任何关系</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span>   <span class="comment">//子类型限定通配符</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将 getFirst 的返回值赋给一个 Employee 的引用完全合法。</span></span></span><br><span class="line"><span class="function"><span class="comment">//但不能调用setFirst方法</span></span></span><br><span class="line"><span class="function">Pair&lt;Manager&gt; managerBuddies </span>= <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair&lt;? extends Employee&gt; wildcardBuddies = managerBuddies; <span class="comment">// OK</span></span><br><span class="line">wildcardBuddies.setFirst(lowlyEmployee); <span class="comment">// 会产生编译错误</span></span><br><span class="line"></span><br><span class="line">? <span class="function">extends Employee <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? extends Employee)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-通配符的超类型限定"><a href="#2-通配符的超类型限定" class="headerlink" title="2. 通配符的超类型限定"></a>2. 通配符的超类型限定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">带有超类型限定的通配符可以向泛型对象写入（set方法），带有子类型限定的通配符可以从泛型对象读取（get方法）。</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? <span class="keyword">super</span> Manager)</span> </span></span><br><span class="line"><span class="function">? <span class="keyword">super</span> Manager <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minmaxBonus</span><span class="params">(Manager[] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Manager rain = a[<span class="number">0</span>];</span><br><span class="line">    Manager max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i *<span class="number">1</span>; i &lt; a.length; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (min.getBonus() &gt; a[i].getBonus()) rain = a[i];</span><br><span class="line">        <span class="keyword">if</span> (max.getBonus() &lt; a[i].getBonus()) max = a[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    result.setFirst(min);</span><br><span class="line">    result.setSecond(max); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Conparable&lt;? <span class="keyword">super</span> T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicated&lt;? <span class="keyword">super</span> E&gt; filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArrayList&lt;Employee&gt; staff = . .;</span><br><span class="line">    Predicate&lt;Object&gt; oddHashCode = obj -&gt; obj.hashCode() %<span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">    staff.removelf(oddHashCode):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-无限定通配符"><a href="#3-无限定通配符" class="headerlink" title="3. 无限定通配符"></a>3. 无限定通配符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getFirst 的返回值只能赋给一个 Object。setFirst 方法不能被调用， 甚至不能用 Object 调 用。</span></span><br><span class="line"></span><br><span class="line">? getFirst()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//可以调用 setFirst(null)。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() = <span class="keyword">null</span> || p.getSecond() =<span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过将 hasNulls 转换成泛型方法，可以避免使用通配符类型,</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-通配符捕获"><a href="#4-通配符捕获" class="headerlink" title="4. 通配符捕获"></a>4. 通配符捕获</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通配符不是类型变量，因此，不能在编写代码中使用“？”作为一种类型。</span></span><br><span class="line">? t = p.getFirst(); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符捕获</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    T t = p.getFirst(); </span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(t); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123; swapHelper(p); &#125;  <span class="comment">//参数T 捕获通配符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxminBonus</span><span class="params">(Manager ] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    minmaxBonus(a, result);</span><br><span class="line">    PairAlg.swap(result); <span class="comment">// OK swapHelper captures wildcard type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、反射和泛型"><a href="#八、反射和泛型" class="headerlink" title="八、反射和泛型"></a>八、反射和泛型</h1><h2 id="1-泛型-Class-类"><a href="#1-泛型-Class-类" class="headerlink" title="1. 泛型 Class 类"></a>1. 泛型 Class 类</h2><p>//反射不能获得泛型类型参数的太多信息，因为它们会被擦除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span> <span class="comment">//返回无参数构造器构造的一个新实例。</span></span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span> <span class="comment">//如果 obj 为 null 或有可能转换成类型 T， 则 返 回 obj ; 否 则 拋 出 BadCastException异常。</span></span></span><br><span class="line"><span class="function">T[ ] <span class="title">getEnumConstants</span><span class="params">( )</span> <span class="comment">//如果 T 是枚举类型， 则返回所有值组成的数组，否则返回 null。</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperclass</span><span class="params">( )</span> <span class="comment">//返回这个类的超类。如果 T 不是一个类或 Object 类， 则返回 null。</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>  <span class="comment">//获得公有的构造器， 或带有给定参数类型的构造器。</span></span></span><br><span class="line"><span class="function">T <span class="title">newlnstance</span><span class="params">(<span class="number">0</span>bject... parameters)</span> <span class="comment">//返回用指定参数构造的新实例。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-使用-Class-参数进行类型匹配"><a href="#2-使用-Class-参数进行类型匹配" class="headerlink" title="2. 使用 Class 参数进行类型匹配"></a>2. 使用 Class<T> 参数进行类型匹配</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Employee.class 是类型 Class&lt;Employee&gt; 的一个对象。makePair 方法的类型参数 T 同 Employee匹配， 并且编译器可以推断出这个方法将返回一个 Pair&lt;Employee&gt;。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pai r&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Pairo(c.newInstance(), c.newInstance()); </span><br><span class="line">&#125;</span><br><span class="line">makePair(Employee<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="3-虚拟机中的泛型类型信息"><a href="#3-虚拟机中的泛型类型信息" class="headerlink" title="3. 虚拟机中的泛型类型信息"></a>3. 虚拟机中的泛型类型信息</h2><p>可以使用反射 API 来确定： </p>
<ul>
<li>这个泛型方法有一个叫做 T 的类型参数。<br>这个类型参数有一个子类型限定，其自身又是一个泛型类型。<br>这个限定类型有一个通配符参数。<br>这个通配符参数有一个超类型限定。<br>这个泛型方法有一个泛型数组参数。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的集合</title>
    <url>/2020/05/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>集合是Java中非常重要的内容。</p>
<h1 id="一、Java-集合框架"><a href="#一、Java-集合框架" class="headerlink" title="一、Java 集合框架"></a>一、Java 集合框架</h1><h2 id="1-将集合的接口与实现分离"><a href="#1-将集合的接口与实现分离" class="headerlink" title="1. 将集合的接口与实现分离"></a>1. 将集合的接口与实现分离</h2><p>队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; </span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列实现</span></span><br><span class="line"><span class="comment">//循环队列,循环数组要比链表更高效，因此多数人优先选择循环数组。</span></span><br><span class="line"><span class="comment">//循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    CircularArrayQueue(<span class="keyword">int</span> capacity) &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="keyword">private</span> E[] elements; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Link head;</span><br><span class="line">    <span class="keyword">private</span> Link tail;</span><br><span class="line">    LinkedListQueue() &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; ... &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用接口类型存放集合的引用</span></span><br><span class="line">Queue&lt;Customer&gt; expresslane = <span class="keyword">new</span> CircularArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">"Harry"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//只需修改接口的引用即可使用另外一种实现</span></span><br><span class="line">Queue&lt;Custoaer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">"Harry"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="2-Collection-接口"><a href="#2-Collection-接口" class="headerlink" title="2. Collection 接口"></a>2. Collection 接口</h2><p>Java类库中集合的基本接口，集合中不允许有重复对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>; <span class="comment">//如果添加元素确实改变了集合就返回 true, 如果集合没有发生变化就返回 false。</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">//iterator方法用于返回一个实现了 Iterator 接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h2><ol>
<li>迭代器是不断向前滑动的，当读取或删除一个元素后就向后滑动一个位置。</li>
<li>元素被访问的顺序取决于集合类型。 如果对 ArrayList 进行迭代， 迭代器将从索引 0开 始，每迭代一次，索引值加1，如果访问 HashSet 中的元素， 每个元素将会按照某种随机的次序出现。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Iterator迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;  <span class="comment">//逐个访问集合中的每个元素，在调用 next 之前调用 hasNext方法。如果迭代器对象还有多个供访问的元素， 这个方法就返回 true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;   <span class="comment">//remove的是上一个被next的元素，故remove之前必须调用next方法读取。</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合遍历</span></span><br><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) </span><br><span class="line">&#123;</span><br><span class="line">    String element = iter.next();</span><br><span class="line">    <span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foreach 遍历：可以与任何实现了 Iterable 接口的对象一起工作</span></span><br><span class="line"><span class="comment">//Collection 接口扩展了 Iterable 接口。因此， 对于标准类库中的任何集合都可以使用“ foreach” 循环。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String element : c) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式遍历</span></span><br><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-泛型实用方法"><a href="#4-泛型实用方法" class="headerlink" title="4. 泛型实用方法"></a>4. 泛型实用方法</h2><ol>
<li>由于 Collection 与 Iterator 都是泛型接口，可以编写操作任何集合类型的实用方法。</li>
<li>Collection 接口中已经实现了很多默认方法供类库使用者直接调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstracted1ection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : <span class="keyword">this</span>) <span class="comment">// calls iterator()</span></span><br><span class="line">        <span class="keyword">if</span> (element.equals(obj))</span><br><span class="line">        <span class="keyword">return</span> = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-集合框架中的接口"><a href="#5-集合框架中的接口" class="headerlink" title="5. 集合框架中的接口"></a>5. 集合框架中的接口</h2><p><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E6%8E%A5%E5%8F%A3.png" alt="集合"><br>集合有两个基本接口：Collection 和 Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection插入读取（使用迭代器）元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Map插入读取元素</span></span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//List 是一个有序集合，可迭代器访问也可随机访问</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Listlterator 接口是 Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//标记接口 RandomAccess 不包含任何方法，不过可以用它来测试一个特定的集合是否支持高效的随机访问。</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(c <span class="keyword">instanceof</span> RandomAccess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    use random access algorithm</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    use sequential access algorithm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集（set) 的 add方法不允许增加重复的元素。</span></span><br><span class="line"><span class="comment">//要适当地定义集的 equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。</span></span><br><span class="line"><span class="comment">//hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口 NavigableSet 和 NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法,TreeSet 和 TreeMap 类实现了这些接口。</span></span><br></pre></td></tr></table></figure>

<h1 id="二、具体的集合"><a href="#二、具体的集合" class="headerlink" title="二、具体的集合"></a>二、具体的集合</h1><p><img src="%E5%85%B7%E4%BD%93%E9%9B%86%E5%90%881.png" alt="集合"><br><img src="%E5%85%B7%E4%BD%93%E9%9B%86%E5%90%882.png" alt="集合"><br>以 Map 结尾的类实现了 Map 接口,除此之外，其他类都实现了Collection 接口。</p>
<h2 id="1-链表（LinkedList）"><a href="#1-链表（LinkedList）" class="headerlink" title="1. 链表（LinkedList）"></a>1. 链表（LinkedList）</h2><ol>
<li>Java中的所有链表实际上都是双向链接的，LinkedList类实现了List接口。</li>
<li>链表是一个有序集合,有n+1个位置添加新元素。</li>
<li>迭代器是描述集合中位置的，所以这种依赖于位置的 add 方法（例如将元素添加到链表中间）将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。</li>
<li>在调用remove之前调用next，则删除的是迭代器左侧元素，若在调用remove之前调用previous，则删除的是右侧元素。</li>
<li>add 方法只依赖于迭代器的位置， 而 remove 方法依赖于迭代器的状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// LinkedList implements List</span></span><br><span class="line">staff.add(<span class="string">"Amy"</span>);   <span class="comment">//LinkedList.add 方法将对象添加到链表的尾部。</span></span><br><span class="line">staff.add(<span class="string">"Bob"</span>)；</span><br><span class="line">staff.add(<span class="string">"Carl"</span>);</span><br><span class="line">Iterator iter = staff.iterator();</span><br><span class="line">String first = iter.next();<span class="comment">// visit first element</span></span><br><span class="line">String second = iter.next(); <span class="comment">//visit second element</span></span><br><span class="line">iter.remove(); <span class="comment">// remove last visited element</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子接口ListIterator</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;  <span class="comment">//假定添加操作总会改变链表，在当前迭代器位置之前添加一个新对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span>   <span class="comment">//反向遍历链表</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ListIterator&lt;String&gt; iter </span>= staff.listIterator();</span><br><span class="line">iter.next();</span><br><span class="line">iter.add(<span class="string">"juliet"</span>);  <span class="comment">//在第二个元素之前添加“Juliet”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。</span></span><br><span class="line"><span class="comment">//添加、删除元素属于结构性修改，而set 方法不被视为结构性修改。</span></span><br><span class="line">ListIterator&lt;String&gt; iter = list.listIterator();</span><br><span class="line">String oldValue = iter.next(); <span class="comment">// returns first element</span></span><br><span class="line">iter.set(newValue); <span class="comment">// sets first element to newValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并发修改异常</span></span><br><span class="line"><span class="comment">//解决方法：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。</span></span><br><span class="line"><span class="comment">//检测并发修改的异常： 每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。</span></span><br><span class="line">List&lt;String&gt; list = ...</span><br><span class="line">ListIterator&lt;String&gt; iter1 = list.listlterator();</span><br><span class="line">ListIterator&lt;String&gt; iter2 = list.listlterator();</span><br><span class="line">iter1.next();</span><br><span class="line">iter1.remove();</span><br><span class="line">iter2.next(); <span class="comment">// throws ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问某个特定元素,效率低</span></span><br><span class="line">LinkedList&lt;String&gt; list = ...;</span><br><span class="line">String obj = list.get(n);  <span class="comment">//每次査找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-数组列表（ArrayList）"><a href="#2-数组列表（ArrayList）" class="headerlink" title="2. 数组列表（ArrayList）"></a>2. 数组列表（ArrayList）</h2><p>ArrayList类实现了List接口，它封装了一个动态再分配的对象数组。</p>
<h2 id="3-散列集（HashSet）"><a href="#3-散列集（HashSet）" class="headerlink" title="3. 散列集（HashSet）"></a>3. 散列集（HashSet）</h2><ol>
<li>在 Java 中，散列表用链表数组实现，散列码是由对象的实例域产生的一个整数。</li>
<li>如果自定义类，就要负责实现这个类的 hashCode 方法，自己实现的 hashCode方法应该与 equals 方法兼容。</li>
<li>散列表可以用来实现Set及HashSet。</li>
<li>装填因子指表大小占预计元素个数的比例，若表中超过该比例的位置已经填入元素，这个表就会用双倍的表长自动地进行再散列。</li>
<li>如果要对散列表再散列， 就需要创建一个表长更大的表，并将所有元素插入到这个新表中，然后丢弃原来的表。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet() <span class="comment">//构造一个空散列表。 </span></span><br><span class="line">HashSet(Collection&lt;? extends E&gt; elements ) <span class="comment">//构造一个散列集， 并将集合中的所有元素添加到这个散列集中。 </span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity) <span class="comment">//构造一个空的具有指定容量（桶数）的散列集。 </span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity , <span class="keyword">float</span> loadFactor ) <span class="comment">//构造一个具有指定容量和装填因子（一个 0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列）的空散列集。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">( )</span>  <span class="comment">//返回这个对象的散列码,equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCode() 必须等于 y.hashCode()。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-树集（TreeSet）"><a href="#4-树集（TreeSet）" class="headerlink" title="4. 树集（TreeSet）"></a>4. 树集（TreeSet）</h2><ol>
<li>树集是一个有序集合，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</li>
<li>排序是利用红黑树实现的，即每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。</li>
<li>要使用树集，必须能够比较元素。这些元素必须实现 Comparable 接口或者构造集时必须提供一个 Comparator。</li>
<li>从 JavaSE 6 起，TreeSet 类实现了 NavigableSet 接口。 这个接口增加了几个便于定位元素以及反向遍历的方法。</li>
</ol>
<h2 id="5-队列与双端队列（Deque）"><a href="#5-队列与双端队列（Deque）" class="headerlink" title="5. 队列与双端队列（Deque）"></a>5. 队列与双端队列（Deque）</h2><p>Deque 接口由 ArrayDeque 和 LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</p>
<h2 id="6-优先级队列（PriorityQueue）"><a href="#6-优先级队列（PriorityQueue）" class="headerlink" title="6. 优先级队列（PriorityQueue）"></a>6. 优先级队列（PriorityQueue）</h2><ol>
<li>优先级队列使用堆对元素进行检索，堆是一个可以自我调整的二叉树，对树执行添加（add) 和删除（remove) 操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</li>
<li>无论何时调用 remove 方法，总会删除当前优先级队列中最小的元素。</li>
</ol>
<h1 id="三、映射"><a href="#三、映射" class="headerlink" title="三、映射"></a>三、映射</h1><p>映射用来存放键/值对。如果提供了键，就能够查找到值。</p>
<h2 id="1-基本映射操作"><a href="#1-基本映射操作" class="headerlink" title="1. 基本映射操作"></a>1. 基本映射操作</h2><ol>
<li>Java 类库为map接口提供了两个通用的实现：HashMap 和 TreeMap。</li>
<li>键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用 put 方法，第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Employee&gt; staff = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>);</span><br><span class="line">staff.put(<span class="string">"987-98-9996"</span>, harry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检索</span></span><br><span class="line">String id = <span class="string">"987-98-9996"</span>; </span><br><span class="line">Employee e = staff.get(id);<span class="comment">// gets harry,如果在映射中没有与给定键对应的信息， get 将返回 null。</span></span><br><span class="line">Map&lt;String, Integer&gt; scores = ...;</span><br><span class="line"><span class="keyword">int</span> score = scores.get(id,<span class="number">0</span>); <span class="comment">// 如果get(id)不存在则默认get(0)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//remove 方法用于从映射中删除给定键对应的元素。size 方法用于返回映射中的元素数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式遍历映射</span></span><br><span class="line">scores.forEach((k, v) -&gt; System.out.println(<span class="string">"key="</span> + k + <span class="string">", value:"</span> + v));</span><br></pre></td></tr></table></figure>

<h2 id="2-更新映射项"><a href="#2-更新映射项" class="headerlink" title="2. 更新映射项"></a>2. 更新映射项</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(word, counts.get(word)+ <span class="number">1</span>); <span class="comment">//当第一次添加 word 时，get 会返回 null, 因此会出现一个 NullPointerException 异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">counts,put(word, counts.getOrDefault(word, <span class="number">0</span>)+ <span class="number">1</span>);  <span class="comment">//若word第一次添加，则利用默认值+1</span></span><br><span class="line"></span><br><span class="line">counts.putlfAbsent(word, <span class="number">0</span>);  <span class="comment">//只有当键原先存在时才会放入一个值。</span></span><br><span class="line">counts.put(word, counts.get(word)+ <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);  <span class="comment">//如果键原先不存在，将把word与1关联，否则将原值和1求和。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-映射视图"><a href="#3-映射视图" class="headerlink" title="3. 映射视图"></a>3. 映射视图</h2><ol>
<li>映射有三种视图：键集、 值集合（不是一个集） 以及键/值对集。</li>
<li>不能向键集视图和键值对视图中增加元素，但可以删除，若试图调用 add方法， 它会抛出一个 UnsupportedOperationException。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种视图</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span>  <span class="comment">//keySet是实现了 Set 接口的另外某个类的对象。</span></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K, V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//视图遍历</span></span></span><br><span class="line"><span class="function"><span class="comment">//键视图</span></span></span><br><span class="line"><span class="function">Set&lt;String&gt; keys </span>= map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keys) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键值对视图</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Employee&gt; entry : staff.entrySet()) </span><br><span class="line">&#123;</span><br><span class="line">    String k = entry.getKey();</span><br><span class="line">    Employee v = entry.getValue();</span><br><span class="line">    <span class="keyword">do</span> something with k, v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counts.forEach((k，v) -&gt; &#123;<span class="keyword">do</span> somethingwith k, v &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-弱散列映射-WeakHashMap"><a href="#4-弱散列映射-WeakHashMap" class="headerlink" title="4. 弱散列映射(WeakHashMap)"></a>4. 弱散列映射(WeakHashMap)</h2><ol>
<li>WeakHashMap用来配合垃圾回收器删除无用映射对象。</li>
<li>WeakHashMap 使用弱引用 （ weak references) 保存键。WeakReference 对象将引用保存到另外一个对象中，在这里，就是散列键。</li>
<li>如果某个对象只能由 WeakReference 引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap 将周期性地检查队列，以便找出新添加的弱引用，然后由WeakHashMap 删除对应的条目。</li>
</ol>
<h2 id="5-链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）"><a href="#5-链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）" class="headerlink" title="5. 链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）"></a>5. 链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）</h2><ol>
<li>LinkedHashSet 和 LinkedHashMap 类用来记住插入元素项的顺序，当条目插入到表中时，就会并入到双向链表中。</li>
<li>LinkedHashSet 按照插入顺序来访问元素项。</li>
<li>LinkedHashMap 按照“最近最少使用”原则来访问元素项，每次调用 get 或put访问一个元素后，该元素就被从当前位置删除并放到链表的尾部。当在表中找不到元素项且表又已经满时，可以将迭代器加入到表中，并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造散列映射表</span></span><br><span class="line">LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, <span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个覆盖了removeEldestEntry方法的子类以实现自动化删除最近最少使用元素</span></span><br><span class="line">Map&lt;K, V&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">128</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">100</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<h2 id="6-枚举集（EnumSet）与枚举映射（EnumMap）"><a href="#6-枚举集（EnumSet）与枚举映射（EnumMap）" class="headerlink" title="6. 枚举集（EnumSet）与枚举映射（EnumMap）"></a>6. 枚举集（EnumSet）与枚举映射（EnumMap）</h2><ol>
<li>所有的枚举类型都扩展于泛型 Enum 类。</li>
<li>EnumSet 是一个枚举类型元素集的高效实现，内部用位序列实现。如果对应的值在集中，则相应的位被置为 1。</li>
<li>EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);</span><br><span class="line"></span><br><span class="line">EnumMap&lt;Weekday, Employee&gt; personlnCharge = <span class="keyword">new</span> EnumMapo(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-标识散列映射（IdentityHashMap）"><a href="#7-标识散列映射（IdentityHashMap）" class="headerlink" title="7. 标识散列映射（IdentityHashMap）"></a>7. 标识散列映射（IdentityHashMap）</h2><ol>
<li>类 IdentityHashMap的键的散列值不是用 hashCode 函数计算的，而是用 System.identityHashCode 方法由Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式计算的。</li>
<li>在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals，即不同的键对象， 即使内容相同， 也被视为是不同的对象。</li>
<li>在实现对象遍历算法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。</li>
</ol>
<h1 id="四、视图与包装器"><a href="#四、视图与包装器" class="headerlink" title="四、视图与包装器"></a>四、视图与包装器</h1><p>映射类中的keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h2 id="1-轻量级集合包装器-Collections"><a href="#1-轻量级集合包装器-Collections" class="headerlink" title="1. 轻量级集合包装器(Collections)"></a>1. 轻量级集合包装器(Collections)</h2><p>Collections 类包含很多实用方法， 这些方法的参数和返回值都是集合，如空集、 列表、 映射等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个包装了普通 Java 数组的 List 包装器。</span></span><br><span class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);  <span class="comment">//是一个视图对象， 带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法（例如，与迭代器相关的 add 和 remove 方法）都会抛出一个</span></span><br><span class="line">                                                <span class="comment">//Unsupported OperationException 异常。</span></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span> , <span class="string">"Bob"</span>, <span class="string">"Carl "</span>); <span class="comment">//返回一个实现了 List 接口的不可修改的对象</span></span><br><span class="line">List&lt;String&gt; settings = Collections.nCopies(<span class="number">100</span>, <span class="string">"DEFAULT"</span>); <span class="comment">//创建一个包含100个字符串的List, 每个串都被设置为“DEFAULT”</span></span><br></pre></td></tr></table></figure>

<h2 id="2-子范围视图"><a href="#2-子范围视图" class="headerlink" title="2. 子范围视图"></a>2. 子范围视图</h2><p>可以为很多集合建立子范围视图，将任何操作应用于子范围，并且能够自动地反映整个列表的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List group2 = staff.subList(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">//返回索引[10.20)之间的子范围元素视图</span></span><br><span class="line">group2.clear();  <span class="comment">//删除子视图元素，反映到整个列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于有序集和映射， 可以使用排序顺序而不是元素位置建立子范围。</span></span><br><span class="line"><span class="comment">//返回大于等于 from 且小于 to 的所有元素子集。</span></span><br><span class="line">SortedSet&lt; E&gt; subSet(E from, E to)</span><br><span class="line">SortedSet&lt; E&gt; headSet(E to)</span><br><span class="line">SortedSet&lt; E&gt; <span class="function">tail <span class="title">Set</span><span class="params">(E from)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K from, K to)</span></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//NavigableSet 接口赋予子范围操作更多的控制能力。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive, E to, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to, <span class="keyword">boolean</span> tolncIusive)</span></span></span><br><span class="line"><span class="function">Navigab1eSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-不可修改的视图"><a href="#3-不可修改的视图" class="headerlink" title="3. 不可修改的视图"></a>3. 不可修改的视图</h2><ol>
<li>Collections 还有几个方法，用于产生集合的不可修改视图,这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改， 就抛出一个异常，同时这个集合将保持未修改的状态。</li>
<li>由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下方法可获得一个不可修改视图</span></span><br><span class="line"><span class="comment">//它的 equals 方法不调用底层集合的 equals 方法。它继承了 Object 类的 equals 方法， 这个方法只是检测两个对象是否是同一个对象。</span></span><br><span class="line">Collections.unmodifiableCollection  </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用底层集合的 equals 方法和 hashCode 方法。</span></span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line"></span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure>

<h2 id="4-同步视图"><a href="#4-同步视图" class="headerlink" title="4. 同步视图"></a>4. 同步视图</h2><ol>
<li>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。</li>
<li>同步操作即在另一个线程调用另一个方法之前，刚才的方法调用必须彻底完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collections 类的静态 synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的 Map</span></span><br><span class="line">Map&lt;String, Employee&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Employee&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="5-受查视图"><a href="#5-受查视图" class="headerlink" title="5. 受查视图"></a>5. 受查视图</h2><p>受查视图可以在调用add 方法时检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 ClassCastException。这样做的好处是错误可以在正确的位置得以报告。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayListo()</span><br><span class="line">ArrayList rawList = strings; <span class="comment">// 仅出现警告</span></span><br><span class="line">rawList.add(<span class="keyword">new</span> Date()); <span class="comment">// now strings contains a Date object!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：使用受查视图</span></span><br><span class="line">List&lt;String&gt; safestrings = Collections.checkedList(strings，String,<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">ArrayList rawList = safestrings;</span><br><span class="line">rawList.add(<span class="keyword">new</span> Date());<span class="comment">// 抛出异常 ClassCastException</span></span><br></pre></td></tr></table></figure>

<h1 id="五、算法"><a href="#五、算法" class="headerlink" title="五、算法"></a>五、算法</h1><h2 id="1-排序与混排"><a href="#1-排序与混排" class="headerlink" title="1. 排序与混排"></a>1. 排序与混排</h2><ol>
<li>java中对列表的排序直接将所有元素转入一个数组，对数组进行排序，然后再将排序后的序列复制回列表。</li>
<li>不能将不可修改列表如unmodifiableList 列表传递给排序算法，传递的列表必须是可修改的，但不必是可以改变大小的。<ul>
<li>如果列表支持 set 方法，则是可修改的。</li>
<li>如果列表支持 add 和 remove 方法， 则是可改变大小的。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">fill collection</span><br><span class="line">Collections.sort(staff);   <span class="comment">//方法假定列表元素实现了 Comparable 接口</span></span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));  <span class="comment">//使用 List 接口的 sort方法并传入一个 Comparator 对象。</span></span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.reverseOrder());  <span class="comment">//按降序排列</span></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed())  <span class="comment">//按工资逆序排序</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);  <span class="comment">//随机地混排列表中元素的顺序,如果提供的列表没有实现 RandomAccess 接口，shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-二分查找（binarySearch）"><a href="#2-二分查找（binarySearch）" class="headerlink" title="2. 二分查找（binarySearch）"></a>2. 二分查找（binarySearch）</h2><ol>
<li>要使用二分查找，必须提供排好序的集合以及要查找的元素，且该集合必须实现List接口。</li>
<li>如果集合没有采用 Comparable 接口的 compareTo 方法进行排序， 就还要提供一个比较器对象。</li>
<li>只有采用随机访问，二分査找才有意义，若果为 binarySearch 算法提供一个链表，它将自动地变为线性查找。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值 &gt;=0 ,表示匹配对象的索引。</span></span><br><span class="line"><span class="comment">//返回负值，表示没有匹配的元素。应该将这个键插人到列表索引（-i - l）的位置上，以保持列表的有序性。</span></span><br><span class="line">i = Collections.binarySearch(c, element); </span><br><span class="line">i = Collections.binarySearch(c, element, comparator);</span><br><span class="line">c.get(i);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">    c.add(-i - <span class="number">1</span>, element);</span><br></pre></td></tr></table></figure>

<h2 id="3-简单算法"><a href="#3-简单算法" class="headerlink" title="3. 简单算法"></a>3. 简单算法</h2><p>Collections 类中提供的各种简单算法可以增加代码的可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.replaceAll (<span class="string">"C++"</span>, <span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">words.removelf(w -&gt; w.length() &lt;= <span class="number">3</span>);</span><br><span class="line">words.replaceAll(String::toLowerCase);</span><br></pre></td></tr></table></figure>

<h2 id="4-批操作"><a href="#4-批操作" class="headerlink" title="4. 批操作"></a>4. 批操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 coll1 中删除 coll2 中出现的所有元素。</span></span><br><span class="line">colll.removeAll(coll2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求coll1和coll2的交集</span></span><br><span class="line">coll1.retainAll(coll2);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">result.retainAll(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在视图上批量操作</span></span><br><span class="line">Map&lt;String, Employee&gt; staffMap = ...;</span><br><span class="line">Set&lt;String&gt; terminatedIDs = ...;</span><br><span class="line">staffMap.keySet().removeAll(terminatedIDs);</span><br><span class="line">relocated.addAll(staff.subList(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">staff.subList(<span class="number">0</span>, <span class="number">10</span>).clear();</span><br></pre></td></tr></table></figure>

<h2 id="5-集合与数组的转换"><a href="#5-集合与数组的转换" class="headerlink" title="5. 集合与数组的转换"></a>5. 集合与数组的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把一个数组转换为集合</span></span><br><span class="line">String[] values = ...;</span><br><span class="line">HashSet&lt;String&gt; staff = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//从集合得到数组</span></span><br><span class="line">Object[] values = staff.toArray();   <span class="comment">//返回的数组是一个 Object[] 数组，不能使用强制类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个所需类型而且长度为 0 的数组</span></span><br><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);  <span class="comment">// 返回的数组就会创建为相同的数组类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以构造一个指定大小的数组</span></span><br><span class="line">staff.toArray(<span class="keyword">new</span> String[staff.size()]);  <span class="comment">//这种情况不会创建新数组</span></span><br></pre></td></tr></table></figure>

<h2 id="6-编写自己的算法"><a href="#6-编写自己的算法" class="headerlink" title="6. 编写自己的算法"></a>6. 编写自己的算法</h2><p>如果编写自己的算法（实际上，是以集合作为参数的任何方法，) 应该尽可能地使用接口，而不要使用具体的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用接口作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillMenu</span><span class="params">(]Menu menu, Collection&lt;]MenuItem&gt; items)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (JMenuItem item : items)</span><br><span class="line">        menu.add(item); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回接口,在这种情况下，调用者返回的对象是一个不可修改的列表。</span></span><br><span class="line">List&lt;]MenuItem&gt; getAllItems(<span class="keyword">final</span> JHenu menu) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span></span><br><span class="line">    AbstractList&lt;&gt;() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> JMenuItem <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> menu.getltem(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> menu.getltemCount(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、遗留的集合"><a href="#六、遗留的集合" class="headerlink" title="六、遗留的集合"></a>六、遗留的集合</h1><p>在集合框架出现之前已经存在大量“遗留的” 容器类。这些类已经集成到集合框架中。<br><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%81%97%E7%95%99%E7%B1%BB.png" alt="遗留类"></p>
<h2 id="1-Hashtable-类"><a href="#1-Hashtable-类" class="headerlink" title="1. Hashtable 类"></a>1. Hashtable 类</h2><ol>
<li>Hashtable 类与 HashMap 类的作用一样，它们拥有相同的接口。</li>
<li>Hashtable 和Vector类的方法是同步的，如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 HashMap。如果需要并发访问， 则要使用 ConcurrentHashMap。</li>
</ol>
<h2 id="2-枚举（Enumeration）"><a href="#2-枚举（Enumeration）" class="headerlink" title="2. 枚举（Enumeration）"></a>2. 枚举（Enumeration）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遗留集合使用 Enumeration 接口对元素序列进行遍历。</span></span><br><span class="line">Enumeration&lt;Employee&gt; e = staff.elements();</span><br><span class="line">whi1e (e.HasMoreElements()) </span><br><span class="line">&#123;</span><br><span class="line">    Employee e = e.nextElement(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留方法，其参数是枚举类型的。</span></span><br><span class="line">List&lt;InputStream&gt; streams = ...;</span><br><span class="line">SequenceInputStream in = <span class="keyword">new</span> SequencelnputStream(Collections.enumeration(streams));</span><br></pre></td></tr></table></figure>

<h2 id="3-属性映射（Properties）"><a href="#3-属性映射（Properties）" class="headerlink" title="3. 属性映射（Properties）"></a>3. 属性映射（Properties）</h2><p>属性映射是一个类型非常特殊的映射结构,通常用于程序的特殊配置选项。</p>
<ul>
<li>键与值都是字符串。 </li>
<li>表可以保存到一个文件中，也可以从文件中加载。 </li>
<li>使用一个默认的辅助表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties() <span class="comment">//创建一个空的属性映射。 </span></span><br><span class="line">Properties(Properties defaults)  <span class="comment">//创建一个带有一组默认值的空的属性映射。 </span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span> <span class="comment">//获得属性的对应关系；返回与键对应的字符串。 如果在映射中不存在，返回默认表中与这个键对应的字符串。 </span></span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span> <span class="comment">//获得在键没有找到时具有的默认值属性；它将返回与键对应的字符串，如果在映射中不存在，就返回默认的字符串。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span>  <span class="comment">//从 InputStream 加载属性映射。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out, String commentstring)</span> <span class="comment">//把属性映射存储到 OutputStream。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-栈（Stack）"><a href="#4-栈（Stack）" class="headerlink" title="4. 栈（Stack）"></a>4. 栈（Stack）</h2><p>Stack类扩展于Vector类，Vector 类并不太令人满意，它可以让栈使用不属于栈操作的 insert 和 remove 方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E item)</span> <span class="comment">//将 item 压入桟并返回 item。  </span></span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span> <span class="comment">//弹出并返回栈顶的 item。如果栈为空，请不要调用这个方法。 </span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span> <span class="comment">//返回栈顶元素，但不弹出。如果栈为空，请不要调用这个方法。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="5-位集（BitSet）"><a href="#5-位集（BitSet）" class="headerlink" title="5. 位集（BitSet）"></a>5. 位集（BitSet）</h2><ol>
<li>BitSet 类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适)。如果需要高效地存储位序列（例如，标志）就可以使用位集。</li>
<li>由于位集将位包装在字节里，所以使用位集要比使用 Boolean 对象的 ArrayList 更加高效。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bucketOfBits.get(i) <span class="comment">//如果第 i 位处于“开” 状态，就返回 true; 否则返回 false。</span></span><br><span class="line">bucketOfBits.set(i) <span class="comment">//将第 i 位置为“开” 状态。</span></span><br><span class="line">bucketOfBits.clear(i)  <span class="comment">//将第 i 位置为“关” 状态。</span></span><br><span class="line"></span><br><span class="line">BitSet(<span class="keyword">int</span> initialCapacity) <span class="comment">//创建一个位集。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//返回位集的“逻辑长度”， 即 1 加上位集的最高设置位的索引。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet set )</span> <span class="comment">//这个位集与另一个位集进行逻辑“ AND”。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet set )</span> <span class="comment">//这个位集与另一个位集进行逻辑“ OR”。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet set )</span> <span class="comment">//这个位集与另一个位集进行逻辑“ X0R” 异或。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span> <span class="comment">//清除这个位集中对应另一个位集中设置的所有位。</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的并发</title>
    <url>/2020/05/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>多进程程序中的每一个进程都拥有自己的一整套变量，而线程则共享数据，共享变量使线程之间的通信比进程之间的通信更有效、 更容易，且在有的操作系统中线程更加轻量级。在实际应用中有很多地方都用到了多线程，例如一个浏览器可以同时下载几幅图片等等。</p>
<h1 id="一、创建线程"><a href="#一、创建线程" class="headerlink" title="一、创建线程"></a>一、创建线程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个单独的线程中执行一个任务的简单过程</span></span><br><span class="line">Runnable r = () -&gt;     <span class="comment">//1. 将任务代码移到实现了 Runnable 接口的类的 run 方法中,由于 Runnable 是一个函数式接口，可以用 lambda 表达式建立一个实例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= STEPS; i ++) </span><br><span class="line">        &#123;</span><br><span class="line">            ball.move(comp.getBounds());</span><br><span class="line">            comp.repaint();</span><br><span class="line">            Thread.sleep(DELAY);  <span class="comment">//休眠给定的毫秒数，以阻塞线程</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);     <span class="comment">//2. 由 Runnable 创建一个 Thread 对象</span></span><br><span class="line">t.start();    <span class="comment">//3. 启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式接口Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、中断线程"><a href="#二、中断线程" class="headerlink" title="二、中断线程"></a>二、中断线程</h1><ol>
<li>当线程的 run 方法执行方法体中最后一条语句后， 并经由执行 return 语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。</li>
<li>没有可以强制线程终止的方法，但是有方法可以用来请求终止线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不断检查当前线程是否被中断</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().islnterrupted() &amp;&amp; more work to <span class="keyword">do</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// thread was interr叩ted during sleep or wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        cleanup,<span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exiting the run method terminates the thread</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对InterruptedException 异常的处理</span></span><br><span class="line"><span class="comment">//在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123; sleep(delay); &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">    &#123; </span><br><span class="line">        Thread.currentThread().interrupt(); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用 throws InterruptedException 标记你的方法， 让调用者（或者， 最终的 run 方法）去捕获这一异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> <span class="comment">//向线程发送中断请求。线程的中断状态将被设置为 true。如果目前该线程被一个 sleep调用阻塞，那么，InterruptedException 异常被抛出。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> <span class="comment">//测试当前线程（即正在执行这一命令的线程）是否被中断。注意，这是一个静态方法。这一调用会产生副作用—它将当前线程的中断状态重置为 false。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> <span class="comment">//这是一个实例方法，测试线程是否被终止。不像静态的中断方法，这一调用不改变线程的中断状态。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> <span class="comment">//返回代表当前执行线程的 Thread 对象。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="三、线程状态（6种）"><a href="#三、线程状态（6种）" class="headerlink" title="三、线程状态（6种）"></a>三、线程状态（6种）</h1><ul>
<li>New (新创建） </li>
<li>Runnable (可运行） </li>
<li>Blocked (被阻塞） </li>
<li>Waiting (等待） </li>
<li>Timed waiting (计时等待） </li>
<li>Terminated (被终止）</li>
</ul>
<p>线程状态间的转换：<br><img src="%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="线程状态转换"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.<span class="function">State <span class="title">getState</span><span class="params">()</span>  <span class="comment">//得到这一线程的状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING或 TERMINATED 之一。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="1-新创建线程"><a href="#1-新创建线程" class="headerlink" title="1. 新创建线程"></a>1. 新创建线程</h2><p>在<code>newThread(r)</code>之后还未运行之前，还有一些基础工作要做，这个状态称为new状态，即新创建状态。</p>
<h2 id="2-可运行线程"><a href="#2-可运行线程" class="headerlink" title="2. 可运行线程"></a>2. 可运行线程</h2><ol>
<li>一旦调用 start 方法，线程就处于 runnable 状态。</li>
<li>然而为了让其它线程获得运行机会，运行中的线程可能被中断，线程调度的细节依赖于操作系统提供的服务(抢占式调度或协作式调度)。</li>
<li>现在所有的桌面以及服务器操作系统都使用抢占式调度（时间片和优先级调度），像手机这样的小型设备可能使用协作式调度（线程只有在调用 yield 方法、 或者被阻塞或等待时，线程才失去控制权。）</li>
<li>故在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。</li>
</ol>
<h2 id="3-被阻塞线程和等待线程"><a href="#3-被阻塞线程和等待线程" class="headerlink" title="3. 被阻塞线程和等待线程"></a>3. 被阻塞线程和等待线程</h2><ol>
<li>当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。</li>
<li>线程转换为被阻塞状态或等待状态的时机：<ul>
<li>当一个线程试图获取一个内部的对象锁而该锁被其他线程持有，则该线程进入阻塞状。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。</li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用 <code>Object.wait</code> 方法或 <code>Thread.join</code> 方法， 或者是等待 <code>java.util.concurrent</code> 库中的 Lock 或 Condition 时， 就会出现这种情况。注意等待和阻塞状态是不同的。</li>
<li>有几个方法有一个超时参数。调用它们导致线程进入<strong>计时等待</strong>（ timed waiting ) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 <code>Thread.sleep</code> 和 <code>Object.wait</code>、<code>Threadjoin</code>、 <code>Lock.tryLock</code> 以及 <code>Condition.await</code> 的计时版。</li>
</ul>
</li>
</ol>
<h2 id="4-被终止的线程"><a href="#4-被终止的线程" class="headerlink" title="4. 被终止的线程"></a>4. 被终止的线程</h2><p>线程被终止的两个原因：</p>
<ul>
<li>因为 run 方法正常退出而自然死亡。</li>
<li>因为一个没有捕获的异常终止了 run 方法而意外死亡。</li>
</ul>
<h1 id="四、线程属性"><a href="#四、线程属性" class="headerlink" title="四、线程属性"></a>四、线程属性</h1><h2 id="1-线程优先级"><a href="#1-线程优先级" class="headerlink" title="1. 线程优先级"></a>1. 线程优先级</h2><ol>
<li>在 Java 程序设计语言中，每一个线程有一个优先级。</li>
<li>默认情况下，一个线程继承它的父线程的优先级。可以用 <code>setPriority</code> 方法提高或降低任何一个线程的优先级。</li>
<li>可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。一般使用 NORM_PRIORITY （默认优先级，被定义为 5）。</li>
<li>线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">( )</span> <span class="comment">//导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。注意，这是一个静态方法。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-守护线程（daemon）"><a href="#2-守护线程（daemon）" class="headerlink" title="2. 守护线程（daemon）"></a>2. 守护线程（daemon）</h2><ol>
<li>守护线程的唯一用途是为其他线程提供服务。</li>
<li>当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。</li>
<li>守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">( <span class="keyword">boolean</span> isDaemon )</span>   <span class="comment">//标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-未捕获异常处理器"><a href="#3-未捕获异常处理器" class="headerlink" title="3. 未捕获异常处理器"></a>3. 未捕获异常处理器</h2><ol>
<li>线程的 run方法不能抛出任何受查异常，不需要任何 catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</li>
<li>该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置或获取未捕获异常的默认处理器。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(Thread.UncaughtExceptionHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Thread.UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//设置或获取未捕获异常的处理器。如果没有安装处理器，则将线程组对象作为处理器。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(Thread.UncaughtExceptionHandlerhandler)</span></span></span><br><span class="line"><span class="function">Thread.UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Thread.UncaughtExceptionHandler 接口中的唯一方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UncaughtException</span><span class="params">(Thread t, Throwable e)</span>  <span class="comment">//当一个线程因未捕获异常而终止， 按规定要将客户报告记录到日志中。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="五、同步"><a href="#五、同步" class="headerlink" title="五、同步"></a>五、同步</h1><h2 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1. 竞争条件"></a>1. 竞争条件</h2><p>往往线程中的某个修改操作不是原子操作，则当线程1在计算的过程中被剥夺运行权，并在线程2修改完成同一项内容后被唤醒时，线程1对该项做的修改就会擦除线程2对该项做出的修改，此时程序就会出现错误。如果能够确保线程在失去控制之前方法运行完成，那么程序就不会因为竞争条件而产生错误。<br>指令<code>accounts[to] += amount;</code>就不是一个原子操作：</p>
<ul>
<li>将 accounts[to] 加载到寄存器。</li>
<li>增加 amount。</li>
<li>将结果写回 accounts[to]。</li>
</ul>
<h2 id="2-锁对象（ReentrantLock）"><a href="#2-锁对象（ReentrantLock）" class="headerlink" title="2. 锁对象（ReentrantLock）"></a>2. 锁对象（ReentrantLock）</h2><ol>
<li>ReentrantLock 保护代码块的结构确保任何时刻只有一个线程进入<strong>临界区</strong>。一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞，直到第一个线程释放锁对象。</li>
<li>必须在finally子句中包括解锁 unlock 操作，如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。</li>
<li>如果使用锁，就不能使用带资源的 try 语句。</li>
<li>加了锁的类的每一个对象都有自己的 ReentrantLock 锁对象。</li>
<li>锁是<strong>可重入的</strong>， 因为线程可以重复地获得<strong>已经持有的锁</strong>。锁保持一个<strong>持有计数</strong>来跟踪对 lock 方法的嵌套调用，当该计数为0时，线程才释放锁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用 ReentrantLock 保护代码块的基本结构</span></span><br><span class="line">myLock.lock(); <span class="comment">// a ReentrantLock object</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    临界区  <span class="comment">//临界区的代码要仔细设计，避免因为异常的抛出而跳出临界区，否则finally 子句释放锁之后会使对象可能处于一种受损状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    myLock.unlock();  <span class="comment">// 确保锁被释放，即使抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用：使用一个锁来保护 Bank 类的 transfer 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构建一个可以被用来保护临界区的可重入锁对象。</span></span><br><span class="line">    <span class="keyword">private</span> Lock bankLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// ReentrantLock 实现了 Lock 接口</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> amount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取这个锁；如果锁同时被另一个线程拥有则发生阻塞。</span></span><br><span class="line">        bankLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(Thread.currentThread());</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            System.out.printf(<span class="string">" %10.2f from %d to %d"</span>, amount, from, to);</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">            System.out.printf(<span class="string">" Total Balance: %10.2f%n"</span>, getTotalBalance());  <span class="comment">//transfer 方法调用 getTotalBalance 方法，这也会封锁 bankLock 对象，此时 bankLock对象的持有计数为 2。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//释放这个锁。</span></span><br><span class="line">            banklock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReentrantLock(<span class="keyword">boolean</span> fair) <span class="comment">//构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以， 默认情况下， 锁没有被强制为公平的。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-条件对象"><a href="#3-条件对象" class="headerlink" title="3. 条件对象"></a>3. 条件对象</h2><ol>
<li>线程进入临界区后发现需要满足某一条件之后才能执行，但由于判断条件和执行语句之间可能被其它线程打断，故为了避免错误需要使用一个条件对象来管理这些线程。</li>
<li>使用条件对象的await方法使当前需要某条件的线程阻塞并放弃锁。</li>
<li>等待获得锁的线程和调用 await 方法的线程存在本质上的不同。一旦一个线程调用 await 方法，它进入该条件的<strong>等待集</strong>。<strong>当锁可用时</strong>，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的 signalAll 方法时为止。</li>
<li>当调用条件对象的signalALL方法时会重新激活因为这一条件而等待的<strong>所有线程</strong>。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从 await 调用返回， 获得该锁并从被阻塞的地方继续执行。</li>
<li>如果所有其他线程被阻塞， 最后一个活动线程在解除其他线程的阻塞状态之前就调用 await 方法，那么它也被阻塞，这会导致<strong>死锁</strong>现象，并使该程序被挂起。</li>
<li>经验上讲，在对象的状态有利于等待线程的方向改变时调用 signalAll。</li>
<li>条件对象的另一个方法 signal, 是<strong>随机解除</strong>等待集中<strong>某个</strong>线程的阻塞状态。这更加有效，但存在危险。如果随机选择的线程发现自己仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用 signal, 那么系统就死锁了。</li>
<li>当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用 await、signalAll 或signal 方法。</li>
<li>锁可以拥有一个或多个相关的条件对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">    <span class="keyword">private</span> Lock bankLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds = = bankLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bankLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (accounts [from] &lt; amount)</span><br><span class="line">                sufficientFunds.await();  <span class="comment">//等待满足某条件</span></span><br><span class="line">            System.out.print(Thread.currentThread());</span><br><span class="line">            accounts[from] -= amount;  </span><br><span class="line">            System.out.printf(<span class="string">" %10.2f from %d to %d"</span>, amount, from, to);</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">            System.out.printf(<span class="string">" Total Balance: %10.2f%n"</span>, getTotalBalance());</span><br><span class="line">            sufficientFunds.signalAll();  <span class="comment">//释放所有等待集</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-synchronized-关键字-内部对象锁"><a href="#4-synchronized-关键字-内部对象锁" class="headerlink" title="4. synchronized 关键字(内部对象锁)"></a>4. synchronized 关键字(内部对象锁)</h2><ol>
<li>从 1.0 版开始，Java中的每一个对象都有一个内部锁和一个内部条件。如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。</li>
<li>内部对象锁<strong>只有一个相关条件</strong>。wait 方法添加一个线程到等待集中，notifyAll/notify 方法解除等待线程的阻塞状态。</li>
<li>将静态方法声明为 synchronized 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁，且没有其他线程可以调用<strong>同一个类的这个或任何其他的同步静态方法</strong>。</li>
<li>实际应用中应尽量使用synchronized 关键字，只有在特别需要 Lock/Condition 结构提供的独有特性时，才使用 Lock/Condition。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部锁的基本结构,以下两种结构等价</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    method body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">this</span>.intrinsicLock.unlock(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from，<span class="keyword">int</span> to, <span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (accounts[from] &lt; amount)</span><br><span class="line">            wait(); <span class="comment">// 类似await</span></span><br><span class="line">        accounts[from] -= amount ;</span><br><span class="line">        accounts[to] += amount ;</span><br><span class="line">        notifyAll();<span class="comment">// 类似signalAll</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span> </span>&#123; . . . &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-同步阻塞"><a href="#5-同步阻塞" class="headerlink" title="5. 同步阻塞"></a>5. 同步阻塞</h2><p>通过进入一个同步阻塞也可以获得每个java对象持有的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本结构</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) <span class="comment">//获得obj的锁</span></span><br><span class="line">&#123;</span><br><span class="line">    critical section</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> amount)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (accounts) </span><br><span class="line">    &#123;</span><br><span class="line">        accounts.set(from, accounts.get(from) - amount);</span><br><span class="line">        accounts.set(to, accounts.get(to) + amount); </span><br><span class="line">    &#125;</span><br><span class="line">    Systen.out.print1n(. . .); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-监视器概念"><a href="#6-监视器概念" class="headerlink" title="6. 监视器概念"></a>6. 监视器概念</h2><ol>
<li>监视器可以在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性，可用synchronized 关键字来实现。</li>
<li>监视器应满足如下特性：<ul>
<li>监视器是只包含私有域的类。</li>
<li>每个监视器类的对象有一个相关的锁。 </li>
<li>使用该锁对所有的方法进行加锁。换句话说，如果客户端调用 对象的某个方法, 那么对象的锁是在方法调用开始时自动获得， 并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时， 没有其他线程能访问该域。 </li>
<li>该锁可以有任意多个相关条件。</li>
</ul>
</li>
</ol>
<h2 id="7-Volatile-域"><a href="#7-Volatile-域" class="headerlink" title="7. Volatile 域"></a>7. Volatile 域</h2><ol>
<li>volatile 关键字为实例域的同步访问提供了一种免锁机制。</li>
<li>如果声明一个域为 volatile ,那么<strong>编译器</strong>和<strong>虚拟机</strong>就知道该域是可能被另一个线程并发更新的。</li>
<li>Volatile 变量不能提供原子性，不能保证读取、 翻转和写入不被中断，故该变量只用于原子操作时可声明为Volatile。</li>
<li>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后：<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ul>
</li>
</ol>
<h2 id="8-final-变量"><a href="#8-final-变量" class="headerlink" title="8. final 变量"></a>8. final 变量</h2><p>还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;String, Double&gt; accounts = <span class="keyword">new</span> HashKap&lt;&gt;(); <span class="comment">//其他线程会在构造函数完成构造之后才看到这个 accounts 变量。否则不能保证其他线程看到的是 accounts 更新后的值，它们可能都只是看到 null , 而不是新构造的 HashMap。</span></span><br></pre></td></tr></table></figure>

<h2 id="9-原子性"><a href="#9-原子性" class="headerlink" title="9. 原子性"></a>9. 原子性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong nextNumber = <span class="keyword">new</span> AtomicLong(); </span><br><span class="line"><span class="keyword">long</span> id = nextNumber.incrementAndGet();  <span class="comment">//以原子方式将 AtomicLong 自增，并返回自增后的值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    oldValue = largest.get();</span><br><span class="line">    newValue = Math.max (oldValue , observed); </span><br><span class="line">&#125;<span class="keyword">while</span> (llargest.compareAndSet(oldValue, newValue));  <span class="comment">//如果另一个线程也在更新 largest，就可能阻止这个线程更新。这样一来，compareAndSet会返回 false, 而不会设置新值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda 表达式更新变量</span></span><br><span class="line">largest.updateAndGet(x -&gt; Math .max(x, observed));</span><br><span class="line">largest.accumulateAndCet(observed, Math::max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//累加</span></span><br><span class="line">LongAccumulator adder = <span class="keyword">new</span> LongAccumulator(Long::sum, <span class="number">0</span>); </span><br><span class="line">adder.accumulate(value);</span><br></pre></td></tr></table></figure>

<h2 id="10-死锁"><a href="#10-死锁" class="headerlink" title="10. 死锁"></a>10. 死锁</h2><ol>
<li>锁和条件不能解决多线程中的所有问题，在程序运行的过程中有可能所有的线程都会被阻塞，这样的状态就称为死锁，当程序进入死锁状态时程序就会被挂起。</li>
<li>当程序挂起时，键入 <code>CTRL+\</code>, 将得到一个所有线程的列表。每一个线程有一个栈踪迹，告诉你线程被阻塞的位置。</li>
<li>Java 编程语言中没有任何东西可以避免或打破这种死锁现象。只能仔细设计程序，以确保不会出现死锁。</li>
</ol>
<h2 id="11-线程局部变量"><a href="#11-线程局部变量" class="headerlink" title="11. 线程局部变量"></a>11. 线程局部变量</h2><p>由于在线程间共享变量有死锁的风险，且使用同步机制会产生很大的开销，故对于那些不需要共享的变量就可以使用线程局部变量为各个线程提供各自的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用ThreadLocal辅助类构造SimpleDateFormat的线程局部变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat =ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">String dateStamp = dateFormat.get().format(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ThreadLocalRandom类为各个线程提供一个单独的随机数生成器</span></span><br><span class="line"><span class="keyword">int</span> random = ThreadLocalRandom.current().nextlnt(upperBound);  <span class="comment">//ThreadLocalRandom.current() 调用会返回特定于当前线程的 Random 类实例。</span></span><br></pre></td></tr></table></figure>

<h2 id="12-锁测试与超时"><a href="#12-锁测试与超时" class="headerlink" title="12. 锁测试与超时"></a>12. 锁测试与超时</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tryLock 方法试图申请一个锁， 在成功获得锁后返回 true, 否则，立即返回false, 而且线程可以立即离开去做其他事情。</span></span><br><span class="line"><span class="keyword">if</span> (myLock.tryLock()) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; . . . &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; myLock.unlock(); &#125; &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 tryLock 时，使用超时参数,如果线程在等待期间被中断，将抛出InterruptedException 异常。这是一个非常有用的特性，因为允许程序打破死锁。</span></span><br><span class="line"><span class="comment">//TimeUnit 是一 枚举类型，可以取的值包括 SECONDS、MILLISECONDS, MICROSECONDS和 NANOSECONDS</span></span><br><span class="line"><span class="comment">//也可以调用 locklnterruptibly 方法。它就相当于一个超时设为无限的 tryLock 方法。</span></span><br><span class="line"><span class="keyword">if</span> (myLock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))</span><br><span class="line"></span><br><span class="line"><span class="comment">//在等待一个条件时， 也可以提供一个超时,</span></span><br><span class="line"><span class="comment">//可以使用 awaitUninterruptibly 方法代替 await,这会使等待的线程被中断时继续等待下去。</span></span><br><span class="line">myCondition.await(<span class="number">100</span>, TimeUnit.MILLISECONDS))</span><br></pre></td></tr></table></figure>

<h2 id="13-读-写锁"><a href="#13-读-写锁" class="headerlink" title="13. 读 / 写锁"></a>13. 读 / 写锁</h2><p>如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，使用ReentrantReadWriteLock 类是十分有用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用读/写锁的步骤</span></span><br><span class="line"><span class="comment">//1. 构造一个 ReentrantReadWriteLock 对象</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//2. 抽取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> Lock readLock = rwl . readLock();</span><br><span class="line"><span class="keyword">private</span> Lock writeLock = rwl .writeLock();</span><br><span class="line"><span class="comment">//3. 对所有的获取方法加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; . . . &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; readLock.unlock(); &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4. 对所有的修改方法加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(. . .)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; . . . &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; writeLock.unlock(); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、阻塞队列"><a href="#六、阻塞队列" class="headerlink" title="六、阻塞队列"></a>六、阻塞队列</h1><p>阻塞队列是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95.png" alt="阻塞队列方法"></p>
<h1 id="七、线程安全的集合"><a href="#七、线程安全的集合" class="headerlink" title="七、线程安全的集合"></a>七、线程安全的集合</h1><h2 id="1-高效的映射、集和队列"><a href="#1-高效的映射、集和队列" class="headerlink" title="1. 高效的映射、集和队列"></a>1. 高效的映射、集和队列</h2><ol>
<li><code>java.util.concurrent</code> 包提供了映射、 有序集和队列的高效实现：<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code> 和 <code>ConcurrentLinkedQueue</code>。</li>
<li>这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。</li>
<li>size 方法不必在常量时间内操作,通常需要遍历来确定集合当前的大小。</li>
</ol>
<h2 id="2-映射条目的原子更新"><a href="#2-映射条目的原子更新" class="headerlink" title="2. 映射条目的原子更新"></a>2. 映射条目的原子更新</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//replace操作</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    oldValue = map.get(word);</span><br><span class="line">    newValue = oldValue = <span class="keyword">null</span> ? <span class="number">1</span> : oldValue + <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">while</span> (!map.replace(word, oldValue, newValue));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个 ConcurrentHashMap&lt;String, AtomicLong&gt;或者使用 ConcurrentHashMap&lt;String，LongAdder&gt;</span></span><br><span class="line">map.putIfAbsent(word, <span class="keyword">new</span> LongAdder()).increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 compute 方法</span></span><br><span class="line">map.compute(word , (k, v) -&gt; v = <span class="keyword">null</span> ? <span class="number">1</span>: v + <span class="number">1</span>);  </span><br><span class="line">map.computelfAbsent(word , k -&gt; <span class="keyword">new</span> LongAdder()).increment();</span><br><span class="line"></span><br><span class="line">map.merge(word, <span class="number">1L</span>, (existingValue, newValue) -&gt; existingValue + newValue);</span><br><span class="line">map.merge(word, <span class="number">1L</span>, Long::sum);</span><br></pre></td></tr></table></figure>

<h2 id="3-对并发散列映射的批操作"><a href="#3-对并发散列映射的批操作" class="headerlink" title="3. 对并发散列映射的批操作"></a>3. 对并发散列映射的批操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//search操作</span></span><br><span class="line">String result = map.search(threshold, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k : <span class="keyword">null</span>);</span><br><span class="line">map.forEach(threshold, (k, v) -&gt; System.out.println(k + <span class="string">" -&gt; "</span> + v)); <span class="comment">//只为各个映射条目提供一个消费者函数</span></span><br><span class="line">map.forEach(threshold, (k, v) -&gt; k + <span class="string">" -&gt; "</span> + v, System.out::println);  <span class="comment">//添加一个转换器函数，这个函数要先提供， 其结果会传递到消费者</span></span><br><span class="line">map.forEach(threshold, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k + <span class="string">" -&gt; "</span> + v : <span class="keyword">null</span>, System.out::println); <span class="comment">//转换器可以用作为一个过滤器，过滤结果为null的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce操作，利用一个累加函数组合其输入</span></span><br><span class="line">Long sum = map.reduceValues(threshold, Long::sum); <span class="comment">//计算所有值的总和</span></span><br><span class="line">Integer maxlength = map.reduceKeys(threshold, String::length, Integer::max);  <span class="comment">//提供一个转换器函数，计算最长的键的长度</span></span><br><span class="line">Long count = map. reduceValues(threshold, v -&gt; v &gt; <span class="number">1000</span> ? <span class="number">1L</span> : <span class="keyword">null</span> , Long::sum);  <span class="comment">//转换器可以作为一个过滤器，通过返回 null 来排除不想要的输入。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-并发集视图"><a href="#4-并发集视图" class="headerlink" title="4. 并发集视图"></a>4. 并发集视图</h2><p>可以由ConcurrentHashMap的某些操作得到一个线程安全的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//newKeySet 方法生成这个映射的键集。</span></span><br><span class="line">Set&lt;String&gt; words = ConcurrentHashMap.&lt;String&gt;newKeySet();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//keySet 方法，包含一个默认值，可以在为集增加元素时使用</span></span><br><span class="line">Set&lt;String&gt; words = map.keySet(<span class="number">1L</span>);</span><br><span class="line">words.add(<span class="string">"Java"</span>);   <span class="comment">//如果 "Java" 在 words 中不存在， 现在它会有一个值 1。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-写数组的拷贝"><a href="#5-写数组的拷贝" class="headerlink" title="5. 写数组的拷贝"></a>5. 写数组的拷贝</h2><ol>
<li>CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。</li>
<li>如果数组后来被修改了，迭代器仍然引用旧数组，但是，集合的数组已经被替换了。因而，旧的迭代器拥有一致的（可能过时的）视图，访问它无须任何同步开销。</li>
</ol>
<h2 id="6-并行数组算法"><a href="#6-并行数组算法" class="headerlink" title="6. 并行数组算法"></a>6. 并行数组算法</h2><p>Java SE 8中，Arrays 类提供了大量并行化操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态 Arrays.parallelSort 方法对一个基本类型值或对象的数组排序。</span></span><br><span class="line">String contents = <span class="keyword">new</span> String(Files.readAllBytes(Paths.get(<span class="string">"alice.txt"</span>)), StandardCharsets.UTF_8);  <span class="comment">//将文件中的内容读入string中 </span></span><br><span class="line">String[] words = contents.split(<span class="string">"[\\P&#123;L&#125;]+"</span>); <span class="comment">// 按非字母拆分</span></span><br><span class="line">Arrays.parallelSort(words):</span><br><span class="line"></span><br><span class="line">Arrays.parallelSort(words, Comparator.comparing(String::length)); <span class="comment">//提供一个 Comparator进行排序</span></span><br><span class="line">values.parallelSort(values, length / <span class="number">2</span>, values,length); <span class="comment">//提供一个排序的边界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parallelSetAll 方法会用由一个函数计算得到的值填充一个数组。</span></span><br><span class="line">Arrays.parallelSetAll(values, i-&gt; i % <span class="number">10</span>); <span class="comment">// 以 0 12 3 4 5 6 7 8 9 0 12 . . .来填充值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parallelPrefix 方法，它会用对应一个给定结合操作的前缀的累加结果替换各个数组元素。</span></span><br><span class="line"><span class="comment">//操作并行完成，即经过log(n)步之后，这个过程结束。</span></span><br><span class="line">Arrays.parallelPrefix(values, (x, y) -&gt; x * y); <span class="comment">//若数组为[1,2,3,4,...],执行该操作后数组将包含[1, 1x 2, 1x 2 x 3, l x 2 x 3 x 4, . . .]</span></span><br></pre></td></tr></table></figure>

<h2 id="7-较早的线程安全集合"><a href="#7-较早的线程安全集合" class="headerlink" title="7. 较早的线程安全集合"></a>7. 较早的线程安全集合</h2><ol>
<li>Java的初始版本中，Vector 和 Hashtable 类就提供了线程安全的动态数组和散列表的实现。</li>
<li>ArrayList 和 HashMap 类不是线程安全的。</li>
<li>任何集合类都可以通过使用<strong>同步包装器</strong>变成线程安全的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步包装器，结果集合的方法使用锁加以保护，提供了线程安全访问</span></span><br><span class="line">List&lt;E&gt; synchArrayList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K , V&gt; synchHashMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K , V&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在另一个线程可能进行修改时要对集合进行迭代，仍然需要使用“ 客户端” 锁定：</span></span><br><span class="line"><span class="comment">//如果使用“ foreach” 循环必须使用同样的代码， 因为循环使用了迭代器。</span></span><br><span class="line"><span class="comment">//如果在迭代过程中，别的线程修改集合，迭代器会失效，抛出 ConcurrentModificationException 异常,因此并发的修改可以被可靠地检测出来。</span></span><br><span class="line"><span class="keyword">synchronized</span> (synchHashMap) </span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;K&gt; iter = synchHashMap.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、Callable-与-Future"><a href="#八、Callable-与-Future" class="headerlink" title="八、Callable 与 Future"></a>八、Callable 与 Future</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Callable接口封装一个异步运行的任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Future 保存异步计算的结果。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> . . .</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> . . .</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterrupt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FutureTask 包装器可将 Callable转换成 Future 和 Runnable,它同时实现二者的接口。</span></span><br><span class="line">Callable&lt;Integer&gt; myComputation = . . .;</span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myComputation);</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(task); <span class="comment">// it's a Runnable</span></span><br><span class="line">t.start();</span><br><span class="line">Integer result = task.get(); <span class="comment">// it's a Future</span></span><br></pre></td></tr></table></figure>

<h1 id="九、执行器"><a href="#九、执行器" class="headerlink" title="九、执行器"></a>九、执行器</h1><p>执行器（ Executor) 类有许多静态工厂方法用来构建线程池：<br><img src="%E6%89%A7%E8%A1%8C%E5%99%A8.png" alt="执行器"></p>
<h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>使用线程池的步骤：</p>
<ol>
<li>调用 Executors 类中静态的方法 newCachedThreadPool 或 newFixedThreadPool。</li>
<li>调用 submit 提交 Runnable 或 Callable 对象。</li>
<li>如果想要取消一个任务，或如果提交 Callable 对象，那就要保存好返回的 Future对象。</li>
<li>当不再提交任何任务时，调用 shutdown。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> <span class="comment">//返回一个带缓存的线程池， 该池在必要的时候创建线程， 在线程空闲 60 秒之后终止线程。 </span></span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> threads)</span> <span class="comment">//返回一个线程池， 该池中的线程数由参数指定。 </span></span></span><br><span class="line"><span class="function">ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> <span class="comment">//返回一个执行器， 它在一个单个的线程中依次执行各个任务。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Future&lt;T &gt; <span class="title">submit</span><span class="params">(Cal1able&lt;T&gt; task)</span> </span></span><br><span class="line"><span class="function">Future&lt; T &gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span> <span class="comment">//提交指定的任务去执行。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="comment">//关闭服务，会先完成已经提交的任务而不再接收新的任务。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span>  <span class="comment">//返回线程池在该执行器生命周期中的最大尺寸。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-预定执行"><a href="#2-预定执行" class="headerlink" title="2. 预定执行"></a>2. 预定执行</h2><p>ScheduledExecutorService 接口具有为预定执行或重复执行任务而设计的方法。</p>
<h2 id="3-控制任务组"><a href="#3-控制任务组" class="headerlink" title="3. 控制任务组"></a>3. 控制任务组</h2><p>使用执行器可以控制一组相关任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//invokeAll 方法提交所有对象到一个 Callable 对象的集合中</span></span><br><span class="line">List&lt;Callab1e&lt;T&gt;&gt; tasks = . . .;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span> (Future&lt;T&gt; result : results)</span><br><span class="line">    processFurther(result.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//用 ExecutorCompletionService 来进行排列</span></span><br><span class="line">ExecutorCompletionService&lt;T&gt; service = <span class="keyword">new</span> ExecutorCompletionServiceo(executor);</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; task : tasks) service,submit(task);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i ++) processFurther(service.take().get());</span><br></pre></td></tr></table></figure>

<h2 id="4-Fork-Join-框架"><a href="#4-Fork-Join-框架" class="headerlink" title="4. Fork-Join 框架"></a>4. Fork-Join 框架</h2><ol>
<li>Fork-join 框架专门用来完成计算密集型任务，如图像或视频处理，它通过将任务分解为多个子任务来执行，最后合并其结果。</li>
<li>Fork-join 框架使用了一种有效的智能方法称为<strong>工作密取</strong>来平衡可用线程的工作负载，每个工作线程都有一个双端队列来完成任务。</li>
</ol>
<h2 id="5-可完成Future"><a href="#5-可完成Future" class="headerlink" title="5. 可完成Future"></a>5. 可完成Future</h2><p>可完成future是可以组合的，利用可完成 fiiture，可以指定你希望做什么，以及希望以什么顺序执行这些工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConipletableFuture&lt;String&gt; contents = readPage(url);</span><br><span class="line">CompletableFuture&lt;List&lt;URL&gt;&gt; links = contents.thenApply(Parser::getlinks);</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="为 CompletableFuture&lt;T&gt; 对象增加一个动作"><br><img src="2.png" alt="组合多个组合对象"></p>
<h1 id="十、同步器"><a href="#十、同步器" class="headerlink" title="十、同步器"></a>十、同步器</h1><p><img src="3.png" alt="同步器"></p>
<h2 id="1-信号量"><a href="#1-信号量" class="headerlink" title="1. 信号量"></a>1. 信号量</h2><p>信号量作为<strong>同步原语</strong>可以被有效地实现， 并且有足够的能力解决许多常见的线程同步问题。</p>
<h2 id="2-倒计时门栓-CountDownLatch"><a href="#2-倒计时门栓-CountDownLatch" class="headerlink" title="2. 倒计时门栓(CountDownLatch)"></a>2. 倒计时门栓(CountDownLatch)</h2><p>一个倒计时门栓让一个线程集等待直到计数变为 0。倒计时门栓是一次性的。一旦计数为 0, 就不能再重用了。</p>
<h2 id="3-障栅-CyclicBarrier-类"><a href="#3-障栅-CyclicBarrier-类" class="headerlink" title="3. 障栅(CyclicBarrier 类)"></a>3. 障栅(CyclicBarrier 类)</h2><ol>
<li>CyclicBarrier 类实现了一个集结点称为障栅，当一个线程完成了它的那部分任务后就让它运行到障栅处。一旦所有的线程都到达了这个障栅，障栅就撤销，线程就可以继续运行。</li>
<li>如果任何一个在障栅上等待的线程离开了障栅，那么障栅就被破坏了，所有其他线程的 await 方法抛出 BrokenBarrierException 异常。</li>
<li>障栅被称为是循环的（ cyclic), 因为可以在所有等待线程被释放后被重用。</li>
<li>Phaser 类增加了更大的灵活性，允许改变不同阶段中参与线程的个数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先， 构造一个障栅， 并给出参与的线程数</span></span><br><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CydicBarrier(nthreads);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个线程做一些工作，完成后在障栅上调用 await</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doWork();</span><br><span class="line">    bamer.await();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//await 方法有一个可选的超时参数：</span></span><br><span class="line">barrier.await(<span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以提供一个可选的障栅动作（ barrier action), 当所有线程到达障栅的时候就会执行这一动作。</span></span><br><span class="line"><span class="comment">//该动作可以收集那些单个线程的运行结果。</span></span><br><span class="line">Runnable barrierAction = . . .;</span><br><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> Cyc1icBarrier(nthreads, barrierAction);</span><br></pre></td></tr></table></figure>

<h2 id="4-交换器（Exchanger）"><a href="#4-交换器（Exchanger）" class="headerlink" title="4. 交换器（Exchanger）"></a>4. 交换器（Exchanger）</h2><p>当两个线程在同一个数据缓冲区的两个实例上工作完成后，就可以使用交换器来相互交换缓冲区。</p>
<h2 id="5-同步队列（SynchronousQueue）"><a href="#5-同步队列（SynchronousQueue）" class="headerlink" title="5. 同步队列（SynchronousQueue）"></a>5. 同步队列（SynchronousQueue）</h2><ol>
<li>同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用 SynchronousQueue的 put 方法时，它会阻塞直到另一个线程调用 take 方法为止，数据仅仅沿一个方向传递。</li>
<li>即使 SynchronousQueue 类实现了 BlockingQueue 接口， 概念上讲，它依然不是一个队列。它没有包含任何元素，它的 size方法总是返回 0。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <url>/2020/06/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="一、运行时的数据区域"><a href="#一、运行时的数据区域" class="headerlink" title="一、运行时的数据区域"></a>一、运行时的数据区域</h1><p><img src="1.png" alt="JVM运行数据区"></p>
<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><ol>
<li>程序计数器是一块<strong>较小的</strong>内存空间,它可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>它是程序控制流的指示器,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为<strong>线程私有</strong>的内存。</li>
</ol>
<h2 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h2><ol>
<li>Java虚拟机栈也是<strong>线程私有</strong>的,它的生命周期与线程相同。</li>
<li>虚拟机栈描述的是<strong>Java方法执行的线程内存模型</strong>：每个方法被执行的时候,Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表,操作数栈,动态连接,方法出口</strong>等信息。</li>
<li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型,对象引用和returnAddress 类型(指向了一条字节码指令的地址)。</li>
<li>这些数据类型在局部变量表中的存储空间以<strong>局部变量槽</strong>来表示,其中64位长度的long和 double类型的数据会占用两个变量槽,其余的数据类型只占用一个。</li>
<li>局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在栈帧中分配多大的（指变量槽的个数）局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小。</li>
<li>虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特,64个比特,或者更多)来实现一个变量槽完全由具体的虚拟机实现自行决定。</li>
<li>该区域会出现两类异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展,当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</li>
</ol>
<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>本地方法栈的Java虚拟机栈实现的功能类似，只不过本地方法栈则是为虚拟机使用到的本地(Native) 方法服务的，本地方法栈中方法使用的语言,使用方式与数据结构并没有任何强制规定,因此具体的虚拟机可以根据需要自由实现它。</p>
<h2 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h2><ol>
<li>对于Java应用程序来说,Java堆是虚拟机所管理的内存中最大的一块，又称为<strong>GC堆</strong>（Garbage Collected Heap）。</li>
<li>它是<strong>线程共享</strong>的，在虚拟机<strong>启动时创建</strong>，只能存放对象实例。</li>
<li>从分配内存的角度看,所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer,TLAB),以提升对象分配时的效率。</li>
<li>Java堆可以物理不连续但必须逻辑连续，可被实现为固定大小也可以是扩展的，若在Java堆中没有内存完成实例分配,并且堆也无法再 扩展时,Java虚拟机将会抛出OutOfMemoryError异常。</li>
</ol>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><ol>
<li>方法区是<strong>线程共享的</strong>，用于存储<strong>已被虚拟机加载的类型信息,常量,静态变量,即时编译器编译后的代码缓存等数据。</strong></li>
<li>方法区不需要连续的内存，可以选择固定大小或者可扩展,甚至还可以选择不实现垃圾收集。</li>
<li>对该区域的垃圾收集目标主要是针对常量池的回收和对类型的卸载，若对此区域未完全回收则会导致内存泄漏。</li>
<li>如果方法区无法满足新的内存分配需求时,将抛出OutOfMemoryError异常。</li>
</ol>
<h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h2><ol>
<li>Class文件中除了有类的版本,字段,方法,接口等描述信息外,还有一项信息是常量池表,用于存放编译期生成的<strong>各种字面量与符号引用</strong>,这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>除了保存Class文件中描述的符号引用外,还会把由符号引用翻译出来的<strong>直接引用</strong>也存储在运行时常量池中。</li>
<li>运行时常量池具备动态性，即不要求常量一定只有编译期才能产生,运行期间也可以将新的常量放入池中。</li>
</ol>
<h1 id="二、直接内存"><a href="#二、直接内存" class="headerlink" title="二、直接内存"></a>二、直接内存</h1><ol>
<li>NIO(New Input/Output)类是一种基于通道与缓冲区的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。</li>
<li>本机直接内存的分配不会受到Java堆大小的限制，但仍然受本机总内存大小以及处理器寻址空间的限制，当各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现 OutOfMemoryError异常。</li>
</ol>
<h1 id="三、HotSpot虚拟机对象探秘"><a href="#三、HotSpot虚拟机对象探秘" class="headerlink" title="三、HotSpot虚拟机对象探秘"></a>三、HotSpot虚拟机对象探秘</h1><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h2><ol>
<li>当Java虚拟机遇到一条字节码new指令时，首先检查该指令参数是否能在常量池中定位到一个类的符号引用，并检查其代表的类是否已被加载,解析和初始化过，如果没有,那必须先执行相应的类加载过程。</li>
<li>类加载检查通过后,虚拟机将为新生对象分配内存（大小在类加载完后即可完全确定）:<blockquote>
<p><strong>指针碰撞方式</strong>：假设Java堆中内存是绝对规整的，就把分界点指示器指针向空闲空间方向挪动一段与对象大小相等的距离。<br><strong>空闲列表方式</strong>：假设使用的内存和空闲的内存相互交错在一起,则虚拟机就维护一个列表,记录哪些内存块是可用的,在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表记录。</p>
</blockquote>
</li>
</ol>
<p>使用哪种方式取决于Java堆所采用的垃圾收集器是否带有空间压缩整理的能力<br>3. 内存分配必须保证原子性：</p>
<blockquote>
<p><strong>比较并替换（Compare and substitute，CAS）加上失败重试的方式</strong><br> <strong>本地线程分配缓冲(线程本地分配缓冲区，TLAB)</strong>：为每个线程在Java堆中预先分配一小块内存TLAB, 则在需要内存时直接在线程的本地缓冲中分配，只有当本地缓冲区用完了才需要同步锁定来安全分配内存。</p>
</blockquote>
<ol start="4">
<li>内存分配完成之后,虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，以保证对象的实例字段在Java代码中可以不赋初始值就直接使用。</li>
<li>最后虚拟机在对象头中设置一些必要信息，如这个对象是哪个类的实例,如何才能找到类的元数据信息,对象的哈希码(实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算),对象的GC分代年龄等信息.</li>
<li>至此从虚拟机的视角来看,一个新的对象已经产生了，但从Java程序的视角看来,还需要再执行 <code>&lt;init&gt;()</code>方法后对象才算构造完成。</li>
</ol>
<h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><p>对象在堆内存中的存储布局包括三个部分：对象头、实例数据和对齐填充。</p>
<h3 id="2-1-对象头"><a href="#2-1-对象头" class="headerlink" title="2.1 对象头"></a>2.1 对象头</h3><ol>
<li><strong>用于存储对象自身的运行时数据Mark Word：</strong>哈希码,GC分代年龄,锁状态标志,线程持有的锁,偏向线程ID,偏向时间戳,32bit或64bit;</li>
<li><strong>类型指针:</strong>对象指向它的类型元数据的指针,Java虚拟机通过这个指针来确定该对象是哪个类的实例,并非所有的虚拟机实现都必须在对象数据上保留类型指针,因为查找对象的元数据信息并不一定要经过对象本身。</li>
<li>如果对象是一个Java数组,那在对象头中还必须有一块用于记录数组长度的数据。<br><img src="2.png" alt="Mark Word"></li>
</ol>
<h3 id="2-2-实例数据"><a href="#2-2-实例数据" class="headerlink" title="2.2 实例数据"></a>2.2 实例数据</h3><ol>
<li>实例数据部分是对象真正存储的有效信息,无论是从父类继承下来的,还是在子类中定义的字段都必须记录起来。</li>
<li>存储顺序受到虚拟机分配策略参数(-XX：FieldsAllocationStyle参数，默认为true)和字段在Java源码中定义顺序的影响。</li>
<li>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary对象指针，OOP),即相同宽度的字段总是被分配到一起存 放,在此前提下,在父类中定义的变量会出现在子类之前。</li>
<li>如果HotSpot虚拟机的 +XX：CompactFields参数值为true(默认就为true),那子类之中较窄的变量也允许插入父类变量的空隙之中,以节省出一点点空间。</li>
</ol>
<h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，即任何对象的大小都必须是8字节的整数倍，而对象头部分已经被精心设计成正好是8字节的倍数,因此,如果对象实例数据部分没有对齐的话,就需要通过对齐填充来补全。</p>
<h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h2><p>创建完对象后Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种。</p>
<h3 id="3-1-句柄访问"><a href="#3-1-句柄访问" class="headerlink" title="3.1 句柄访问"></a>3.1 句柄访问</h3><ol>
<li>reference中存储的是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</li>
<li>使用句柄访问对象的优点是reference中存储的是稳定句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针而无需修改reference。<br><img src="3.png" alt="句柄"></li>
</ol>
<h3 id="3-2-直接指针访问"><a href="#3-2-直接指针访问" class="headerlink" title="3.2 直接指针访问"></a>3.2 直接指针访问</h3><ol>
<li>reference中存储的直接就是对象地址,Java堆中对象的内存布局还必须考虑如何放置访问类型数据的相关信息。</li>
<li>最大的好处就是速度更快,它节省了一次指针定位的时间开销。</li>
<li>虚拟机HotSpot主要使用直接指针方式进行对象访问。<br><img src="4.png" alt="直接指针"></li>
</ol>
<h1 id="四、-实战：OutOfMemoryError异常"><a href="#四、-实战：OutOfMemoryError异常" class="headerlink" title="四、 实战：OutOfMemoryError异常"></a>四、 实战：OutOfMemoryError异常</h1><ol>
<li>通过实战可验证运行时数据区域存储的内容。</li>
<li>当遇到实际的内存溢出异常时,能根据异常的提示信息迅速得知是哪个区域的内存溢出,溢出的原因以及相应的处理方法。</li>
</ol>
<h2 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1. Java堆溢出"></a>1. Java堆溢出</h2><h3 id="1-1-溢出原因"><a href="#1-1-溢出原因" class="headerlink" title="1.1 溢出原因"></a>1.1 溢出原因</h3><ol>
<li><p>IDEA中设置虚拟机参数:<br>run-&gt;Edit Configurations-&gt;VM options: <code>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</code>；</p>
<blockquote>
<p>限制Java堆的大小为20MB,不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数 设置为一样即可避免堆自动扩展);<br>通过参数<code>-XX：+HeapDumpOnOutOfMemoryError</code>可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析。</p>
</blockquote>
</li>
<li><p>不断创建对象并避免垃圾收集机制清除这些对象，当触及设定的最大堆容量限制后就会产生内存溢出异常。</p>
</li>
<li><p>控制台错误输出信息：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid13516.hprof ...</span><br><span class="line">Heap dump file created [28164792 bytes in 0.104 secs]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="1-2-分析和解决的方法"><a href="#1-2-分析和解决的方法" class="headerlink" title="1.2 分析和解决的方法"></a>1.2 分析和解决的方法</h3><ol>
<li>使用内存映像分析工具（IDEA可以使用插件viaualvm分析）对Dump出来的堆转储快照进行分析，查看是出现了内存泄漏还是内存溢出。</li>
<li>若为内存泄漏，则利用工具根据泄漏对象的类型信息以及它到GC Roots引用链的信息比较准确地定位到这些对象创建的位置,进而找出产生内存泄漏的代码的具体位置。</li>
<li>若为内存溢出(比如申请了一个integer,但给它存了long才能存下的数)，则应适当调整Java虚拟机的堆参数大小，然后检查代码中是否存在某些对象生命周期过长,持有状态时间过长,存储结构设计不合理等情况。</li>
</ol>
<h2 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2 虚拟机栈和本地方法栈溢出"></a>2 虚拟机栈和本地方法栈溢出</h2><ol>
<li>使用<code>-Xss128K</code>参数减少栈内存容量或定义大量的本地变量,增大此方法帧中本地变量表的长度.</li>
<li>无论是由于栈帧太大还是虚拟机栈容量太小,当新的栈帧内存无法分配的时候, HotSpot虚拟机抛出的都是StackOverflowError异常，因为HotSpot是不允许动态扩展栈容量大小的虚拟机。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stackLength++;</span><br><span class="line">    stackLeak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3. 方法区和运行时常量池溢出"></a>3. 方法区和运行时常量池溢出</h2><h3 id="3-1-运行时常量池溢出"><a href="#3-1-运行时常量池溢出" class="headerlink" title="3.1 运行时常量池溢出"></a>3.1 运行时常量池溢出</h3><ol>
<li>设置参数<code>-XX:PermSize=6M -XX:MaxPermSize=6M</code>来限制永久代的大小以间接限制其中常量池的容量。</li>
<li>在jdk6中String.intern()方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储,返回的也是永久代里面这个字符串实例的引用</li>
<li>在jdk7中原本存放在永久代的字符串常量池被移至Java堆之中，故intern()方法只需要在常量池里记录一下<strong>首次出现</strong>的实例引用即可。</li>
<li><font color=Crmison>注意！字符串”java”在加载sun.misc.Version这个类的时候就进入常量池的,因此不属于第一次出现。</font></li>
<li>在JDK8以后,永久代便完全退出了历史舞台,元空间作为其替代者登场。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line"><span class="comment">//jdk6中会产生溢出，jdk7中不会溢出</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">    <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        set.add(String.valueOf(i++).intern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String.intern()返回引用的测试</span></span><br><span class="line"><span class="comment">//在jdk6中将返回2个flase，而在jdk7及以上则得到一个true和一个flase</span></span><br><span class="line">String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">System.out.println(str2.intern() == str2);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-2-方法区溢出"><a href="#3-2-方法区溢出" class="headerlink" title="3.2 方法区溢出"></a>3.2 方法区溢出</h3><ol>
<li>若在运行时产生的大量的类填满了方法区，方法区就会产生溢出，当前流行的很多主流框架如Spring，Hibernate在对类进行增强时(用到了CGLib这类字节码技术)就很容易溢出。</li>
<li>很多运行于Java虚拟机上的动态语言(例如Groovy等)通常都会持续创建新类型来支撑语言的动态性, 因此也容易出现方法区溢出场景。     </li>
<li>大量JSP或动态产生JSP文件的应用(JSP第一次运行时需要编译为Java类),基于OSGi的应用(即使是同一个类文件,被不同的加载器加载也会视为不同的类)等也容易产生方法区的溢出。</li>
</ol>
<p><strong>设置虚拟机参数的解决方法：</strong></p>
<ol>
<li><code>-XX: MaxMetaspaceSize:</code> 设置元空间最大值,默认是-1,即不限制,或者说只受限于本地内存大小;</li>
<li><code>-XX: MetaspaceSize:</code> 指定元空间的初始空间大小,以字节为单位,达到该值就会触发垃圾收集进行类型卸载,同时垃圾收集器会对根据垃圾收集情况对该值进行自适应调整；</li>
<li><code>-XX: MinMetaspaceFreeRatio:</code> 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比,可减少因为元空间不足导致的垃圾收集的频率。</li>
<li><code>-XX: Max-MetaspaceFreeRatio:</code> 用于控制最 大的元空间剩余容量的百分比。</li>
</ol>
<h2 id="4-本机直接内存溢出"><a href="#4-本机直接内存溢出" class="headerlink" title="4. 本机直接内存溢出"></a>4. 本机直接内存溢出</h2><ol>
<li>由直接内存导致的内存溢出,一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况,如果读者发现内存溢出之后产生的Dump文件很小,而程序中又直接或间接使用了 DirectMemory(典型的间接使用就是NIO类)。</li>
<li>使用DirectByteBuffer分配内存也会抛出内存溢出异常,但它抛出异常时并没有真正向操作系统申请分配内存,而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常,真正申请分配内存的方法是Unsafe::allocateMemory()。</li>
<li>直接内存(Direct Memory)的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定,如果不去指定,则默认与Java堆最大值(由-Xmx指定)一致。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    unsafe.allocateMemory(_1MB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM自动内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/2020/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<ol>
<li><p>当我们需要排查各种内存溢出,内存泄漏问题时,当垃圾收集成为系统达到更高并发量的瓶颈时,我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
</li>
<li><p>在Java内存运行时区域中的程序计数器,虚拟机栈,本地方法栈这3个区域随线程而生,随线程而灭，所需的内存大体在编译期即可知，因此这几个区域的<strong>内存分配和回收都具备确定性</strong>。</p>
</li>
<li><p>而Java堆和方法区这两个区域则有着很显著的不确定性,只有处于运行期间,我们才能知道程序究竟会创建哪些对象,创建多少个对象,这部分<strong>内存的分配和回收是动态的</strong>。</p>
</li>
<li><p>垃圾收集器关注的正是Java堆和方法区这2部分的内存该如何管理。</p>
</li>
</ol>
<h1 id="一、判定对象是否存活"><a href="#一、判定对象是否存活" class="headerlink" title="一、判定对象是否存活"></a>一、判定对象是否存活</h1><h2 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h2><ol>
<li><p>引用计数算法即在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一；当引用失效时,计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的.</p>
</li>
<li><p>微软COM技术,使用ActionScript 3的FlashPlayer,Python语言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法进行内存管理，但是主流的Java虚拟机里面都没有选用引用计数算法来管<br>理内存。</p>
</li>
<li><p>引用计数算法有时需要配合大量额外处理才能解决很多例外情况，例如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br></pre></td></tr></table></figure>

<h2 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h2><ol>
<li><p>当前主流的商用程序语言(Java,C#,Lisp)的内存管理子系统,都是通过可达性分析算法来判定对象是否存活的.</p>
</li>
<li><p>可达性分析算法通过一系列称为“GC Roots”的根对象作为起始节点集,从这些节点开始,根据引用关系向下搜索对象，若某个对象到GC Roots之间不存在<strong>引用链</strong>即不可达时，判定此对象已死亡，即可被回收的对象。</p>
</li>
<li><p>可作为GC Roots的对象包括以下几种:</p>
</li>
</ol>
<blockquote>
<p>在虚拟机栈(栈帧中的本地变量表)中引用的对象；<br>在方法区中类静态属性引用的对象；<br>在方法区中常量引用的对象;<br>在本地方法栈中JNI(即通常所说的Native方法)引用的对象;<br>Java虚拟机内部的引用,如基本数据类型对应的Class对象,一些常驻的异常对象(比如 NullPointExcepiton,OutOfMemoryError)等,还有系统类加载器;<br>所有被同步锁(synchronized关键字)持有的对象;<br>反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调,本地代码缓存等.<br>此外还可以有其他对象“临时性”地加入,共同构成完整GC Roots集合。<br><img src="1.png" alt="可达性分析"></p>
</blockquote>
<h2 id="3-引用的类型"><a href="#3-引用的类型" class="headerlink" title="3. 引用的类型"></a>3. 引用的类型</h2><ol>
<li><p><strong>强引用：</strong>指在程序代码之中普遍存在的引用赋值,如<code>Object obj=new Object()</code>，任何情况下,只要强引用关系还存在,垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
<li><p><strong>软引用：</strong>指一些还有用,但非必须的对象,JDK 1.2版之后提供了<code>SoftReference</code>类来实现软引用,只被软引用关联着的对象,<strong>在系统将要发生内存溢出异常前</strong>,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还没有足够的内存, 才会抛出内存溢出异常。</p>
</li>
<li><p><strong>弱引用：</strong>也指非必须的对象，但强度比软引用更弱，在JDK 1.2版之后提供了<code>WeakReference</code>类来实现弱引用,被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生为止</strong>，当垃圾收集器开始工作,无论当前内存是否足够,都会回收掉只被弱引用关联的对象。</p>
</li>
<li><p><strong>虚引用：</strong>也称为“幽灵引用”或者“幻影引用”,它是最弱的一种引用关系,在JDK 1.2版之后提供了<code>PhantomReference</code>类来实现虚引用,为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知,它不会对该对象的生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>
</li>
</ol>
<h2 id="4-对象的自我拯救（finalize方法）"><a href="#4-对象的自我拯救（finalize方法）" class="headerlink" title="4. 对象的自我拯救（finalize方法）"></a>4. 对象的自我拯救（finalize方法）</h2><ol>
<li><p>要真正宣告一个对象死亡,至少要经历<strong>两次标记</strong>过程：</p>
<ul>
<li><strong>一次标记</strong>：当对象在进行可达性分析后发现没有与GC Roots相连接的引用链则进行一次标记。</li>
<li><strong>一次筛选</strong>：筛选对象是否有必要执行finalize()方法，假如对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过(虚拟机只会执行一次该方法),那么虚拟机将这两种情况都视为“没有必要执行”。  </li>
</ul>
</li>
<li><p>如果这个对象被判定为确有必要执行finalize()方法,那么该对象将会被放置在一个名为F-Queue的队列之中,并在稍后由一条由虚拟机自动建立的,低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>
</li>
<li><p>虚拟机在执行finalize()方法时并不承诺一定等待它运行结束，finalize()方法是对象逃脱死亡命运的最后一次机会如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己 (this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移出“即将回收”的集 合；如果对象这时候还没有逃脱,那基本上它就真的要被回收了。</p>
</li>
<li><p>finalize()方法只是Java刚诞生时为了使传统C,C++程序员更容易接受Java所做出的一 项妥协，它的运行代价高昂,不确定性大,无法保证各个对象的调用顺序,如今已被官方明确声明为不推荐使用的语法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">    System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">    FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象第二次拯救自己失败，因为finalize已经执行过一次，故第二次将直接回收该对象</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>

<h2 id="5-回收方法区"><a href="#5-回收方法区" class="headerlink" title="5. 回收方法区"></a>5. 回收方法区</h2><ol>
<li><p>方法区回收囿于苛刻的判定条件,其区域垃圾收集的回收成果往往远低于其它区域。</p>
</li>
<li><p>方法区主要回收废弃的常量和不再使用的类型：</p>
<ul>
<li><p>若已经没有任何字符串对象引用常量池中的某个常量，且虚拟机中也没有其他地方引用这个字面量,如果在这时发生内存回收,而且垃圾收集器判断确有必要的话,这个常量就将会被系统清理出常量池.常量池中其他类(接口),方法,字段的符号引用也与此类似。</p>
</li>
<li><p>判定一个类型是否属于“不再被使用的类”需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收,也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收,这个条件除非是经过精心设计的可替换类加载器的场景,如 OSGi,JSP的重加载等,否则通常是很难达成的。 </li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li><p>满足条件后只是被允许回收，关于是否要对类型进行回收：</p>
<ul>
<li>HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制;</li>
<li>Product版的虚拟机提供了<code>-verbose:class</code> 以及 <code>-XX: +TraceClass-Loading</code>;</li>
<li>FastDebug版的虚拟机提供了<code>-XX: +TraceClassUnLoading</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>在大量使用反射,动态代理,CGLib等字节码框架,动态生成JSP以及OSGi这类频繁自定义类加载器的场景中,通常都需要Java虚拟机具备<strong>类型卸载</strong>的能力,以保证不会对方法区造成过大的内存压力。</p>
</li>
</ol>
<h1 id="二、垃圾收集算法"><a href="#二、垃圾收集算法" class="headerlink" title="二、垃圾收集算法"></a>二、垃圾收集算法</h1><p>从如何判定对象消亡的角度出发,垃圾收集算法可以划分为“引用计数式垃圾收集(直接垃圾收集)”和“追踪式垃圾收集(间接垃圾收集)”两大类,主流Java虚拟机中大都采用<strong>追踪式垃圾收集</strong>。</p>
<h2 id="1-分代收集理论"><a href="#1-分代收集理论" class="headerlink" title="1. 分代收集理论"></a>1. 分代收集理论</h2><h3 id="1-1-分代收集理论的三条经验法则"><a href="#1-1-分代收集理论的三条经验法则" class="headerlink" title="1.1 分代收集理论的三条经验法则"></a>1.1 分代收集理论的三条经验法则</h3><ol>
<li><p><strong>弱分代假说：</strong>绝大多数对象都是朝生夕灭的；</p>
</li>
<li><p><strong>强分代假说：</strong>熬过越多次垃圾收集过程的对象就越难以消亡；</p>
</li>
<li><p><strong>跨代引用假说：</strong>跨代引用相对于同代引用来说仅占极少数。</p>
</li>
</ol>
<h3 id="1-3-Java堆的年代划分"><a href="#1-3-Java堆的年代划分" class="headerlink" title="1.3 Java堆的年代划分"></a>1.3 Java堆的年代划分</h3><ol>
<li><p>现在的商用Java虚拟机里一般至少会把Java堆划分为新生代和老年代两个区域。在<strong>新生代</strong>中,每次垃圾收集时都发现有大批对象死去,而每次回收后存活的少量对象,将会逐步晋升到<strong>老年代</strong>中存放。</p>
</li>
<li><p>HotSpot的“分代式垃圾收集器框架”包括一些名为“Generation”的实现，如<code>DefNewGeneration</code>和<code>ParNewGeneration</code>等。 </p>
</li>
<li><p>由于在新生代能以较低代价回收到大量的空间，而可以使用较低的频率来回收老年代这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
</li>
<li><p>由于对象之间会存在<strong>少量</strong>跨代引用，而新生代中的跨代引用不能被回收，因此需要在新生代上建立一个全局的数据结构(<strong>记忆集</strong>)把老年代划分成若干小块,并标识哪一块内存会存在跨代引用，此后当发生Minor GC时,只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
</li>
</ol>
<h3 id="1-2-回收类型的划分"><a href="#1-2-回收类型的划分" class="headerlink" title="1.2 回收类型的划分"></a>1.2 回收类型的划分</h3><p>根据分代收集理论的三条经验法以及Java堆的分代划分可以将回收类型进行如下划分：</p>
<ol>
<li><p><strong>部分收集(Partial GC)：</strong>指目标不是完整收集整个Java堆的垃圾收集，又分为：</p>
<ul>
<li><strong>新生代收集（Minor GC/Young GC）：</strong>指目标只是新生代的垃圾收集。</li>
<li><strong>老年代收集（Major GC/Old GC）:</strong>指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为，且Major GC需要按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li><strong>混合收集（Mixed GC）:</strong>指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li><p><strong>整堆收集（Full GC）:</strong>收集整个Java堆和方法区的垃圾收集。</p>
</li>
</ol>
<h2 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. 标记-清除算法</h2><ol>
<li><p>标记-清除算法分两个阶段：</p>
<ul>
<li><strong>标记：</strong>标记过程就是对象是否属于垃圾的判定过程。</li>
<li><strong>清除：</strong>统一回收掉被标记的对象。<br>可以首先标记出所有需要回收的对象然后清除，也可以反过来首先标记存活的对象，清除所有未被标记的对象。</li>
</ul>
</li>
<li><p>标记-清除算法是最基础的收集算法，后续的收集算法大多都是以标记-清除算法为基础,对其缺点进行改进而得到的。</p>
</li>
<li><p>主要缺点：</p>
<ul>
<li>执行效率不稳定，标记和清除的执行效率随着回收对象数量的增长而降低；</li>
<li>内存空间碎片化，标记清除后产生的大量不连续内存碎片可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</li>
</ol>
<p><img src="2.png" alt="标记清除"></p>
<h2 id="3-标记-复制算法（回收新生代）"><a href="#3-标记-复制算法（回收新生代）" class="headerlink" title="3. 标记-复制算法（回收新生代）"></a>3. 标记-复制算法（回收新生代）</h2><p>解决了标记-清除算法执行效率低的问题。</p>
<ol>
<li><strong>半区复制算法：</strong>将可用内存按容量划分为<strong>大小相等</strong>的两块,每次只使用其中的一块，当这一块的内存用完了,就将还存活着的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉。<ul>
<li>对于多数对象都是存活的情况，将产生大量内存复制开销；</li>
<li>将可用内存缩小为了原来的一半，空间浪费较大。而IBM公司研究表明新生代中的对象有98%熬不过第一轮收集。</li>
</ul>
</li>
</ol>
<p><img src="3.png" alt="半区复制"></p>
<ol start="2">
<li><strong>Appel式回收（优化的半区复制算法）：</strong>把新生代分为一块较大的Eden空间和两块较小的Survivor空间,每次分配内存只使用Eden和其中一块Survivor，发生垃圾搜集时,将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上,然后直接清理掉Eden和已用过的那块Survivor空间。<ul>
<li>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，可用空间为Eden80%加上一个Survivor10%，复制空间为另一个10%的Survivor空间。</li>
<li>没有办法百分百保证每次回收都只有不多于10%的对象存活，当Survivor空间不足以容纳一次Minor GC之后存活的对象时,就需要依赖其他内存区域(实际上大多就是老年代)进行分配担保。</li>
</ul>
</li>
</ol>
<h2 id="4-标记-整理算法（回收老年代）"><a href="#4-标记-整理算法（回收老年代）" class="headerlink" title="4. 标记-整理算法（回收老年代）"></a>4. <strong>标记-整理算法</strong>（回收老年代）</h2><ol>
<li><p>其中的标记过程仍然与“标记-清除”算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向内存空间一端移动,然后直接清理掉边界以外的内存。</p>
</li>
<li><p>优缺点：</p>
<ul>
<li>在老年代这种每次回收都有大量对象存活区域,移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作,而且这种对象移动操作必须全程暂停用户应用程序才能进行，被称为<strong>Stop The World</strong>。</li>
<li>对象移动则内存回收时会更复杂,不移动则内存分配时会更复杂。</li>
<li>因内存分配和访问相比垃圾收集频率要高得多，故从整个程序的吞吐量来看移动对象会更划算。</li>
</ul>
</li>
<li><p>HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的,而关注延迟的CMS收集器则基于标记-清除算法。</p>
</li>
<li><p>“和稀泥式”解决方案：让虚拟机平时多数时间都采用标记-清除算法,暂时容忍内存碎片的存在,直到内存空间的碎片化程度已经大到影响对象分配时,再采用标记-整理算法收集一次,以获得规整的内存空间，例如CMS收集器。</p>
</li>
</ol>
<h1 id="三、HotSpot的算法细节实现"><a href="#三、HotSpot的算法细节实现" class="headerlink" title="三、HotSpot的算法细节实现"></a>三、HotSpot的算法细节实现</h1><h2 id="1-根节点枚举"><a href="#1-根节点枚举" class="headerlink" title="1. 根节点枚举"></a>1. 根节点枚举</h2><ol>
<li><p>迄今为止,所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的,它会面临相似的“Stop The World”的困扰，这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因。</p>
</li>
<li><p>目前主流的Java虚拟机使用的都是<strong>准确式垃圾收集</strong>,即利用某些数据结构清楚记录哪些地方存放着对象引用，所以当用户线程停顿下来之后,并不需要一个不漏地检查完所有执行上下文和全局的引用位置,虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</p>
</li>
<li><p>HotSpot使用OopMap数据结构在类加载完成时就会在<strong>特定的位置</strong>记录下栈里和寄存器里哪些位置是引用，这样收集器在扫描时就可以直接得知这些信息了,并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>
</li>
</ol>
<h2 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2. 安全点"></a>2. 安全点</h2><ol>
<li><p>HotSpot没有为每条指令都生成OopMap,只是在“特定的位置”记录栈里和寄存器里哪些位置是引用,这些位置被称为安全点(Safepoint)。</p>
</li>
<li><p>用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集,而是强制要求必须执行到达<strong>安全点</strong>后才能够暂停。</p>
</li>
<li><p>安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的,如方法调用,循环跳转,异常跳转等这些指令序列复用。</p>
</li>
<li><p>虚拟机暂停线程响应GC事件的方法：</p>
</li>
</ol>
<ul>
<li>抢先式中断：无需线程的执行代码主动去配合,在GC发生时,系统首先把所有用户线程全部中断,如果发现有用户线程中断的地方不在安全点上,就恢复这条线程执行,让它一会再重新中断,直到跑到安全点上，现在几乎没有虚拟机实现采用此方式。</li>
<li>主动式中断: 当GC需要中断线程的时候,不直接对线程操作,仅仅简单地设置一个标志位(与安全点重合，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方),各个线程执行过程时会不停地主动去轮询这个标志,一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</li>
</ul>
<ol start="5">
<li>HotSpot使用<strong>内存保护陷阱</strong>的方式, 把轮询操作精简至只有一条汇编指令的程度，使其足够高效。</li>
</ol>
<h2 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3. 安全区域"></a>3. 安全区域</h2><ol>
<li><p>安全区域是指能够确保在某一段代码片段之中,引用关系不会发生变化,因此,在这个区域中任意地方开始垃圾收集都是安全的，我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
</li>
<li><p>当用户线程执行到安全区域里面的代码时,首先会标识自己已经进入了安全区域,那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了,当线程要离开安全区域时,它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段),如果完成了,那线程就当作没事发生过,继续执行；否则它就必须一直等待,直到收到可以离开安全区域的信号为止.</p>
</li>
</ol>
<h2 id="4-记忆集与卡表"><a href="#4-记忆集与卡表" class="headerlink" title="4. 记忆集与卡表"></a>4. 记忆集与卡表</h2><ol>
<li>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构,考虑效率和成本，有三种实现方式：</li>
</ol>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长，该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象,该对象里有字段含有跨代指针。</li>
<li><strong>卡精度（卡表）</strong>：最常用，每个记录精确到一块内存区域,该区域内有对象含有跨代指针。</li>
</ul>
<ol start="2">
<li>卡表最简单的形式可以只是一个字节数组，例<code>CARD_TABLE[this address &gt;&gt; 9] = 0;</code>,HotSpot虚拟机即采用这种方式。</li>
</ol>
<ul>
<li>字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块,这个内存块被称作<strong>卡页</strong>(Card Page)。</li>
<li>一般来说,卡页大小都是以2的N次幂的字节数,HotSpot中使用的卡页是2的9次幂,即512字节(地址右移9位,相当于用地址除以512)。</li>
<li>一个卡页的内存中通常包含不止一个对象,只要卡页内有一个(或更多)对象的字段存在着跨代指针,那就将对应卡表的数组元素的值标识为1,称为这个元素<strong>变脏</strong>(Dirty),没有则标识为0。</li>
<li>在垃圾收集发生时,只要筛选出卡表中变脏的元素,就能轻易得出哪些卡页内存块中包含跨代指针,把它们加入GC Roots中一并扫描。<br><img src="5.png" alt="卡表卡页"></li>
</ul>
<h2 id="5-写屏障"><a href="#5-写屏障" class="headerlink" title="5. 写屏障"></a>5. 写屏障</h2><ol>
<li><p>在HotSpot虚拟机里是通过<strong>写屏障</strong>(Write Barrier)技术维护卡表状态的。</p>
</li>
<li><p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面,在引用对象赋值时会产生一个环形(Around)通知,供程序执行额外的动作,也就是说赋值前后都在写屏障的覆盖范畴内.在赋值前的部分的写屏障叫作<strong>写前屏障</strong>(Pre-Write Barrier),在赋值后的则叫作<strong>写后屏障</strong>(Post-Write Barrier)，至G1收集器出现之前,其他收集器都只用到了写后屏障。</p>
</li>
<li><p>应用写屏障后,虚拟机就会为<strong>所有赋值操作</strong>生成相应的指令,一旦收集器在写屏障中增加了更新卡表操作,无论更新的是不是老年代对新生代对象的引用,每次只要对引用进行更新,就会产生额外的开销,不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</p>
</li>
<li><p><strong>伪共享：</strong>现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的,当多线程修改互相独立的变量时,如果这些变量恰好共享同一个缓存行,就会彼此影响(写回,无效化或者同步)而导致性能降低,这就是伪共享问题。为了避免伪共享问题,一种简单的解决方案是不采用无条件的写屏障,而是先检查卡表标记,只有当该卡表元素未被标记过时才将其标记为变脏。</p>
</li>
<li><p>在JDK 7之后,HotSpot虚拟机增加了一个新的参数<code>-XX：+UseCondCardMark</code>,用来决定是否开启卡表更新的条件判断,开启会增加一次额外判断的开销。</p>
</li>
</ol>
<h2 id="6-并发的可达性分析"><a href="#6-并发的可达性分析" class="headerlink" title="6. 并发的可达性分析"></a>6. 并发的可达性分析</h2><ol>
<li><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析, 这意味着必须全程冻结用户线程的运行，其中根节点枚举这个步骤在各种优化技巧(如OopMap)的加持下,它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了，而从GC Roots再继续往下遍历对象图标记的过程会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器。</p>
</li>
<li><p>可达性分析需要一致性快照的原因：用户线程与收集器<strong>并发工作</strong>时会修改对象图结构，可能将原本消亡的对象错误标记为存活（非致命），或者把原本存活的对象错误标记为已消亡(<strong>对象消失</strong>，致命)。</p>
</li>
<li><p><strong>三色标记</strong>：把遍历对象图过程中遇到的对象,按照“是否访问过”这个条件进行标记。</p>
</li>
</ol>
<ul>
<li>白色：表示对象尚未被垃圾收集器访问过，显然在可达性分析刚刚开始的阶段,所有的对象都是白色的,若在分析结束的阶段,仍然是白色的对象,即代表不可达. </li>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，代表安全存活对象,如果有其他对象引用指向了黑色对象,无须重新扫描一遍，黑色对象不可能直接(不经过灰色对象)指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过,但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<ol start="4">
<li>产生<strong>对象消失</strong>的问题（原本应该是黑色的对象被误标为白色）必须满足的两个条件：</li>
</ol>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用； </li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<ol start="5">
<li>解决并发扫描时的对象消失问题的两种解决方案：</li>
</ol>
<ul>
<li><strong>增量更新：</strong>破坏的是第一个条件,当黑色对象插入新的指向白色对象的引用关系时,就将这个新插入的引用记录下来,等并发扫描结束之后,再将这些记录过的引用关系中的黑色对象为根,重新扫描一次.这可以简化理解为,黑色对象一旦新插入了指向白色对象的引用之后,它就变回灰色对象了，例CMS。</li>
<li><strong>原始快照SATB:</strong>破坏的是第二个条件,当灰色对象要删除指向白色对象的引用关系时,就将这个要删除的引用记录下来,在并发扫描结束之后,再将这些记录过的引用关系中的灰色对象为根,重新扫描一次，这也可以简化理解为,无论引用关系删除与否,都会按照刚刚开始扫描那一刻的对象图快照来进行搜索，例G1,Shenandoah。<br><img src="6.png" alt="三色标记"></li>
</ul>
<h1 id="四、经典的垃圾收集器"><a href="#四、经典的垃圾收集器" class="headerlink" title="四、经典的垃圾收集器"></a>四、经典的垃圾收集器</h1><p>这里的经典垃圾收集器是指JDK 7 Update 4 之后(在这个版本中正式提供了商用的G1收集器,此前G1仍处于实验状态),JDK 11正式发布之前,OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。<br><img src="7.png" alt="三色标记"><br>如果两个收集器之间存在连线,就说明它们可以搭配使用。</p>
<h2 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h2><ol>
<li><p>Serial收集器是单线程的，并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作,更重要的是强调在它进行垃圾收集时,必须暂停其他所有工作线程,直到它收集结束。</p>
</li>
<li><p>优点：简单而高效(与其他收集器的单线程相比),对于内存资源受限的环境,它是所有收集器里额外内存消耗(Memory Footprint)最小的；对于单核处理器或处理器核心数较少的环境来说,Serial收集器由于没有线程交互的开销,专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
</li>
<li><p>Serial收集器对于运行在<strong>客户端模式</strong>下的虚拟机来说是一个很好的选择。</p>
</li>
</ol>
<p>Serial/Serial Old收集器:<br><img src="8.png" alt="Serial"></p>
<h2 id="2-ParNew收集器（新生代收集器）"><a href="#2-ParNew收集器（新生代收集器）" class="headerlink" title="2. ParNew收集器（新生代收集器）"></a>2. ParNew收集器（新生代收集器）</h2><ol>
<li><p>ParNew收集器实质上是Serial收集器的多线程并行版本,除了同时使用多条线程进行垃圾收集之外,其余的行为与Serial收集器完全一致，甚至在实现上共用了相当多的代码。</p>
</li>
<li><p>是不少运行在<strong>服务端模式</strong>下的HotSpot虚拟机,JDK7之前首选的新生代收集器，且除了Serial收集器外,目前只有它能与CMS 收集器配合工作。</p>
</li>
<li><p>JDK9开始直接取消了- XX：+UseParNewGC参数,这意味着ParNew和CMS从此只能互相搭配使用,再也没有其他收集器能够和它们配合了，即从此以后,ParNew合并入CMS,成为它专门处理新生代的组成部分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。</p>
</li>
<li><p>并行与并发的含义：</p>
</li>
</ol>
<ul>
<li><strong>并行：</strong>并行描述的是多条垃圾收集器线程之间的关系,说明同一时间有多条这样的线程在协同工作,通常默认此时用户线程是处于等待状态。</li>
<li><strong>并发：</strong>并发描述的是垃圾收集器线程与用户线程之间的关系,说明同一时间垃圾收集器线程与用户线程都在运行.由于用户线程并未被冻结,所以程序仍然能响应服务请求,但由于垃圾收集器线程占用了一部分系统资源,此时应用程序的处理的吞吐量将受到一定影响。</li>
</ul>
<p>ParNew 收集器：<br><img src="9.png" alt="ParNew"></p>
<h2 id="3-Parallel-Scavenge收集器-新生代收集器"><a href="#3-Parallel-Scavenge收集器-新生代收集器" class="headerlink" title="3. Parallel Scavenge收集器(新生代收集器)"></a>3. Parallel Scavenge收集器(新生代收集器)</h2><ol>
<li><p>Parallel Scavenge收集器是基于<strong>标记-复制算法</strong>实现的收集器,也是能够并行收集的多线程收集器，它的关注点与其他收集器不同，目标是达到一个可控制的<strong>吞吐量</strong>(Throughput)，即吞吐量优先收集器。<br><img src="10.png" alt="吞吐量"></p>
</li>
<li><p>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序,良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源,尽快完成程序的运算任务,主要适合在后台运算而不需要太多交互的分析任务.</p>
</li>
<li><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量：</p>
</li>
</ol>
<ul>
<li><code>-XX：Max GCPause Millis</code>: 控制最大垃圾收集停顿时间，是一个大于0的毫秒数；垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。</li>
<li><code>-XX：GCTimeRatio</code>: 直接设置吞吐量大小；是一个大于0小于100的整数，即应用程序总执行时间所占比例。</li>
</ul>
<ol start="4">
<li>Parallel Scavenge收集器的自适应调节策略：<code>-XX：+UseAdaptiveSizePolicy</code>:这是一个开关参数,当这个参数被激活之后,就不需要人工指定新生代的大小<code>-Xmn</code>,Eden与Survivor区的比例<code>-XX：SurvivorRatio</code>,晋升老年代对象大小<code>-XX：PretenureSizeThreshold</code>等细节参数了,虚拟机会根据当前系统的运行情况收集性能监控信息,动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</li>
</ol>
<h2 id="4-Serial-Old收集器-老年代收集器"><a href="#4-Serial-Old收集器-老年代收集器" class="headerlink" title="4. Serial Old收集器(老年代收集器)"></a>4. Serial Old收集器(老年代收集器)</h2><ol>
<li><p>Serial Old是Serial收集器的老年代版本,是一个单线程收集器,使用<strong>标记-整理算法</strong>。</p>
</li>
<li><p>主要供客户端模式下的HotSpot虚拟机使用,在服务端模式下可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用,另外一种就是作为CMS收集器发生失败时的后备预案,在并发收集发生Concurrent Mode Failure时使用。</p>
</li>
<li><p>Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集,并非 直接调用Serial Old收集器,但是这个PS MarkSweep收集器与Serial Old的实现几乎是一样的，所以可替代。</p>
</li>
</ol>
<h2 id="5-Parallel-Old收集器（老年代收集器）"><a href="#5-Parallel-Old收集器（老年代收集器）" class="headerlink" title="5. Parallel Old收集器（老年代收集器）"></a>5. Parallel Old收集器（老年代收集器）</h2><ol>
<li><p>Parallel Old是Parallel Scavenge收集器的老年代版本,支持多线程并发收集,基于<strong>标记-整理算法</strong>实现。</p>
</li>
<li><p>直到JDK6Parallel Old收集器出现后,“吞吐量优先”收集器终于有了比较名副其实的搭配组合,在注重吞吐量或者处理器资源较为稀缺的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
</li>
</ol>
<p>Parallel Scavenge/Parallel Old收集器：<br><img src="11.png" alt="Parallel Scavenge/Parallel Old"></p>
<h2 id="6-CMS收集器（老年代收集器）"><a href="#6-CMS收集器（老年代收集器）" class="headerlink" title="6. CMS收集器（老年代收集器）"></a>6. CMS收集器（老年代收集器）</h2><ol>
<li><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，适用于较为关注服务的响应速度,希望系统<strong>停顿时间</strong>尽可能短,以给用户带来良好的交互体验的应用。</p>
</li>
<li><p>CMS基于<strong>标记-清除算法</strong>，从总体上来说,内存回收过程是与用户线程一起并发执行的，包括四个步骤：</p>
</li>
</ol>
<ul>
<li><p>初始标记(CMS initial mark)：需要Stop The World，仅仅只是标记一下GC Roots能直接关联到的对象,速度很快；</p>
</li>
<li><p>并发标记(CMS concurrent mark):是从GC Roots的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长但是不需要停顿用户线程,可以与垃圾收集线程一起并发运行；CMS采用<strong>增量更新算法</strong>保证再并发运行时不打破原本的对象图结构。CMS的卡表只有唯一一份,而且只需要处理老年代到新生代的引用.</p>
</li>
<li><p>重新标记(CMS remark)：需要Stop The World，是为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些,但也远比并发标记阶段的时间短；</p>
</li>
<li><p>并发清除(CMS concurrent sweep)：清理删除掉标记阶段判断的已经死亡的对象,由于不需要移动存活对象,所以这个阶段也是可以与用户线程同时并发的。</p>
</li>
</ul>
<p><img src="12.png" alt="CMS"></p>
<ol start="3">
<li>CMS收集器的缺点：</li>
</ol>
<ul>
<li><p>CMS收集器对处理器资源非常敏感：CMS默认启动的回收线程数是(处理器核心数量 +3)/4,并发回收时垃圾收集线程会随着处理器核心数量的增加而下降,若处理器核心少于4个对用户程序的影响就可能变得很大,就可能导致用户程序的执行速度忽然大幅降低；</p>
</li>
<li><p>由于CMS收集器无法处理<strong>浮动垃圾</strong>(Floating Garbage，由于并发垃圾收集过程中正在运行用户程序产生的新垃圾是在标记过程后，无法当次收集),有可能出现“Con-current Mode Failure”失败（即老年代被填满后无法供并发收集时的程序运作使用）进而导致另一次完全“Stop The World”的Full GC的产生，可利用参数<code>-XX：CMS Initiating Occu-pancy Fraction</code>适当设置老年代占用多少百分比的空间后触发CMS垃圾收集过程。</p>
</li>
<li><p>CMS基于标记-清除算法会产生大量空间碎片，若无法找到足够大的连续空间来分配当前对象,就不得不提前触发一次Full GC。</p>
</li>
</ul>
<h2 id="7-Garbage-First收集器（混合收集器）"><a href="#7-Garbage-First收集器（混合收集器）" class="headerlink" title="7. Garbage First收集器（混合收集器）"></a>7. Garbage First收集器（混合收集器）</h2><ol>
<li><p>G1是一款主要面向<strong>服务端应用</strong>的垃圾收集器，是CMS收集器的替代者和继承人，G1收集器可以面向堆内存任何部分来组成回收集(Collection Set,一般简称CSet)进行回收,衡量标准不再是它属于哪个分代,而 是哪块内存中存放的垃圾数量最多,回收收益最大,这就是G1收集器的Mixed GC模式。</p>
</li>
<li><p>G1开创的<strong>基于Region的堆内存布局</strong>是它能够实现<strong>停顿时间模型</strong>目标（能够支持指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标）的关键：</p>
</li>
</ol>
<ul>
<li><p>G1不再坚持固定大小以及固定数量的分代区域划分,而是把连续的Java堆划分为多个大小相等的独立区域(Region),每一个Region都可以根据需要,扮演新生代的Eden空间,Survivor空间,或者老年代空间。每个Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设定,取值范围为1MB～32MB,且应为2的N次幂。</p>
</li>
<li><p>收集器能够对扮演不同角色的 Region采用不同的策略去处理,这样无论是新创建的对象还是已经存活了一段时间,熬过多次收集的旧对象都能获取很好的收集效果。</p>
</li>
<li><p>Region中还有一类特殊的Humongous区域,专门用来存储大对象.G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象，而对于那些超过了整个Region容量的超级大对象, 将会被存放在N个连续的Humongous Region之中,G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p>
</li>
</ul>
<ol start="3">
<li>G1将Region作为单次回收的最小单元,即每次收集到的内存空间都是Region大小的整数倍，避免整堆收集，具体思路：</li>
</ol>
<ul>
<li><p>G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小,价值即回收所获得的空间大小以及回收所需时间的经验值。</p>
</li>
<li><p>然后在后台维护一个优先级列表,每次根据用户设定允许的收集停顿时间(使用参数<code>-XX：MaxGCPauseMillis</code>指定,默认值是200毫秒),优先处理回收价值收益最大的那些Region,这也就是“Garbage First”名字的由来.</p>
</li>
<li><p>这种使用Region划分内存空间,以及具有优先级的区域回收方式,保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
</li>
</ul>
<p><img src="13.png" alt="G1"></p>
<ol start="4">
<li>G1收集器需要解决的问题：</li>
</ol>
<ul>
<li><p><strong>跨Region引用对象</strong>的解决方法：在G1收集器上的每个Region都维护有自己的<strong>记忆集</strong>,这些记忆集会记录下别的Region 指向自己的指针,并标记这些指针分别在哪些卡页的范围之内.G1的记忆集一种双向的卡表结构(卡表是“我指向谁”,这种结构还记录了“谁指向我”)，本质上是种哈希表,Key是别的Region的起始地址,Value是一个集合,里面存储的元素是卡表的索引号。复杂性使G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作.</p>
</li>
<li><p><strong>保证收集线程与用户线程互不干扰地运行</strong>：为了不打破原本的对象图结构，G1采用<strong>原始快照算法</strong>实现；为了不影响对象分配，G1为每一个Region设计了两个名为<strong>TAMS</strong>(Top at Mark Start)的指针,把Region中的这两个指针以上的一部分空间划分出来专门用于并发回收过程中的新对象分配,G1收集器默认在 这个地址以上的对象是被隐式标记过的,即默认它们是存活的,不纳入回收范围。但是如果内存回收的速度赶不上内存分配的速度, G1收集器也要被迫冻结用户线程执行,导致Full GC而产生长时间“Stop The World”。</p>
</li>
<li><p><strong>建立可靠的停顿预测模型</strong>:用户通过<code>-XX：MaxGCPauseMillis</code>参数指定垃圾收集的期望停顿时间，然后利用<strong>衰减均值</strong>理论来实现它，衰减平均值更准确地代表“最近的”平均状态，统计状态越新越能决定其回收的价值。G1收集器会记录每个Region的回收耗时,每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本,并分析得出平均值,标准偏差,置信度等统计信息。然后通过这些信息预测现在开始回收的话,由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p>
</li>
</ul>
<ol start="5">
<li>G1的运作过程：</li>
</ol>
<ul>
<li><p><strong>初始标记</strong>：标记GC Roots能直接关联到的对象,修改TAMS 指针的值，需停顿线程，但耗时很短，借用Minor GC同步完成,实际并没有额外的停顿。</p>
</li>
<li><p><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析,递归扫描整个堆里的对象图,找出要回收的对象,这阶段耗时较长,但可与用户程序并发执行.当对象图扫描完成以后,还要重新处理SATB记录下的在并发时有引用变动的对象。</p>
</li>
<li><p><strong>最终标记</strong>： 对用户线程做另一个短暂的暂停,用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录.</p>
</li>
<li><p><strong>筛选回收</strong>：由多条收集器线程并行完成，涉及存活对象移动，必须暂停用户线程.对各个Region的回收价值和成本进行排序,根据用户所期望的停顿时间来制定回收计划,自由选择任意多个Region 构成回收集,然后把决定回收的那一部分Region的存活对象复制到空的Region中,再清理掉整个旧Region的全部空间.</p>
</li>
</ul>
<ol start="6">
<li>G1与CMS优缺点对比：</li>
</ol>
<ul>
<li><p>G1从整体来看是基于“标记-整理”算法实现的收集器,但从局部(两个Region 之间)上看又是基于“标记-复制”算法实现,故不会产生内存碎片。</p>
</li>
<li><p>G1的卡表实现更为复杂。</p>
</li>
<li><p>CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的(由于G1的卡表结构复杂,其实是更烦琐的)卡表维护操作外,为了实现原始快照搜索 (SATB)算法,还需要使用写前屏障来跟踪并发时的指针变化情况,CMS的写屏障实现是直接的同步操作,而G1就不得不将其实现为类似于消息队列的结构,把写前屏障和写后屏障中要做的事情都放到队列里,然后再异步处理。</p>
</li>
<li><p>目前在小内存应用上CMS的表现大概率仍然要会优于G1,而在大内存应用上G1则大多能发挥其优势,这个优劣势的Java堆容量平衡点通常在6GB至8GB之间。</p>
</li>
</ul>
<h2 id="5-低延迟垃圾收集器"><a href="#5-低延迟垃圾收集器" class="headerlink" title="5. 低延迟垃圾收集器"></a>5. 低延迟垃圾收集器</h2><p>1. </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM自动内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL函数查询</title>
    <url>/2020/06/10/MySQL/MySQL%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>YEAR 函数、 NOW 函数、 MAX 函数、 MIN 函数 的使用。</p>
<p><strong>查询汇总</strong></p>
<ol>
<li><p>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</p>
</li>
<li><p>查询 <code>student</code> 表中每个学生的姓名和年龄。</p>
</li>
<li><p>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</p>
</li>
<li><p>查询最高分同学的 <code>score</code> 表。</p>
</li>
</ol>
<h2 id="一、YEAR-函数与带-IN-关键字查询"><a href="#一、YEAR-函数与带-IN-关键字查询" class="headerlink" title="一、YEAR 函数与带 IN 关键字查询"></a>一、YEAR 函数与带 IN 关键字查询</h2><p><strong>1.查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- YEAR(..): 取出日期中的年份</span><br><span class="line">SELECT no, name, birthday FROM student</span><br><span class="line">WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));</span><br></pre></td></tr></table></figure>

<h2 id="二、YEAR-与-NOW-函数"><a href="#二、YEAR-与-NOW-函数" class="headerlink" title="二、YEAR 与 NOW 函数"></a>二、YEAR 与 NOW 函数</h2><p><strong>2.查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。</span><br><span class="line">SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;</span><br><span class="line">+-----------+------+</span><br><span class="line">| name      | age  |</span><br><span class="line">+-----------+------+</span><br><span class="line">| 曾华      |   42 |</span><br><span class="line">| 匡明      |   44 |</span><br><span class="line">| 王丽      |   43 |</span><br><span class="line">| 李军      |   43 |</span><br><span class="line">| 王芳      |   44 |</span><br><span class="line">| 陆军      |   45 |</span><br><span class="line">| 王尼玛    |   43 |</span><br><span class="line">| 张全蛋    |   44 |</span><br><span class="line">| 赵铁柱    |   45 |</span><br><span class="line">| 张飞      |   45 |</span><br><span class="line">+-----------+------+</span><br></pre></td></tr></table></figure>

<h2 id="三、MAX-与-MIN-函数"><a href="#三、MAX-与-MIN-函数" class="headerlink" title="三、MAX 与 MIN 函数"></a>三、MAX 与 MIN 函数</h2><p><strong>3.查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(birthday), MIN(birthday) FROM student;</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| MAX(birthday) | MIN(birthday) |</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| 1977-09-01    | 1974-06-03    |</span><br><span class="line">+---------------+---------------+</span><br></pre></td></tr></table></figure>

<h2 id="四、MAX-函数与子查询"><a href="#四、MAX-函数与子查询" class="headerlink" title="四、MAX 函数与子查询"></a>四、MAX 函数与子查询</h2><p><strong>4.查询最高分同学的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 找出最高成绩（该查询只能有一个结果）</span><br><span class="line">SELECT MAX(degree) FROM score;</span><br><span class="line"></span><br><span class="line">-- 根据上面的条件筛选出所有最高成绩表，</span><br><span class="line">-- 该查询可能有多个结果，假设 degree 值多次符合条件。</span><br><span class="line">SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中控制事务的提交与回滚</title>
    <url>/2020/06/16/MySQL/MySQL%E4%B8%AD%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<h2 id="一、如何控制事务-COMMIT-ROLLBACK"><a href="#一、如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="一、如何控制事务 - COMMIT / ROLLBACK"></a>一、如何控制事务 - COMMIT / ROLLBACK</h2><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询事务的自动提交状态</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">+--------------+</span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+--------------+</span><br><span class="line">|            1 |</span><br><span class="line">+--------------+</span><br><span class="line"></span><br><span class="line">-- 也可以手动set为1</span><br><span class="line">-- set</span><br><span class="line">set autocommit&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p>
<p>什么是回滚？举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE bank;</span><br><span class="line"></span><br><span class="line">USE bank;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    money INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO user VALUES (1, &#39;a&#39;, 1000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p>
<p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 回滚到最后一次提交</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 关闭自动提交</span><br><span class="line">SET AUTOCOMMIT &#x3D; 0;</span><br><span class="line"></span><br><span class="line">-- 查询自动提交状态</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">+--------------+</span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+--------------+</span><br><span class="line">|            0 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p>将自动提交关闭后，测试数据回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);</span><br><span class="line"></span><br><span class="line">-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，</span><br><span class="line">-- 发生变化的数据并没有真正插入到数据表中。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 数据表中的真实数据其实还是：</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 由于数据还没有真正提交，可以使用回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 再次查询</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> (体现了mysql的<strong>持久性</strong>): </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);</span><br><span class="line">-- 手动提交数据（持久性），</span><br><span class="line">-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 提交后测试回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 再次查询（回滚无效了）</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h2><blockquote>
<ol>
<li><p><strong>自动提交</strong></p>
<ul>
<li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p>
</li>
<li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p>
</li>
</ul>
</li>
<li><p><strong>手动提交</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p>
</li>
</ol>
</blockquote>
<h2 id="三、事务的实际应用"><a href="#三、事务的实际应用" class="headerlink" title="三、事务的实际应用"></a>三、事务的实际应用</h2><p>让我们再回到银行转账项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 转账</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">-- 到账</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假设转账发生了意外，需要回滚。</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：使用<code>COMMIT</code> 进行提交。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基本查询方法</title>
    <url>/2020/06/09/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>包括 DISTINCT、IN、BETWEEN…AND、OR、DESC（ASC）、COUNT、ORDER BY、LIMIT 等关键字的使用。</p>
<p><strong>问题汇总</strong></p>
<ol>
<li><p>查询 student 表的所有记录;</p>
</li>
<li><p>查询 student 表中所有记录的 name、sex 和 class 列;</p>
</li>
<li><p>查询 teacher 表中不重复的 department 列，即查询老师所有单位;</p>
</li>
<li><p>查询 score 表中成绩在60-80之间的所有行;</p>
</li>
<li><p>查询 score 表中成绩为 85, 86 或 88 的行;</p>
</li>
<li><p>查询 student 表中 ‘95031’ 班或性别为 ‘女’ 的所有行;</p>
</li>
<li><p>以 class 降序的方式查询 student 表的所有行;</p>
</li>
<li><p>以 c_no 升序、degree 降序查询 score 表的所有行;</p>
</li>
<li><p>查询 “95031” 班的学生人数;</p>
</li>
<li><p>查询 score 表中的最高分的学生学号和课程编号;</p>
</li>
<li><p>排序查询,查询最高分。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1.查询 student 表的所有记录</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 2.查询 student 表中所有记录的 name、sex 和 class 列</span><br><span class="line">SELECT name, sex, class FROM student;</span><br><span class="line"></span><br><span class="line">-- DISTINCT: 去重查询</span><br><span class="line">-- 3.查询 teacher 表中不重复的 department 列，即查询老师所有单位</span><br><span class="line">SELECT DISTINCT department FROM teacher;</span><br><span class="line"></span><br><span class="line">-- 区间查询</span><br><span class="line">-- 4.查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）</span><br><span class="line">-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;</span><br><span class="line">SELECT * FROM score WHERE degree BETWEEN 60 AND 80;</span><br><span class="line">SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80; -- 字符串比较</span><br><span class="line"></span><br><span class="line">-- IN: 查询规定中的多个值，同类型字段值的或者关系查询</span><br><span class="line">-- 5.查询 score 表中成绩为 85, 86 或 88 的行</span><br><span class="line">SELECT * FROM score WHERE degree IN (85, 86, 88);</span><br><span class="line"></span><br><span class="line">-- or: 表示或者关系，不同类型字段的或者关系的查询</span><br><span class="line">-- 6.查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行</span><br><span class="line">SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;</span><br><span class="line"></span><br><span class="line">-- DESC: 降序，从高到低</span><br><span class="line">-- ASC（默认）: 升序，从低到高</span><br><span class="line">-- 7.以 class 降序的方式查询 student 表的所有行</span><br><span class="line">SELECT * FROM student ORDER BY class DESC;</span><br><span class="line">SELECT * FROM student ORDER BY class ASC;</span><br><span class="line"></span><br><span class="line">-- 8.以 c_no 升序、degree 降序查询 score 表的所有行</span><br><span class="line">SELECT * FROM score ORDER BY c_no ASC, degree DESC;</span><br><span class="line"></span><br><span class="line">-- COUNT: 统计</span><br><span class="line">-- 9.查询 &quot;95031&quot; 班的学生人数</span><br><span class="line">SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;</span><br><span class="line"></span><br><span class="line">-- (SELECT MAX(degree) FROM score): 子查询，算出最高分</span><br><span class="line">-- 10.查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。</span><br><span class="line">SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);</span><br><span class="line"></span><br><span class="line">--  11.排序查询,查询最高分，有缺陷，存在同最高分的情况</span><br><span class="line">-- LIMIT r, n: 表示从第r行开始，查询n条数据</span><br><span class="line">SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的事务及其特性</title>
    <url>/2020/06/15/MySQL/MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一、事务简介"><a href="#一、事务简介" class="headerlink" title="一、事务简介"></a>一、事务简介</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p>
<p>比如我们的银行转账：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- a -&gt; -100</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">-- b -&gt; +100</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br></pre></td></tr></table></figure>

<p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p>
<p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p>
<h2 id="二、事务的-ACID-特性"><a href="#二、事务的-ACID-特性" class="headerlink" title="二、事务的 ACID 特性"></a>二、事务的 ACID 特性</h2><p><strong>事务的四大特征：</strong></p>
<ul>
<li><strong>A(Atomicity) 原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>C(Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>I (Isolation)隔离性</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>D(Durability) 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) ，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务的隔离性</title>
    <url>/2020/06/17/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/</url>
    <content><![CDATA[<p><strong>事务的隔离级别</strong></p>
<p><strong>事务的隔离性可分为四种 ( 级别从低到高，性能由高到低 )</strong> ：</p>
<ol>
<li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p>
<p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p>
</li>
<li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p>
<p>只能读取到其他事务<strong>已经提交的数据</strong>。</p>
</li>
<li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p>
<p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p>
</li>
<li><p><strong>SERIALIZABLE ( 串行化 )</strong></p>
<p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p>
</li>
</ol>
<p><strong>查看当前数据库的默认隔离级别：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。</span><br><span class="line">+--------------------------------+</span><br><span class="line"></span><br><span class="line">-- MySQL 5.x</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;</span><br><span class="line">SELECT @@TX_ISOLATION;</span><br></pre></td></tr></table></figure>

<p><strong>修改隔离级别：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">-- 查询系统隔离级别，发现已经被修改。</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-UNCOMMITTED               |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="一、脏读"><a href="#一、脏读" class="headerlink" title="一、脏读"></a>一、脏读</h2><p>即读取未提交数据。</p>
<p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);</span><br><span class="line">INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 开启一个事务操作数据</span><br><span class="line">-- 假设成都的小明在淘宝店买了一双800块钱的鞋子：</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;</span><br><span class="line">UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;</span><br><span class="line"></span><br><span class="line">-- 然后广州淘宝店在另一方的mysql中查询结果，发现钱已到账（脏读）</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 成都的小明所处的事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 此时无论对方是谁，如果再去查询结果就会发现：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>这就是所谓的<strong>脏读</strong>，两个不同的地方都在进行操作，即一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p>
<h2 id="二、不可重复度"><a href="#二、不可重复度" class="headerlink" title="二、不可重复度"></a>二、不可重复度</h2><p>前后多次读取，数据内容不一致。</p>
<p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| READ-COMMITTED                 |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正在操作数据事务（当前事务）</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;</span><br><span class="line">UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;</span><br><span class="line"></span><br><span class="line">-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，</span><br><span class="line">-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 假设此时在远程开启了一个新事务，连接到数据库。</span><br><span class="line">$ mysql -u root -p12345612</span><br><span class="line"></span><br><span class="line">-- 此时远程连接查询到的数据只能是已经提交过的</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br></pre></td></tr></table></figure>

<p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小张在查询数据的时候发现：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 在小张求表的 money 平均值之前，小王做了一个操作：</span><br><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO user VALUES (5, &#39;c&#39;, 100);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 此时表的真实数据是：</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：</span><br><span class="line">SELECT AVG(money) FROM user;</span><br><span class="line">+------------+</span><br><span class="line">| AVG(money) |</span><br><span class="line">+------------+</span><br><span class="line">|  820.0000  |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure>

<p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p>
<h2 id="三、幻读"><a href="#三、幻读" class="headerlink" title="三、幻读"></a>三、幻读</h2><p>前后多次读取，数据总量不一致。</p>
<p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| REPEATABLE-READ                |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小王 - 北京</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p>
<p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p>
<p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'</span></span><br></pre></td></tr></table></figure>

<p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p>
<h2 id="四、串行化"><a href="#四、串行化" class="headerlink" title="四、串行化"></a>四、串行化</h2><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">SELECT @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| SERIALIZABLE                   |</span><br><span class="line">+--------------------------------+</span><br></pre></td></tr></table></figure>

<p>还是拿小张和小王来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小张 - 成都</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 小王 - 北京</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 开启事务之前先查询表，准备操作数据。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">| id | name      | money |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">|  6 | d         |  1000 |</span><br><span class="line">+----+-----------+-------+</span><br><span class="line"></span><br><span class="line">-- 发现没有 7 号王小花，于是插入一条数据：</span><br><span class="line">INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000);</span><br></pre></td></tr></table></figure>

<p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p>
<p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>
<p>串行化带来的问题：性能差。</p>
<p><strong>隔离级别越高，性能越差。</strong></p>
<p>性能比较： <code>READ-UNCOMMITTED &gt; READ-COMMITTED &gt; REPEATABLE-READ &gt; SERIALIZABLE;</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的基本语法</title>
    <url>/2020/06/05/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>MySQL的增、删、改、查 即 CRUD 基本操作。</p>
<p>Create(创建)、Retrieve(读取)、Update（更新）、Delete（删除）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 显示所有数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE test;</span><br><span class="line"></span><br><span class="line">-- 切换数据库</span><br><span class="line">use test;</span><br><span class="line"></span><br><span class="line">-- 显示数据库中的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">-- 创建数据表</span><br><span class="line">CREATE TABLE pet (</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    owner VARCHAR(20),</span><br><span class="line">    species VARCHAR(20),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birth DATE,</span><br><span class="line">    death DATE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查看数据表结构</span><br><span class="line">-- describe pet;</span><br><span class="line">desc pet;</span><br><span class="line"></span><br><span class="line">-- 查询表</span><br><span class="line">SELECT * from pet;</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);</span><br><span class="line"></span><br><span class="line">-- 修改数据</span><br><span class="line">UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;</span><br><span class="line"></span><br><span class="line">-- 删除数据</span><br><span class="line">DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line">DROP TABLE myorder;</span><br><span class="line"></span><br><span class="line">-- 删除数据库</span><br><span class="line">DROP DATABASE test;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL子查询</title>
    <url>/2020/06/10/MySQL/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>即在主查询中再嵌套一个SELECT。</p>
<p><strong>查询汇总</strong></p>
<ol>
<li><p>查询 <code>95031</code> 班学生每门课程的平均成绩。</p>
</li>
<li><p>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</p>
</li>
<li><p>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</p>
</li>
<li><p>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</p>
</li>
<li><p>查询 “计算机系” 课程的成绩表。</p>
</li>
<li><p>.查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code>。</p>
</li>
<li><p>查询 “男” 教师及其所教授的课程。</p>
</li>
<li><p>查询和 “李军” 同性别的所有同学 <code>name</code> 。</p>
</li>
<li><p>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</p>
</li>
<li><p>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</p>
</li>
</ol>
<h2 id="一、子查询加分组求平均分"><a href="#一、子查询加分组求平均分" class="headerlink" title="一、子查询加分组求平均分"></a>一、子查询加分组求平均分</h2><p><strong>1.查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p>
<p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询</span><br><span class="line">SELECT s_no, c_no, degree FROM score</span><br><span class="line">WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT c_no, AVG(degree) FROM score</span><br><span class="line">WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)</span><br><span class="line">GROUP BY c_no;</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     82.0000 |</span><br><span class="line">| 3-245 |     71.5000 |</span><br><span class="line">| 6-166 |     80.0000 |</span><br><span class="line">+-------+-------------+</span><br></pre></td></tr></table></figure>

<h2 id="二、子查询-1"><a href="#二、子查询-1" class="headerlink" title="二、子查询 - 1"></a>二、子查询 - 1</h2><p><strong>2.查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p>
<p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score </span><br><span class="line">WHERE c_no &#x3D; &#39;3-105&#39;</span><br><span class="line">AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="三、子查询-2"><a href="#三、子查询-2" class="headerlink" title="三、子查询 - 2"></a>三、子查询 - 2</h2><p><strong>3.查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。</span><br><span class="line">SELECT * FROM score</span><br><span class="line">WHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="四、多层嵌套子查询"><a href="#四、多层嵌套子查询" class="headerlink" title="四、多层嵌套子查询"></a>四、多层嵌套子查询</h2><p><strong>4.查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p>
<p>首先找到教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39;</span><br></pre></td></tr></table></figure>

<p>通过 <code>sourse</code> 表找到该教师课程号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; );</span><br></pre></td></tr></table></figure>

<p>通过筛选出的课程号查询成绩表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; (</span><br><span class="line">    SELECT no FROM course WHERE t_no &#x3D; ( </span><br><span class="line">        SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; </span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="五、子查询-3"><a href="#五、子查询-3" class="headerlink" title="五、子查询 - 3"></a>五、子查询 - 3</h2><p><strong>5.查询 “计算机系” 课程的成绩表。</strong></p>
<p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号</span><br><span class="line">SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line">| no  | name   | department   |</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line">| 804 | 李诚   | 计算机系     |</span><br><span class="line">| 825 | 王萍   | 计算机系     |</span><br><span class="line">+-----+--------+--------------+</span><br><span class="line"></span><br><span class="line">-- 通过 course 表查询该教师的课程编号</span><br><span class="line">SELECT no FROM course WHERE t_no IN (</span><br><span class="line">    SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">);</span><br><span class="line">+-------+</span><br><span class="line">| no    |</span><br><span class="line">+-------+</span><br><span class="line">| 3-245 |</span><br><span class="line">| 3-105 |</span><br><span class="line">+-------+</span><br><span class="line"></span><br><span class="line">-- 根据筛选出来的课程号查询成绩表</span><br><span class="line">SELECT * FROM score WHERE c_no IN (</span><br><span class="line">    SELECT no FROM course WHERE t_no IN (</span><br><span class="line">        SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h2 id="六、子查询-4"><a href="#六、子查询-4" class="headerlink" title="六、子查询 - 4"></a>六、子查询 - 4</h2><p><strong>6.查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code>。</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);</span><br><span class="line">+--------+-----------------+</span><br><span class="line">| name   | department      |</span><br><span class="line">+--------+-----------------+</span><br><span class="line">| 李诚   | 计算机系        |</span><br><span class="line">| 王萍   | 计算机系        |</span><br><span class="line">| 刘冰   | 电子工程系      |</span><br><span class="line">| 张旭   | 电子工程系      |</span><br><span class="line">+--------+-----------------+</span><br></pre></td></tr></table></figure>

<h2 id="七、子查询-5"><a href="#七、子查询-5" class="headerlink" title="七、子查询 - 5"></a>七、子查询 - 5</h2><p><strong>7.查询 “男” 教师及其所教授的课程。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);</span><br><span class="line">+-------+--------------+------+</span><br><span class="line">| no    | name         | t_no |</span><br><span class="line">+-------+--------------+------+</span><br><span class="line">| 3-245 | 操作系统     | 804  |</span><br><span class="line">| 6-166 | 数字电路     | 856  |</span><br><span class="line">+-------+--------------+------+</span><br></pre></td></tr></table></figure>

<h2 id="八、子查询-6"><a href="#八、子查询-6" class="headerlink" title="八、子查询 - 6"></a>八、子查询 - 6</h2><p><strong>8.查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先将李军的性别作为条件取出来</span><br><span class="line">SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;</span><br><span class="line">+-----+</span><br><span class="line">| sex |</span><br><span class="line">+-----+</span><br><span class="line">| 男  |</span><br><span class="line">+-----+</span><br><span class="line"></span><br><span class="line">-- 根据性别查询 name 和 sex</span><br><span class="line">SELECT name, sex FROM student WHERE sex &#x3D; (</span><br><span class="line">    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">);</span><br><span class="line">+-----------+-----+</span><br><span class="line">| name      | sex |</span><br><span class="line">+-----------+-----+</span><br><span class="line">| 曾华      | 男  |</span><br><span class="line">| 匡明      | 男  |</span><br><span class="line">| 李军      | 男  |</span><br><span class="line">| 陆军      | 男  |</span><br><span class="line">| 王尼玛    | 男  |</span><br><span class="line">| 张全蛋    | 男  |</span><br><span class="line">| 赵铁柱    | 男  |</span><br><span class="line">| 张飞      | 男  |</span><br><span class="line">+-----------+-----+</span><br></pre></td></tr></table></figure>

<h2 id="九、子查询-7"><a href="#九、子查询-7" class="headerlink" title="九、子查询 - 7"></a>九、子查询 - 7</h2><p><strong>9.查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, sex, class FROM student WHERE sex &#x3D; (</span><br><span class="line">    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">) AND class &#x3D; (</span><br><span class="line">    SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;</span><br><span class="line">);</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| name      | sex | class |</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| 曾华      | 男  | 95033 |</span><br><span class="line">| 李军      | 男  | 95033 |</span><br><span class="line">| 王尼玛    | 男  | 95033 |</span><br><span class="line">+-----------+-----+-------+</span><br></pre></td></tr></table></figure>

<h2 id="十、子查询-8"><a href="#十、子查询-8" class="headerlink" title="十、子查询 - 8"></a>十、子查询 - 8</h2><p><strong>10.查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p>
<p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; (</span><br><span class="line">    SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;</span><br><span class="line">) AND s_no IN (</span><br><span class="line">    SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mac osx 系统下 MySQL安装与使用</title>
    <url>/2020/06/05/MySQL/MySQL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、下载MySQL"><a href="#一、下载MySQL" class="headerlink" title="一、下载MySQL"></a>一、下载MySQL</h2><p>官网下载地址： <a href="https://downloads.mysql.com/archives/community/" target="_blank" rel="noopener">https://downloads.mysql.com/archives/community/</a></p>
<p><img src="1.png" alt="mysql下载"></p>
<p>可以选择不同版本以及对应不同系统，一般下载 5.7版本的dmg 文件，这一版本比较稳定，这里推荐mac osx用户使用Folx下载，速度超快~</p>
<p>方法：直接复制下载链接到Folx回车即可下载。</p>
<h2 id="二、安装MySQL"><a href="#二、安装MySQL" class="headerlink" title="二、安装MySQL"></a>二、安装MySQL</h2><p>双击dmg文件，一路next即可，注意！在最后一步时会提醒我们MySQL的一串初始密码，需要复制下来，否则将会很麻烦。。</p>
<h3 id="2-1-修改密码"><a href="#2-1-修改密码" class="headerlink" title="2.1 修改密码"></a>2.1 修改密码</h3><p>打开终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.首先输入初始密码登入mysql</span></span><br><span class="line"><span class="meta">nesw-f#</span><span class="bash">UF3uj</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.重置密码</span></span><br><span class="line">set password for 'root'@'localhost' = password('你的新密码’);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-忘记初始密码"><a href="#2-2-忘记初始密码" class="headerlink" title="2.2 忘记初始密码"></a>2.2 忘记初始密码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.苹果-&gt;系统偏好设置-&gt;最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2</span></span><br><span class="line">cd /usr/local/mysql/bin/</span><br><span class="line">　　</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.登录管理员权限 </span></span><br><span class="line">sudo su</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">　4.输入以下命令来禁止mysql验证功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回车后mysql会自动重启（偏好设置中mysql的状态会变成running）</span></span><br><span class="line">./mysqld_safe –skip-grant-tables &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5</span></span><br><span class="line">./mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.输入命令 </span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7.输入命令 </span></span><br><span class="line">SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘你的新密码’);</span><br></pre></td></tr></table></figure>

<h2 id="三、使用MySQL"><a href="#三、使用MySQL" class="headerlink" title="三、使用MySQL"></a>三、使用MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入密码</span></span><br><span class="line">123456</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出MySQL数据库服务器</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中手动开启事务</title>
    <url>/2020/06/17/MySQL/MySQL%E6%89%8B%E5%8A%A8%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="一、手动开启事务-BEGIN-START-TRANSACTION"><a href="#一、手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="一、手动开启事务 - BEGIN / START TRANSACTION"></a>一、手动开启事务 - BEGIN / START TRANSACTION</h2><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 先set提交状态为1</span><br><span class="line">set autocommit&#x3D;1;</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">+--------------+</span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+--------------+</span><br><span class="line">|            1 |</span><br><span class="line">+--------------+</span><br><span class="line"></span><br><span class="line">-- 使用set开启事务</span><br><span class="line">set autocommit&#x3D;0;</span><br><span class="line"></span><br><span class="line">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务</span><br><span class="line">-- START TRANSACTION;</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">-- 由于手动开启的事务没有开启自动提交，</span><br><span class="line">-- 此时发生变化的数据仍然是被保存在一张临时表中。</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 测试回滚</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>

<p>事务开启后，一旦使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚，也就是说这个事务在提交的时候就已经结束了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;</span><br><span class="line">UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br><span class="line"></span><br><span class="line">-- 提交数据</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 测试回滚（无效，因为表的数据已经被提交）</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | money |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL多表查询</title>
    <url>/2020/06/09/MySQL/MySQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>通过不同表中相同的字段值进行的多表联合查询。</p>
<p><strong>查询汇总</strong></p>
<ol>
<li><p>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</p>
</li>
<li><p>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</p>
</li>
<li><p>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</p>
</li>
<li><p>查询某选修课程多于5个同学的教师姓名。</p>
</li>
<li><p>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</p>
</li>
</ol>
<h2 id="一、多表查询-1"><a href="#一、多表查询-1" class="headerlink" title="一、多表查询 - 1"></a>一、多表查询 - 1</h2><p><strong>1.查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT no, name FROM student;</span><br><span class="line">+-----+-----------+</span><br><span class="line">| no  | name      |</span><br><span class="line">+-----+-----------+</span><br><span class="line">| 101 | 曾华      |</span><br><span class="line">| 102 | 匡明      |</span><br><span class="line">| 103 | 王丽      |</span><br><span class="line">| 104 | 李军      |</span><br><span class="line">| 105 | 王芳      |</span><br><span class="line">| 106 | 陆军      |</span><br><span class="line">| 107 | 王尼玛    |</span><br><span class="line">| 108 | 张全蛋    |</span><br><span class="line">| 109 | 赵铁柱    |</span><br><span class="line">+-----+-----------+</span><br><span class="line"></span><br><span class="line">SELECT s_no, c_no, degree FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- FROM...: 表示从 student, score 表中查询</span><br><span class="line">-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。</span><br><span class="line">SELECT name, c_no, degree FROM student, score </span><br><span class="line">WHERE student.no &#x3D; score.s_no;</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+-----------+-------+--------+</span><br></pre></td></tr></table></figure>

<h2 id="二、多表查询-2"><a href="#二、多表查询-2" class="headerlink" title="二、多表查询 - 2"></a>二、多表查询 - 2</h2><p><strong>2.查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p>
<p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s_no, c_no, degree FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>然后查询 <code>course</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+-----------------+</span><br><span class="line">| no    | name            |</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+-------+-----------------+</span><br></pre></td></tr></table></figure>

<p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。</span><br><span class="line">-- as 表示取一个该字段的别名。</span><br><span class="line">SELECT s_no, name as c_name, degree FROM score, course</span><br><span class="line">WHERE score.c_no &#x3D; course.no;</span><br><span class="line">+------+-----------------+--------+</span><br><span class="line">| s_no | c_name          | degree |</span><br><span class="line">+------+-----------------+--------+</span><br><span class="line">| 103  | 计算机导论      |     92 |</span><br><span class="line">| 105  | 计算机导论      |     88 |</span><br><span class="line">| 109  | 计算机导论      |     76 |</span><br><span class="line">| 103  | 操作系统        |     86 |</span><br><span class="line">| 105  | 操作系统        |     75 |</span><br><span class="line">| 109  | 操作系统        |     68 |</span><br><span class="line">| 103  | 数字电路        |     85 |</span><br><span class="line">| 105  | 数字电路        |     79 |</span><br><span class="line">| 109  | 数字电路        |     81 |</span><br><span class="line">+------+-----------------+--------+</span><br></pre></td></tr></table></figure>

<h2 id="三、三表关联查询"><a href="#三、三表关联查询" class="headerlink" title="三、三表关联查询"></a>三、三表关联查询</h2><p><strong>3.查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p>
<p>共同字段相等即可。</p>
<p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p>
<p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+-----------+-------+--------+</span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+-----------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 课程表</span><br><span class="line">SELECT no, name FROM course;</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| no    | name            |</span><br><span class="line">+-------+-----------------+</span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+-------+-----------------+</span><br><span class="line"></span><br><span class="line">-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。</span><br><span class="line">SELECT student.name as s_name, course.name as c_name, degree </span><br><span class="line">FROM student, score, course</span><br><span class="line">WHERE student.NO &#x3D; score.s_no</span><br><span class="line">AND score.c_no &#x3D; course.no;</span><br></pre></td></tr></table></figure>

<h2 id="四、多表查询-3"><a href="#四、多表查询-3" class="headerlink" title="四、多表查询 - 3"></a>四、多表查询 - 3</h2><p><strong>4.查询某选修课程多于5个同学的教师姓名。</strong></p>
<p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询 teacher 表</span><br><span class="line">SELECT no, name FROM teacher;</span><br><span class="line">+-----+--------+</span><br><span class="line">| no  | name   |</span><br><span class="line">+-----+--------+</span><br><span class="line">| 804 | 李诚   |</span><br><span class="line">| 825 | 王萍   |</span><br><span class="line">| 831 | 刘冰   |</span><br><span class="line">| 856 | 张旭   |</span><br><span class="line">+-----+--------+</span><br><span class="line"></span><br><span class="line">SELECT name FROM teacher WHERE no IN (</span><br><span class="line">    -- 在这里找到对应的条件</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查看和教师编号有有关的表的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM course;</span><br><span class="line">-- t_no: 教师编号</span><br><span class="line">+-------+-----------------+------+</span><br><span class="line">| no    | name            | t_no |</span><br><span class="line">+-------+-----------------+------+</span><br><span class="line">| 3-105 | 计算机导论      | 825  |</span><br><span class="line">| 3-245 | 操作系统        | 804  |</span><br><span class="line">| 6-166 | 数字电路        | 856  |</span><br><span class="line">| 9-888 | 高等数学        | 831  |</span><br><span class="line">+-------+-----------------+------+</span><br></pre></td></tr></table></figure>

<p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在此之前向 score 插入一些数据，以便丰富查询条件。</span><br><span class="line">INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);</span><br><span class="line">INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);</span><br><span class="line">INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);</span><br><span class="line"></span><br><span class="line">-- 查询 score 表</span><br><span class="line">SELECT * FROM score;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。</span><br><span class="line">SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;</span><br><span class="line">+-------+</span><br><span class="line">| c_no  |</span><br><span class="line">+-------+</span><br><span class="line">| 3-105 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT t_no FROM course WHERE no IN (</span><br><span class="line">    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5</span><br><span class="line">);</span><br><span class="line">+------+</span><br><span class="line">| t_no |</span><br><span class="line">+------+</span><br><span class="line">| 825  |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>

<p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name FROM teacher WHERE no IN (</span><br><span class="line">    -- 最终条件</span><br><span class="line">    SELECT t_no FROM course WHERE no IN (</span><br><span class="line">        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="五、按等级查询"><a href="#五、按等级查询" class="headerlink" title="五、按等级查询"></a>五、按等级查询</h2><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE grade (</span><br><span class="line">    low INT(3),</span><br><span class="line">    upp INT(3),</span><br><span class="line">    grade char(1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO grade VALUES (90, 100, &#39;A&#39;);</span><br><span class="line">INSERT INTO grade VALUES (80, 89, &#39;B&#39;);</span><br><span class="line">INSERT INTO grade VALUES (70, 79, &#39;C&#39;);</span><br><span class="line">INSERT INTO grade VALUES (60, 69, &#39;D&#39;);</span><br><span class="line">INSERT INTO grade VALUES (0, 59, &#39;E&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM grade;</span><br><span class="line">+------+------+-------+</span><br><span class="line">| low  | upp  | grade |</span><br><span class="line">+------+------+-------+</span><br><span class="line">|   90 |  100 | A     |</span><br><span class="line">|   80 |   89 | B     |</span><br><span class="line">|   70 |   79 | C     |</span><br><span class="line">|   60 |   69 | D     |</span><br><span class="line">|    0 |   59 | E     |</span><br><span class="line">+------+------+-------+</span><br></pre></td></tr></table></figure>

<p><strong>5.查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p>
<p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s_no, c_no, grade(等级) FROM score, grade </span><br><span class="line">WHERE degree BETWEEN low AND upp;</span><br><span class="line">+------+-------+-------+</span><br><span class="line">| s_no | c_no  | grade |</span><br><span class="line">+------+-------+-------+</span><br><span class="line">| 101  | 3-105 | A     |</span><br><span class="line">| 102  | 3-105 | A     |</span><br><span class="line">| 103  | 3-105 | A     |</span><br><span class="line">| 103  | 3-245 | B     |</span><br><span class="line">| 103  | 6-166 | B     |</span><br><span class="line">| 104  | 3-105 | B     |</span><br><span class="line">| 105  | 3-105 | B     |</span><br><span class="line">| 105  | 3-245 | C     |</span><br><span class="line">| 105  | 6-166 | C     |</span><br><span class="line">| 109  | 3-105 | C     |</span><br><span class="line">| 109  | 3-245 | D     |</span><br><span class="line">| 109  | 6-166 | B     |</span><br><span class="line">+------+-------+-------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的三大设计范式</title>
    <url>/2020/06/06/MySQL/MySQL%E7%9A%84%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>范式有助于数据库的设计，包括 1NF、2NF、3NF。</p>
<h2 id="一、1NF"><a href="#一、1NF" class="headerlink" title="一、1NF"></a>一、1NF</h2><p>在建表设计字段时，只要字段值还可以继续拆分，就不满足第一范式。例如“中国四川省成都市武侯区天府大道100号”就还可以拆分。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<h2 id="二、2NF"><a href="#二、2NF" class="headerlink" title="二、2NF"></a>二、2NF</h2><p>在满足第一范式的前提下，其他列都必须<strong>完全依赖</strong>于主键列。不完全依赖，<strong>只可能</strong>发生在联合主键的情况下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE myorder (</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    product_name VARCHAR(20),</span><br><span class="line">    customer_name VARCHAR(20),</span><br><span class="line">    PRIMARY KEY (product_id, customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。</p>
<p>也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没有关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
<p>即除主键以外的其它列只依赖于主键的部分字段，这就不满足第二范式：其他列都必须完全依赖于主键列！</p>
<p>拆表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE product (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
<h2 id="三、3NF"><a href="#三、3NF" class="headerlink" title="三、3NF"></a>三、3NF</h2><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    customer_phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>表中的 <code>customer_phone</code> 有可能依赖于 <code>customer_id</code> 、 <code>customer_id</code> 可能依赖于<code>order_id</code>两列，也就不满足了第三范式的设计：其他列之间不能有</p>
<p>传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">    order_id INT PRIMARY KEY,</span><br><span class="line">    product_id INT,</span><br><span class="line">    customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL连接查询</title>
    <url>/2020/06/15/MySQL/MySQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>MySQL中的连接查询相当于求两张表的集合，分为内连接和外连接，其中外连接又分为左外连接、右外连接、全外连接。</p>
<p><strong>连接查询</strong></p>
<p>准备用于测试连接查询的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE testJoin;</span><br><span class="line"></span><br><span class="line">USE testJoin;</span><br><span class="line"></span><br><span class="line">CREATE TABLE person (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    cardId INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE card (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM card;</span><br><span class="line">+------+-----------+</span><br><span class="line">| id   | name      |</span><br><span class="line">+------+-----------+</span><br><span class="line">|    1 | 饭卡      |</span><br><span class="line">|    2 | 建行卡    |</span><br><span class="line">|    3 | 农行卡    |</span><br><span class="line">|    4 | 工商卡    |</span><br><span class="line">|    5 | 邮政卡    |</span><br><span class="line">+------+-----------+</span><br><span class="line"></span><br><span class="line">INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);</span><br><span class="line"></span><br><span class="line">SELECT * FROM person;</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| id   | name   | cardId |</span><br><span class="line">+------+--------+--------+</span><br><span class="line">|    1 | 张三   |      1 |</span><br><span class="line">|    2 | 李四   |      3 |</span><br><span class="line">|    3 | 王五   |      6 |</span><br><span class="line">+------+--------+--------+</span><br></pre></td></tr></table></figure>

<p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p>
<h2 id="一、内连接"><a href="#一、内连接" class="headerlink" title="一、内连接"></a>一、内连接</h2><p>内联查询：要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。相当于取交集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- INNER JOIN&#x2F;JOIN: 表示为内连接，将有关系（即字段相等）的两张表拼接在一起。</span><br><span class="line"></span><br><span class="line">-- on: 表示要执行某个条件。</span><br><span class="line"></span><br><span class="line">SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line"></span><br><span class="line">-- 将 INNER 关键字省略掉，结果也是一样的。</span><br><span class="line">-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>card</code> 的整张表被连接到了右边。</p>
</blockquote>
<h2 id="二、左外连接"><a href="#二、左外连接" class="headerlink" title="二、左外连接"></a>二、左外连接</h2><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。</span><br><span class="line"></span><br><span class="line">SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="三、右外连接"><a href="#三、右外连接" class="headerlink" title="三、右外连接"></a>三、右外连接</h2><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- RIGHT JOIN 也叫做 RIGHT OUTER JOIN，用这两种方式的查询结果是一样的。</span><br><span class="line"></span><br><span class="line">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line"></span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="四、全外链接"><a href="#四、全外链接" class="headerlink" title="四、全外链接"></a>四、全外链接</h2><p>完整显示两张表的全部数据。相当于取并集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MySQL 不支持这种语法的全外连接</span><br><span class="line"></span><br><span class="line">-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line"></span><br><span class="line">-- 出现错误：</span><br><span class="line"></span><br><span class="line">-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;</span><br><span class="line"></span><br><span class="line">-- MySQL全连接语法，使用 UNION 将两张表合并在一起。</span><br><span class="line"></span><br><span class="line">SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;</span><br><span class="line"></span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+------+--------+--------+------+-----------+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的建表约束</title>
    <url>/2020/06/05/MySQL/MySQL%E7%9A%84%E5%BB%BA%E8%A1%A8%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>主要包括 主键约束、自增约束、唯一约束、非空约束、默认约束、外键约束。</p>
<h2 id="一、主键约束"><a href="#一、主键约束" class="headerlink" title="一、主键约束"></a>一、主键约束</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 主键约束</span><br><span class="line">-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 联合主键</span><br><span class="line">-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    password VARCHAR(20),</span><br><span class="line">    PRIMARY KEY(id, name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加主键约束</span><br><span class="line">-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：</span><br><span class="line">ALTER TABLE user ADD PRIMARY KEY(id);</span><br><span class="line">ALTER TABLE user MODIFY id INT PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">-- 删除主键</span><br><span class="line">ALTER TABLE user drop PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<h2 id="二、自增约束"><a href="#二、自增约束" class="headerlink" title="二、自增约束"></a>二、自增约束</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 自增约束</span><br><span class="line">-- 自增约束的主键由系统自动递增分配。</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="三、唯一主键"><a href="#三、唯一主键" class="headerlink" title="三、唯一主键"></a>三、唯一主键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 建表时创建唯一主键</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),  -- UNIQUE(id,name)</span><br><span class="line">    UNIQUE(name)     </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加唯一主键</span><br><span class="line">-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：</span><br><span class="line">ALTER TABLE user ADD UNIQUE(name);</span><br><span class="line">ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;</span><br><span class="line"></span><br><span class="line">-- 删除唯一主键</span><br><span class="line">ALTER TABLE user DROP INDEX name;   &#x2F;&#x2F;INDEX指定具体删除哪一个字段的约束</span><br></pre></td></tr></table></figure>

<p><strong>Primary Key与Unique Key区别</strong></p>
<p>一、作为Primary Key的域/域组不能为null，而Unique Key可以。 </p>
<p>二、在一个表中只能有一个Primary Key，而多个Unique Key可以同时存在。 </p>
<p>更大的区别在逻辑设计上。Primary Key一般在逻辑设计中用作记录标识，这也是设置Primary Key的本来用意，而Unique Key只是为了保证域/域组的唯一性。</p>
<h2 id="四、非空约束"><a href="#四、非空约束" class="headerlink" title="四、非空约束"></a>四、非空约束</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 建表时添加非空约束</span><br><span class="line">-- 约束某个字段不能为空</span><br><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 移除非空约束</span><br><span class="line">ALTER TABLE user MODIFY name VARCHAR(20);</span><br></pre></td></tr></table></figure>

<h2 id="五、默认约束"><a href="#五、默认约束" class="headerlink" title="五、默认约束"></a>五、默认约束</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 建表时添加默认约束</span><br><span class="line">-- 约束某个字段的默认值</span><br><span class="line">CREATE TABLE user2 (</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    age INT DEFAULT 10</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 移除非空约束</span><br><span class="line">ALTER TABLE user MODIFY age INT;</span><br></pre></td></tr></table></figure>

<h2 id="六、外键约束"><a href="#六、外键约束" class="headerlink" title="六、外键约束"></a>六、外键约束</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 班级</span><br><span class="line">CREATE TABLE classes (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 学生表</span><br><span class="line">CREATE TABLE students (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    -- 这里的 class_id 要和 classes 中的 id 字段相关联</span><br><span class="line">    class_id INT,</span><br><span class="line">    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值</span><br><span class="line">    FOREIGN KEY(class_id) REFERENCES classes(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；</span><br><span class="line">-- 2. 主表中的记录被副表引用时，主表的记录不可以被删除。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL分组查询</title>
    <url>/2020/06/09/MySQL/MySQL%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>GROUP BY的主要使用方法。</p>
<p><strong>查询汇总</strong></p>
<ol>
<li><p>查询每门课的平均成绩。</p>
</li>
<li><p>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的c_no和平均分数。</p>
</li>
<li><p>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</p>
</li>
</ol>
<h2 id="一、分组计算平均成绩"><a href="#一、分组计算平均成绩" class="headerlink" title="一、分组计算平均成绩"></a>一、分组计算平均成绩</h2><p><strong>1.查询每门课的平均成绩。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- AVG: 平均值</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;</span><br><span class="line">SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;</span><br><span class="line"></span><br><span class="line">-- GROUP BY: 分组查询</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</span><br></pre></td></tr></table></figure>

<h2 id="二、分组条件与模糊查询"><a href="#二、分组条件与模糊查询" class="headerlink" title="二、分组条件与模糊查询"></a>二、分组条件与模糊查询</h2><p><strong>2.查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的c_no和平均分数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score;</span><br><span class="line">-- c_no 课程编号</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先把 c_no, AVG(degree) 通过分组查询出来</span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no</span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     85.3333 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+-------+-------------+</span><br><span class="line"></span><br><span class="line">-- HAVING: 表示持有，即分组条件</span><br><span class="line">-- 再查询出至少有 2 名学生选修的课程</span><br><span class="line">HAVING COUNT(c_no) &gt;&#x3D; 2</span><br><span class="line"></span><br><span class="line">-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。</span><br><span class="line">-- 并且是以 3 开头的课程</span><br><span class="line">AND c_no LIKE &#39;3%&#39;;</span><br><span class="line"></span><br><span class="line">-- 把前面的SQL语句拼接起来，</span><br><span class="line">-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。</span><br><span class="line">SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no</span><br><span class="line">HAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| c_no  | AVG(degree) | COUNT(*) |</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| 3-105 |     85.3333 |        3 |</span><br><span class="line">| 3-245 |     76.3333 |        3 |</span><br><span class="line">+-------+-------------+----------+</span><br></pre></td></tr></table></figure>

<h2 id="三、条件加组筛选"><a href="#三、条件加组筛选" class="headerlink" title="三、条件加组筛选"></a>三、条件加组筛选</h2><p><strong>3.查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看学生表信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line"></span><br><span class="line">-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。</span><br><span class="line">SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;</span><br><span class="line">+-------+</span><br><span class="line">| class |</span><br><span class="line">+-------+</span><br><span class="line">| 95033 |</span><br><span class="line">| 95031 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据表的创建和添加数据的示例</title>
    <url>/2020/06/06/MySQL/%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>course 表、score 表、student 表、teacher 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE select_test;</span><br><span class="line"></span><br><span class="line">-- 切换数据库</span><br><span class="line">USE select_test;</span><br><span class="line"></span><br><span class="line">-- 创建学生表</span><br><span class="line">CREATE TABLE student (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    sex VARCHAR(10) NOT NULL,</span><br><span class="line">    birthday DATE, -- 生日</span><br><span class="line">    class VARCHAR(20) -- 所在班级</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建教师表</span><br><span class="line">CREATE TABLE teacher (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    sex VARCHAR(10) NOT NULL,</span><br><span class="line">    birthday DATE,</span><br><span class="line">    profession VARCHAR(20) NOT NULL, -- 职称</span><br><span class="line">    department VARCHAR(20) NOT NULL -- 部门</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建课程表</span><br><span class="line">CREATE TABLE course (</span><br><span class="line">    no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    t_no VARCHAR(20) NOT NULL, -- 教师编号</span><br><span class="line">    -- 表示该 tno 来自于 teacher 表中的 no 字段值</span><br><span class="line">    FOREIGN KEY(t_no) REFERENCES teacher(no) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 成绩表</span><br><span class="line">CREATE TABLE score (</span><br><span class="line">    s_no VARCHAR(20) NOT NULL, -- 学生编号</span><br><span class="line">    c_no VARCHAR(20) NOT NULL, -- 课程号</span><br><span class="line">    degree DECIMAL,	-- 成绩</span><br><span class="line">    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值</span><br><span class="line">    FOREIGN KEY(s_no) REFERENCES student(no),	</span><br><span class="line">    FOREIGN KEY(c_no) REFERENCES course(no),</span><br><span class="line">    -- 设置 s_no, c_no 为联合主键</span><br><span class="line">    PRIMARY KEY(s_no, c_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查看所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">-- 添加学生表数据</span><br><span class="line">INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);</span><br><span class="line">INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加教师表数据</span><br><span class="line">INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加课程表数据</span><br><span class="line">INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);</span><br><span class="line">INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);</span><br><span class="line"></span><br><span class="line">-- 添加添加成绩表数据</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);</span><br><span class="line">INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);</span><br><span class="line"></span><br><span class="line">-- 查看表结构</span><br><span class="line">SELECT * FROM course;</span><br><span class="line">SELECT * FROM score;</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">SELECT * FROM teacher;</span><br></pre></td></tr></table></figure>

<p>course 表<br>+——-+—————–+——+<br>| no    | name            | t_no |<br>+——-+—————–+——+<br>| 3-105 | 计算机导论      | 825  |<br>| 3-245 | 操作系统        | 804  |<br>| 6-166 | 数字电路        | 856  |<br>| 9-888 | 高等数学        | 831  |<br>+——-+—————–+——+</p>
<p>score 表<br>+——+——-+——–+<br>| s_no | c_no  | degree |<br>+——+——-+——–+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+——+——-+——–+</p>
<p>student 表<br>+—–+———–+—–+————+——-+<br>| no  | name      | sex | birthday   | class |<br>+—–+———–+—–+————+——-+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>+—–+———–+—–+————+——-+</p>
<p>teacher 表<br>+—–+——–+—–+————+————+—————–+<br>| no  | name   | sex | birthday   | profession | department      |<br>+—–+——–+—–+————+————+—————–+<br>| 804 | 李诚   | 男  | 1958-12-02 | 副教授     | 计算机系        |<br>| 825 | 王萍   | 女  | 1972-05-05 | 助教       | 计算机系        |<br>| 831 | 刘冰   | 女  | 1977-08-14 | 助教       | 电子工程系      |<br>| 856 | 张旭   | 男  | 1969-03-12 | 讲师       | 电子工程系      |<br>+—–+——–+—–+————+————+—————–+</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL复制表的数据作为条件查询</title>
    <url>/2020/06/11/MySQL/%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BD%9C%E4%B8%BA%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h2><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询平均分</span><br><span class="line"></span><br><span class="line">SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</span><br><span class="line"></span><br><span class="line">+-------+-------------+</span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     87.6667 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+-------+-------------+</span><br><span class="line"></span><br><span class="line">-- 查询 score 表</span><br><span class="line"></span><br><span class="line">SELECT * FROM score;</span><br><span class="line"></span><br><span class="line">a                               b</span><br><span class="line">+------+-------+--------+       +------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |       | s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+       +------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |       | 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |       | 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |       | 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |       | 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |       | 103  | 6-166 |     85 |</span><br><span class="line">| 104  | 3-105 |     89 |       | 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |       | 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |       | 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |       | 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |       | 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |       | 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |       | 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+       +------+-------+--------+</span><br><span class="line"></span><br><span class="line">-- 将表 b 作用于表 a 中查询数据</span><br><span class="line"></span><br><span class="line">-- score a (b): 将表声明为 a (b)，</span><br><span class="line"></span><br><span class="line">-- 查找a中每一条数据时，在b中筛选当前c_no课程的平均成绩并将a中当前记录的成绩与该平均成绩比较，若小于则筛选出来。</span><br><span class="line"></span><br><span class="line">SELECT * FROM score a WHERE degree &lt; (</span><br><span class="line">    (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询关键字的使用</title>
    <url>/2020/06/11/MySQL/MySQL%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>UNION、 NOT IN、 ANY、 ALL、 NOT LIKE、 ASC、 DESC等查询关键字的使用方法。</p>
<p><strong>查询汇总</strong></p>
<ol>
<li><p>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</p>
</li>
<li><p>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</p>
</li>
<li><p>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</p>
</li>
<li><p>查询 <code>student</code> 表中不姓 “王” 的同学记录。</p>
</li>
<li><p>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</p>
</li>
<li><p>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</p>
</li>
</ol>
<h2 id="一、UNION-和-NOT-IN-的使用"><a href="#一、UNION-和-NOT-IN-的使用" class="headerlink" title="一、UNION 和 NOT IN 的使用"></a>一、UNION 和 NOT IN 的使用</h2><p><strong>1.查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- NOT IN: 代表逻辑非</span><br><span class="line">SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN (</span><br><span class="line">    SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;</span><br><span class="line">)</span><br><span class="line">-- UNION:求并集</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN (</span><br><span class="line">    SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="二、ANY-表示至少一个-DESC-降序"><a href="#二、ANY-表示至少一个-DESC-降序" class="headerlink" title="二、ANY 表示至少一个 - DESC ( 降序 )"></a>二、ANY 表示至少一个 - DESC ( 降序 )</h2><p><strong>2.查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">+------+-------+--------+</span><br><span class="line"></span><br><span class="line">-- ANY: 符合SQL语句中的任意条件。</span><br><span class="line">-- 也就是说，在 3-105 成绩中，只要大于 3-245 中任意一个成绩就符合条件，</span><br><span class="line">-- 最后根据降序查询结果。</span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY(</span><br><span class="line">    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;</span><br><span class="line">) ORDER BY degree DESC;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h2 id="三、表示所有的-ALL"><a href="#三、表示所有的-ALL" class="headerlink" title="三、表示所有的 ALL"></a>三、表示所有的 ALL</h2><p><strong>3.查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 只需对上一道题稍作修改。</span><br><span class="line">-- ALL: 符合SQL语句中的所有条件。</span><br><span class="line">-- 且的意思是，在 3-105 的多有成绩，都要大于 3-245 所有成绩。</span><br><span class="line">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL(</span><br><span class="line">    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;</span><br><span class="line">);</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">+------+-------+--------+</span><br></pre></td></tr></table></figure>

<h2 id="四、NOT-LIKE-模糊查询取反"><a href="#四、NOT-LIKE-模糊查询取反" class="headerlink" title="四、NOT LIKE 模糊查询取反"></a>四、NOT LIKE 模糊查询取反</h2><p><strong>4.查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- NOT: 取反</span><br><span class="line">-- LIKE: 模糊查询</span><br><span class="line">SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br></pre></td></tr></table></figure>

<h2 id="五、多段排序"><a href="#五、多段排序" class="headerlink" title="五、多段排序"></a>五、多段排序</h2><p><strong>5.以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student ORDER BY class DESC, birthday; -- 日期越小，年龄越大</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">+-----+-----------+-----+------------+-------+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
