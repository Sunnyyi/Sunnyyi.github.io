<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringMVC</title>
    <url>/2019/02/20/Spring%E5%AE%9E%E6%88%98/SpringMVC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeup和PAT刷题记录——入门模拟</title>
    <url>/2020/04/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>记录刷题过程中遇到的问题和技巧。</p>
<h1 id="一、技巧总结"><a href="#一、技巧总结" class="headerlink" title="一、技巧总结"></a>一、技巧总结</h1><h2 id="1-简单模拟"><a href="#1-简单模拟" class="headerlink" title="1. 简单模拟"></a>1. 简单模拟</h2><p>①将字符型数字转换为整型数字：例如<code>&#39;8&#39;-&#39;0&#39;</code>。<br>②当 -10<sup>9</sup>&lt;a,b&lt;10<sup>9</sup>,或者-2<sup>31</sup>&lt;a,b&lt;2<sup>31</sup>，a+b仍为Int型,但当区间带等号时a,b,c都应当定义为long long型变量。</p>
<h2 id="2-图形输出"><a href="#2-图形输出" class="headerlink" title="2. 图形输出"></a>2. 图形输出</h2><p>③整数n/2避免使用round函数来进行四舍五入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) n=n/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> n=n/<span class="number">2</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>②使用指定字符输出图形实质上是确定每一行输出的不同字符数与行数之间的数学计算关系。</p>
<h2 id="3-日期处理"><a href="#3-日期处理" class="headerlink" title="3. 日期处理"></a>3. 日期处理</h2><p>①日期处理问题往往需要使用数组存储与日期如平年和闰年的月份、月份和星期的英文字符串等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！month[m][0]存储平年每个月天数，month[m][1]存储闰年每个月天数 </span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储月份英文名称和罗马数字的关系</span></span><br><span class="line"><span class="keyword">char</span>  monthToNum[<span class="number">13</span>][<span class="number">20</span>]=&#123;<span class="string">" "</span>,<span class="string">"January"</span>,<span class="string">"February"</span>,<span class="string">"March"</span>,<span class="string">"April"</span>,<span class="string">"May"</span>,<span class="string">"June"</span>,</span><br><span class="line">			<span class="string">"July"</span>,<span class="string">"August"</span>,<span class="string">"September"</span>,<span class="string">"October"</span>,<span class="string">"November"</span>,<span class="string">"December"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ </span></span><br><span class="line"><span class="keyword">char</span> numToWeek[<span class="number">8</span>][<span class="number">20</span>]=&#123;<span class="string">"Sunday"</span>,<span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>,<span class="string">"Wednesday"</span>,<span class="string">"Thursday"</span>,<span class="string">"Friday"</span>,<span class="string">"Saturday"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>②判断是否为闰年的函数写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为闰年 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (((y%<span class="number">4</span>==<span class="number">0</span>) &amp;&amp; (y%<span class="number">100</span>!=<span class="number">0</span>)) || (y%<span class="number">400</span>==<span class="number">0</span>)); &#125;</span><br></pre></td></tr></table></figure>
<p>③查找任意年y的某个月m的天数写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">month[m][isLeapTear(y)];</span><br></pre></td></tr></table></figure>
<p>④提取int型变量中的任意几位：例如提取20130102中的YYYY、MM、DD。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y1=date1/<span class="number">10000</span>,m1=date1%<span class="number">10000</span>/<span class="number">100</span>,d1=date1%<span class="number">10000</span>%<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>⑤计算任意两个日期间差值可分别计算它们与公元1年1月1日的差值然后再计算两个差值的差值。<br>⑥计算某个日期的星期数可首先计算与公元1年1月1日天数差值，再对差值取余即为星期数的下标。</p>
<h2 id="4-进制转换"><a href="#4-进制转换" class="headerlink" title="4. 进制转换"></a>4. 进制转换</h2><p>①P进制数x转换为十进制数y，利用while循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">	y=y+(x%<span class="number">10</span>)*product;</span><br><span class="line">	x/=<span class="number">10</span>;</span><br><span class="line">	product*=P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②十进制数y转换为Q进制数z[num-1,0],利用“除基取余法”和do while循环，防止y=0而没有输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	z[num++]=y%Q;</span><br><span class="line">	y/=Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>②注意当数组z为字符数组时，在末尾应手动添加’\0’，否则容易出错。<br>③当十进制整数超出整型可存储的范围时，用字符数组来存储处理比较方便，来模拟十进制整数的运算过程。</p>
<h2 id="5-字符串处理"><a href="#5-字符串处理" class="headerlink" title="5. 字符串处理"></a>5. 字符串处理</h2><p>①边输入边处理被空格分隔的字符串有两种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span>)&#123;...&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[num++])!=EOF);</span><br></pre></td></tr></table></figure>
<p>②一定要注意scanf(“%c”)和gets(s)之间要用getchar()吸收换行符，否则很容易出错。<br>③若题设条件未给出输入字符串格式，则应考虑带空格的输入。此时应用gets(s)进行输入。</p>
<h1 id="二、经典题目"><a href="#二、经典题目" class="headerlink" title="二、经典题目"></a>二、经典题目</h1><h2 id="1-比较交换3个实数值，并按序输出"><a href="#1-比较交换3个实数值，并按序输出" class="headerlink" title="1. 比较交换3个实数值，并按序输出"></a>1. 比较交换3个实数值，并按序输出</h2><p><strong>题目描述</strong><br>从键盘输入3个实数a, b, c，通过比较交换，将最小值存储在变量a中，最大值存储在变量c中，中间值存储在变量b中，并按照从小到大的顺序输出这三个数a, b, c。<br>末尾输出换行。<br><strong>输入</strong><br>输入以空格分隔的三个实数<br><strong>输出</strong><br>按照从小到大的顺序输出这三个实数，中间以空格分隔，最小值在前，最大值在后。小数点后保留2位小数。<br>注意末尾的换行。<br><strong>样例输入</strong><br>3 7 1<br><strong>样例输出</strong><br>1.00 3.00 7.00</p>
<p><strong>思路</strong><br>冒泡法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> a,b,c,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="comment">//冒泡法 </span></span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)temp=a,a=b,b=temp;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)temp=b,b=c,c=temp;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)temp=a,a=b,b=temp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2f %.2f %.2f\n"</span>,a,b,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-三个整数求最大值"><a href="#2-三个整数求最大值" class="headerlink" title="2. 三个整数求最大值"></a>2. 三个整数求最大值</h2><p><strong>题目描述</strong><br>有3个整数a, b, c，由键盘输入，输出其中最大的数。<br><strong>输入</strong><br>以空格分割的三个整数。<br><strong>输出</strong><br>三个数中的最大值，末尾换行。<br><strong>样例输入</strong><br>1 3 2<br><strong>样例输出</strong><br>3<br><strong>思路</strong><br>比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a,b,c,<span class="built_in">max</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="built_in">max</span>=a&gt;b?a:b;</span><br><span class="line">	<span class="built_in">max</span>=<span class="built_in">max</span>&gt;c?<span class="built_in">max</span>:c;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">max</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-矩阵输出"><a href="#3-矩阵输出" class="headerlink" title="3. 矩阵输出"></a>3. 矩阵输出</h2><p><strong>题目描述</strong><br>输出以下4*5的矩阵</p>
<p>  1  2  3  4  5</p>
<p>  2  4  6  8 10</p>
<p>  3  6  9 12 15</p>
<p>  4  8 12 16 20<br>要求使用循环实现，注意每行输出5个数字，每个数字占3个字符的宽度，右对齐。<br><strong>输入</strong><br>无<br><strong>输出</strong><br>每行输出5个数字，每个数字占3个字符的宽度，右对齐。<br><strong>样例输入</strong><br>无<br><strong>样例输出</strong><br>  1  2  3  4  5<br>  2  4  6  8 10<br>  3  6  9 12 15<br>  4  8 12 16 20<br><strong>思路</strong></p>
<blockquote>
<p>i保存每一行的输出值，a为每行的累加值， i=i+a;</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>,a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(a&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%3d"</span>,i);  <span class="comment">//依次输出元素 </span></span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>),a++,i=a;</span><br><span class="line">			<span class="keyword">continue</span>;  <span class="comment">//若每行元素达到5个，则换行且重置a和i的值，并跳出本次循环。</span></span><br><span class="line">		&#125;</span><br><span class="line">		i+=a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-杨辉三角"><a href="#4-杨辉三角" class="headerlink" title="4. 杨辉三角"></a>4. 杨辉三角</h2><p><strong>题目描述</strong><br>按要求输入如下格式的杨辉三角<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1<br>最多输出10层<br><strong>输入</strong><br>输入只包含一个正整数n，表示将要输出的杨辉三角的层数。<br><strong>输出</strong><br>对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开<br><strong>样例输入</strong><br>5<br><strong>样例输出</strong><br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br><strong>思路</strong><br>i控制输出的行数，j控制每行元素个数，j&lt;=i,a[j]保存上一行的元素，b[j]根据a[j]计算本行的元素值并输出；</p>
<blockquote>
<p>① 首先输出每行的第一个元素b[1]；<br>② 然后控制j=2,j&lt;i,输出每行中间元素b[j]=a[j-1]+a[j]；<br>③ 最后输出每行最后一个元素b[j]=a[j],并换行；<br>④ 更新a[j]，回到步骤①</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n,i,j,a[<span class="number">15</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,b[<span class="number">15</span>];</span><br><span class="line">	b[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	 </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,b[<span class="number">1</span>]);  <span class="comment">//输出每一行第一个元素 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;j++)&#123;          <span class="comment">//输出每行中间的元素 </span></span><br><span class="line">			b[j]=a[j<span class="number">-1</span>]+a[j];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,b[j]);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j&gt;i)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		b[j]=a[j];    <span class="comment">//输出每一行最后一个元素 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[j]);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;j++) a[j]=b[j];  <span class="comment">//更新a[j]	</span></span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Shortest-Distance-20"><a href="#5-Shortest-Distance-20" class="headerlink" title="5. Shortest Distance (20)"></a>5. Shortest Distance (20)</h2><p><strong>题目描述</strong><br>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.<br><strong>输入</strong><br>Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.<br><strong>输出</strong><br>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.<br><strong>样例输入</strong><br>5 1 2 4 14 9<br>3<br>1 3<br>2 5<br>4 1<br><strong>样例输出</strong><br>3<br>10<br>7<br><strong>思路</strong><br>本题中的距离不能暴力求解，否则极易出现超时错误！</p>
<blockquote>
<p>①输入距离d的同时利用circle累加距离，并同时利用数组dist[i+1]=circle记录出口i到出口1的距离，输入结束后circle即为计算的周长。<br>②计算任意出口a,b间的顺时针距离d1，利用d1=abs(dist[b]-dist[a])。<br>③计算任意出口a,b间的逆时针距离d2，利用d2=circle-d1。<br>④输出d1和d2中较小的那一个距离。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; //Codeup中的C++编译器不支持cmath中的abs函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> N,M,a,b,d;   <span class="comment">//出口个数N、区间[a,b]的个数M，以及出口间距离d</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">circle</span>=<span class="number">0</span>,dist[<span class="number">100010</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//周长及各出口离起始出口的距离 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d);</span><br><span class="line">			<span class="built_in">circle</span>+=d;  <span class="comment">//计算周长</span></span><br><span class="line">			dist[i+<span class="number">1</span>]=<span class="built_in">circle</span>;   <span class="comment">//计算各出口距离出口1的距离 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;M);</span><br><span class="line">		<span class="keyword">while</span>(M--)&#123;</span><br><span class="line">			<span class="keyword">int</span> d1,d2;  <span class="comment">//正向反向距离 </span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			d1=<span class="built_in">abs</span>(dist[b]-dist[a]);   <span class="comment">//计算正向距离 </span></span><br><span class="line">			d2=<span class="built_in">circle</span>-d1;     <span class="comment">//反向距离=周长-正向距离 </span></span><br><span class="line">			<span class="keyword">if</span>(d1&gt;d2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d2);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-日期差值"><a href="#6-日期差值" class="headerlink" title="6. 日期差值"></a>6. 日期差值</h2><p><strong>题目描述</strong><br>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。</p>
<p><strong>输入</strong><br>有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD</p>
<p><strong>输出</strong><br>每组数据输出一行，即日期差值</p>
<p><strong>样例输入</strong><br>20130101<br>20130105<br><strong>样例输出</strong><br>5<br><strong>思路</strong></p>
<blockquote>
<p>①首先求出每个日期到公元1年1月1日的天数days1和days2，则days2-days1+1即为所求。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ </span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为闰年 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (((y%<span class="number">4</span>==<span class="number">0</span>) &amp;&amp; (y%<span class="number">100</span>!=<span class="number">0</span>)) || (y%<span class="number">400</span>==<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算任意日期距离公元1年1月1日的天数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysFromFirstYear</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> days=<span class="number">0</span>,i=<span class="number">1</span>,j=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//累加年 </span></span><br><span class="line">	<span class="keyword">for</span>(;i&lt;y;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=<span class="number">366</span>;</span><br><span class="line">		<span class="keyword">else</span> days+=<span class="number">365</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加月 </span></span><br><span class="line">	<span class="keyword">for</span>(;j&lt;m;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=month[j][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> days+=month[j][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加日</span></span><br><span class="line">	days+=(d-k+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> days;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> y1,m1,d1,y2,m2,d2;</span><br><span class="line">	<span class="keyword">int</span> date1,date2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d\n%d"</span>,&amp;date1,&amp;date2)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">if</span>(date1&gt;date2)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=date1;</span><br><span class="line">			date1=date2;</span><br><span class="line">			date2=temp;</span><br><span class="line">		&#125;</span><br><span class="line">		y1=date1/<span class="number">10000</span>,m1=date1%<span class="number">10000</span>/<span class="number">100</span>,d1=date1%<span class="number">10000</span>%<span class="number">100</span>;</span><br><span class="line">		y2=date2/<span class="number">10000</span>,m2=date2%<span class="number">10000</span>/<span class="number">100</span>,d2=date2%<span class="number">10000</span>%<span class="number">100</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> days1,days2;</span><br><span class="line">		days1=daysFromFirstYear(y1,m1,d1);</span><br><span class="line">		days2=daysFromFirstYear(y2,m2,d2);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,days2-days1+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Day-of-Week"><a href="#7-Day-of-Week" class="headerlink" title="7. Day of Week"></a>7. Day of Week</h2><p><strong>题目描述</strong><br>We now use the Gregorian style of dating in Russia. The leap years are years with number divisible by 4 but not divisible by 100, or divisible by 400.<br>For example, years 2004, 2180 and 2400 are leap. Years 2004, 2181 and 2300 are not leap.<br>Your task is to write a program which will compute the day of week corresponding to a given date in the nearest past or in the future using today’s agreement about dating.</p>
<p><strong>输入</strong><br>There is one single line contains the day number d, month name M and year number y(1000≤y≤3000). The month name is the corresponding English name starting from the capital letter.</p>
<p><strong>输出</strong><br>Output a single line with the English name of the day of week corresponding to the date, starting from the capital letter. All other letters must be in lower case.</p>
<p><strong>样例输入</strong><br>21 December 2012<br>5 January 2013<br><strong>样例输出</strong><br>Friday<br>Saturday<br><strong>思路</strong></p>
<blockquote>
<p>①存储闰年平年天数int month[13][2]、英文月份char monthToNum[13][20]以及英文星期char numToWeek[8][20]，<font color=Crmison>注意!格里高利纪元中公元1年1月1日为星期一;</font><br>②计算给定日期距离1年1月1日天数days;<br>③numToWeek[days%7]即为所求。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储平年和闰年的每个月的天数；1，3，5，7，8，10，腊，31天永不差！ </span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">		&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储月份英文名称和罗马数字的关系</span></span><br><span class="line"><span class="keyword">char</span>  monthToNum[<span class="number">13</span>][<span class="number">20</span>]=&#123;<span class="string">" "</span>,<span class="string">"January"</span>,<span class="string">"February"</span>,<span class="string">"March"</span>,<span class="string">"April"</span>,<span class="string">"May"</span>,<span class="string">"June"</span>,</span><br><span class="line">			<span class="string">"July"</span>,<span class="string">"August"</span>,<span class="string">"September"</span>,<span class="string">"October"</span>,<span class="string">"November"</span>,<span class="string">"December"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储星期英文名称,格里高利纪年法的公元1年1月1日是星期天，注意星期的排列顺序！ </span></span><br><span class="line"><span class="keyword">char</span> numToWeek[<span class="number">8</span>][<span class="number">20</span>]=&#123;<span class="string">"Sunday"</span>,<span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>,<span class="string">"Wednesday"</span>,<span class="string">"Thursday"</span>,<span class="string">"Friday"</span>,<span class="string">"Saturday"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断是否为闰年 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (((y%<span class="number">4</span>==<span class="number">0</span>) &amp;&amp; (y%<span class="number">100</span>!=<span class="number">0</span>)) || (y%<span class="number">400</span>==<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算任意日期距离公元1年1月1日的天数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysFromFirstYear</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> days=<span class="number">0</span>,i=<span class="number">1</span>,j=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//累加年 </span></span><br><span class="line">	<span class="keyword">for</span>(;i&lt;y;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=<span class="number">366</span>;</span><br><span class="line">		<span class="keyword">else</span> days+=<span class="number">365</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加月 </span></span><br><span class="line">	<span class="keyword">for</span>(;j&lt;m;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isLeapYear(i)) days+=month[j][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> days+=month[j][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//累加日</span></span><br><span class="line">	days+=(d-k+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> days;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> d,m,y;</span><br><span class="line">	<span class="keyword">char</span> mon[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>,&amp;d,mon,&amp;y)!=EOF)&#123;</span><br><span class="line">		<span class="comment">//获取英文月份的罗马数字 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(monthToNum[i],mon)==<span class="number">0</span>)&#123;</span><br><span class="line">				m=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> days=daysFromFirstYear(y,m,d);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,numToWeek[days%<span class="number">7</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-进制转换"><a href="#8-进制转换" class="headerlink" title="8. 进制转换"></a>8. 进制转换</h2><p><strong>题目描述</strong><br>将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。</p>
<p><strong>输入</strong><br>多组数据，每行为一个长度不超过30位的十进制非负整数。<br>（注意是10进制数字的个数可能有30个，而非30bits的整数）</p>
<p><strong>输出</strong><br>每行输出对应的二进制数。</p>
<p><strong>样例输入</strong><br>985<br>211<br>1126<br><strong>样例输出</strong><br>1111011001<br>11010011<br>10001100110<br><strong>思路</strong></p>
<blockquote>
<p>①输入超过整型可存储范围，使用字符数组模拟除法过程和判断是否为0过程。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟十进制除法，返回余数 </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">divideBy2</span><span class="params">(<span class="keyword">char</span> number[],<span class="keyword">char</span> result[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(number);i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=number[i]-<span class="string">'0'</span>;</span><br><span class="line">		sum=sum*<span class="number">10</span>+temp;</span><br><span class="line">		result[num++]=sum/<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">		sum=sum%<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	result[num]=<span class="string">'\0'</span>; </span><br><span class="line">	<span class="keyword">return</span> sum+<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串转为十进制是否为0 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">char</span> number[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(number);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(number[i]!=<span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="built_in">strlen</span>(number)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//输入超过整型可存储范围，使用字符数组模拟除法过程 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> number[<span class="number">35</span>];</span><br><span class="line">	<span class="keyword">char</span> result[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> left[<span class="number">100</span>]; <span class="comment">//定义商和余数 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,number)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			left[num++]=divideBy2(number,result);</span><br><span class="line">			<span class="built_in">strcpy</span>(number,result);</span><br><span class="line">		&#125;<span class="keyword">while</span>(!isZero(number));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">"%c"</span>,left[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeup和PAT刷题记录——算法初步</title>
    <url>/2020/05/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>记录刷题过程中遇到的问题和技巧。</p>
<h1 id="一、技巧总结"><a href="#一、技巧总结" class="headerlink" title="一、技巧总结"></a>一、技巧总结</h1><h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h2><h3 id="1-1-简单选择排序"><a href="#1-1-简单选择排序" class="headerlink" title="1.1 简单选择排序"></a>1.1 简单选择排序</h3><p>总共进行n趟操作，每趟选出A[i，n]中最小的元素与A[i]交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[k])</span><br><span class="line">                k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=A[i];</span><br><span class="line">        A[i]=A[k];</span><br><span class="line">        A[k]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-直接插入排序"><a href="#1-2-直接插入排序" class="headerlink" title="1.2 直接插入排序"></a>1.2 直接插入排序</h3><p>总共进行n-1趟，每趟将A[i]插入A[i-1,1]中合适位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;A[j])</span><br><span class="line">                A[j]=A[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        A[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-C-标准模板库中的sort"><a href="#1-3-C-标准模板库中的sort" class="headerlink" title="1.3 C++标准模板库中的sort()"></a>1.3 C++标准模板库中的sort()</h3><p>由于c语言中的qsort函数涉及很多指针操作，且std中的sort()在实现中规避了经典快速排序中可能出现的导致实际时间复杂度退化到O(n<sup>2</sup>)的极端情况。使用C++头文件需要添加std的命名空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数cmp(非必填，默认递增排序)) <span class="comment">//注意序列中的元素一定要有可比性才可以不写cmp函数，否则需指定cmp比较规则，例如结构体。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型数组的排序 int double ...</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">6</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line">sort(A,A+<span class="number">4</span>,cmp); <span class="comment">//将A[0]-A[3]从大到小排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;    <span class="comment">//若x不等，按x从大到小排序，否则按y从小到大排序。</span></span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y &lt; b.y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcmp</span>(a.name,b.name)&lt;<span class="number">0</span>; <span class="comment">//表示a.name字典序小于b.name的字典序。&lt;font color=Crmison&gt;注意！strcmp返回值不一定是-1或+1,故==-1写法错误。&lt;/font&gt;</span></span><br><span class="line">sort(ssd,ssd+<span class="number">3</span>,cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器的排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vi.push_back(<span class="number">3</span>);</span><br><span class="line">....<span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b;&#125;  <span class="comment">//vector中类型为int型</span></span><br><span class="line">sort(vi.<span class="built_in">begin</span>,vi.<span class="built_in">end</span>,cmp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str[<span class="number">3</span>]=&#123;<span class="string">"bbbb"</span>,<span class="string">"cc"</span>,<span class="string">"aaa"</span>&#125;;</span><br><span class="line">str[<span class="number">0</span>]&gt;str[<span class="number">1</span>];  <span class="comment">//true,c++中string之间可直接比较大小。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span></span>&#123;<span class="keyword">return</span> str1.length &lt; str2.length;&#125; <span class="comment">//按字符串长度递增排序</span></span><br><span class="line">sort(str,str+<span class="number">3</span>);</span><br><span class="line">sort(str,str+<span class="number">3</span>,cmp);</span><br></pre></td></tr></table></figure>
<h3 id="1-4-排名的实现"><a href="#1-4-排名的实现" class="headerlink" title="1.4 排名的实现"></a>1.4 排名的实现</h3><p>分数不同排名不同，分数相同排名相同但占用一个排位：<br>先排序：<br>思路1：将排名这一项添加到结构体中进行记录，若当前个体分数等于上一个个体则排名等于上一个个体排名，否则当前个体排名等于数组下标+1。<br>思路2：不记录进结构体，直接输出排名。</p>
<h2 id="2-散列"><a href="#2-散列" class="headerlink" title="2. 散列"></a>2. 散列</h2><h3 id="2-1-散列的定义"><a href="#2-1-散列的定义" class="headerlink" title="2.1 散列的定义"></a>2.1 散列的定义</h3><p>有些算法题消耗时间很长，需要利用空间换时间的策略，如将输入的数字作为数组下标来统计这个数出现的次数，而输入的数不一定为整数，且有可能出现冲突，即输入多个相同的数，这时就需要用到散列的策略。<br>定义：将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素。可使用C++标准模板库中的map或reordered_mp直接使用整数hash的功能。散列常应用在查找某个字符串或数字是否出现或出现的次数。</p>
<h3 id="2-2-整数散列"><a href="#2-2-整数散列" class="headerlink" title="2.2 整数散列"></a>2.2 整数散列</h3><p>其中直接定址法、平方取中法、除留余数法为散列方法；线性探查法(开放定址法)、平方探查法(开放定址法)、链地址法(拉链法)为解决冲突的方法。</p>
<h4 id="2-2-1-直接定址法"><a href="#2-2-1-直接定址法" class="headerlink" title="2.2.1 直接定址法"></a>2.2.1 直接定址法</h4><p>H(key)=key<br>H(key)=a*key+b</p>
<h4 id="2-2-2-平方取中法"><a href="#2-2-2-平方取中法" class="headerlink" title="2.2.2 平方取中法"></a>2.2.2 平方取中法</h4><p>取key的平方的中间若干位作为hash值，很少用。</p>
<h4 id="2-2-3-除留余数法"><a href="#2-2-3-除留余数法" class="headerlink" title="2.2.3 除留余数法"></a>2.2.3 除留余数法</h4><p>为最常用方法。<br>H(key)=key%mod<br>该方法可将一个较大的数变为可行的数组下标。<br>表长TSize必须不小于mod，否则越界，一般取TSize=mod，且mod取素数可有效避免冲突。</p>
<h4 id="2-2-4-线性探查法"><a href="#2-2-4-线性探查法" class="headerlink" title="2.2.4 线性探查法"></a>2.2.4 线性探查法</h4><p>若H(key)位置被占用，则检查H(key)+1，H(key)+2,…，直到找到一个没被占用的位置，若超过了表长则回到表的首位继续循环查找。此方法容易出现扎堆现象，即表中连续若干个位置都被使用，一定程度上会降低效率。</p>
<h4 id="2-2-5-平方探查法"><a href="#2-2-5-平方探查法" class="headerlink" title="2.2.5 平方探查法"></a>2.2.5 平方探查法</h4><ul>
<li>该方法可避免扎堆现象。</li>
<li>若H(key)位置被占用，则检查H(key)+1<sup>2</sup>，H(key)-1<sup>2</sup>,H(key)+2<sup>2</sup>,H(key)-2<sup>2</sup>…，直到找到一个没被占用的位置，也可只进行正向平方探查。</li>
<li>若超过了表长则计算(H(key)+k<sup>2</sup>)%mod。</li>
<li>若H(key)-k<sup>2</sup>&lt;0,则计算((H(key)-k<sup>2</sup>)%TSize+TSize)%TSize;相当于将H(key)-k<sup>2</sup>不断加上TSize直到出现第一个非负数。</li>
<li>可证明，若k在[0，TSize)范围内都无法找到位置，那么当k&gt;=TSize时也一定无法找到位置。</li>
</ul>
<h4 id="2-2-6-链地址法（拉链法）"><a href="#2-2-6-链地址法（拉链法）" class="headerlink" title="2.2.6 链地址法（拉链法）"></a>2.2.6 链地址法（拉链法）</h4><p>设定一个数组链表，Link[0]-Link[mod-1],用Link[h]将所有H(key)=h的key链接起来。<br><font color=Crmison>注意！以上方法一般都无需自己实现，除非必须模拟这些算法或提升效率，否则都可以直接使用标准模板库中的map函数来直接使用hash功能，C++11以后可以用unordered_map，速度更快。</font></p>
<h3 id="2-3-字符串hash初步"><a href="#2-3-字符串hash初步" class="headerlink" title="2.3 字符串hash初步"></a>2.3 字符串hash初步</h3><p>利用其它进制转换为10进制的策略，仅限字符串长度不是很长的情况。</p>
<ul>
<li>若字符串均由大写字母构成：将26个大写字母视为26进制，转换为10进制。</li>
<li>若出现了小写字母，则将A-Z作为0—25,将a-z作为26-51(例如a-‘a’+26)，共52进制，转换为10进制。</li>
<li>若出现了数字，则可按照小写字母的处理方法增大进制数至62。</li>
<li>若能保证字符串末尾是数字则可将末尾的数字直接拼接上去。</li>
<li><font color=Crmison>ASCII码的hash值可用 字符-‘\0’ 计算，因为’\0’的ASCII码值为0。</font></li>
</ul>
<h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h2><h3 id="3-1-分治"><a href="#3-1-分治" class="headerlink" title="3.1 分治"></a>3.1 分治</h3><p>分治法三个步骤：</p>
<ul>
<li><strong>分解</strong>：将原问题分解为若干与原问题拥有相同或相似结构的子问题。<font color=Crmison>子问题应当互相独立、没有交叉，否则不能使用分治法。</font></li>
<li><strong>解决</strong>：递归求解所有子问题。</li>
<li><strong>合并</strong>：将子问题的解合并为原问题的解。<br>当子问题个数为1时，称为减治，如求n!,大于1则称为分治，如求Fibonacci数列。分治法既可以用递归手段也可用非递归手段去实现。</li>
</ul>
<h3 id="3-2-递归"><a href="#3-2-递归" class="headerlink" title="3.2 递归"></a>3.2 递归</h3><p>递归很适合用来实现分治思想。</p>
<h4 id="3-2-1-递归的三要素"><a href="#3-2-1-递归的三要素" class="headerlink" title="3.2.1 递归的三要素"></a>3.2.1 递归的三要素</h4><p>出自<a href="https://www.zhihu.com/question/31412436/answer/683820765?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=697560822683041792&amp;utm_content=sec的讲解" target="_blank" rel="noopener">https://www.zhihu.com/question/31412436/answer/683820765?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=697560822683041792&amp;utm_content=sec的讲解</a></p>
<ul>
<li><strong>明确函数想要做的事情(函数功能)。</strong></li>
<li><strong>寻找递归结束条件，避免程序一直调用自己，进入无底洞(递归边界)。</strong><br>需要找出当参数为什么时，递归结束，即能直接知道函数的结果，结束后需要返回或输出结果。</li>
<li><strong>找出函数的等价关系式(递归式、递归调用)</strong>。<br>最难也是最关键的一步。需要不断缩小参数的范围，且缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。<font color=Crmison>注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。这些条件一旦漏掉可能会导致死循环。</font></li>
</ul>
<h4 id="3-2-2-求n"><a href="#3-2-2-求n" class="headerlink" title="3.2.2 求n!"></a>3.2.2 求n!</h4><ul>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求n的阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于0！=1，不妨将f(0)=1作为递归边界</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f(n)这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1)*n。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-求Fibonacci数列的第n项"><a href="#3-2-3-求Fibonacci数列的第n项" class="headerlink" title="3.2.3 求Fibonacci数列的第n项"></a>3.2.3 求Fibonacci数列的第n项</h4></li>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求Fibonacci的第n项，1、1、2、3、5、8、13、21、34....</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显然f(1)=f(2)=1,故可设置递归边界为n&lt;=2。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//观察数列可轻易得到等价关系为f(n)=f(n-1)+f(n-2),</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-小青蛙跳台阶"><a href="#3-2-3-小青蛙跳台阶" class="headerlink" title="3.2.3 小青蛙跳台阶"></a>3.2.3 小青蛙跳台阶</h4>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求青蛙跳上一个n级的台阶总共有多少种跳法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少。显然f(n)=1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次跳的时候，小青蛙有两种跳法。即跳一个台阶或跳两个台阶。</span></span><br><span class="line"><span class="comment">//第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。</span></span><br><span class="line"><span class="comment">//第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。</span></span><br><span class="line"><span class="comment">//所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	ruturn f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-反转单链表"><a href="#3-2-4-反转单链表" class="headerlink" title="3.2.4 反转单链表"></a>3.2.4 反转单链表</h4><img src="1.png" alt="1"><br>例如链表为：1-&gt;2-&gt;3-&gt;4。反转后为 4-&gt;3-&gt;2-&gt;1<br>链表节点定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第一步，明确函数的功能<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转单链表，其中 head 表示链表的头节点。</span></span><br><span class="line"><span class="function">Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接把链表压缩到只有一个节点和空表分析，若为空表或只有头节点存在则直接返回head节点。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverseList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null || head.next == null)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式</li>
</ul>
<ol>
<li>首先缩小范围分析，对2-&gt;3-&gt;4反转得到4-&gt;3-&gt;2并将递归的结果用一个新节点newList保存起来。1 这个节点我们并没有去碰它，所以1的 next 节点仍然是连接着2。<br><img src="2.png" alt="2"></li>
<li>接下来只需要把节点 2 的 next 指向 1，然后把 1 的 next 指向 null即完成了反转。<br><img src="3.png" alt="3"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverseList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1.递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) &#123;</span><br><span class="line">             <span class="keyword">return</span> head;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 递归反转 子链表</span></span><br><span class="line">         Node newList = reverseList2(head.next);</span><br><span class="line">         <span class="comment">// 改变 1，2节点的指向。</span></span><br><span class="line">         <span class="comment">// 通过 head.next获取节点2</span></span><br><span class="line">         Node t1  = head.next;</span><br><span class="line">         <span class="comment">// 让 2 的 next 指向 2</span></span><br><span class="line">         t1.next = head;</span><br><span class="line">         <span class="comment">// 1 的 next 指向 null.</span></span><br><span class="line">        head.next = null;</span><br><span class="line">        <span class="comment">// 把调整之后的链表返回。</span></span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-5-递增输出n个数的全排列"><a href="#3-2-5-递增输出n个数的全排列" class="headerlink" title="3.2.5 递增输出n个数的全排列"></a>3.2.5 递增输出n个数的全排列</h4></li>
</ol>
<ul>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按从小到大输出1-n的全排列，即为每一位填入一个从1-n枚举的不重复的数字</span></span><br><span class="line"><span class="comment">//P为当前排列，hashTable记录整数x是否已经在当前排列中，即P中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ptintf(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式</li>
</ul>
<ol>
<li>首先处理index节点，枚举1-n，将第一个还未填入P中的值x填入P[index]中，并记录hashTable[x]=true。</li>
<li>接下来只需要处理下一个位置，即generateP(index+1);</li>
<li>当处理完p[index]=x的子问题后，还原hashTable[x]=false;<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出从1-n的全排列，从index开始填</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ptintf(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举1-n，将x填入P[index]位置。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=index;x&lt;=n;x++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">			P[index]=x;</span><br><span class="line">			hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">			generateP(index+<span class="number">1</span>);</span><br><span class="line">			hashTable[x]=<span class="literal">false</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-6-n皇后问题"><a href="#3-2-6-n皇后问题" class="headerlink" title="3.2.6 n皇后问题"></a>3.2.6 n皇后问题</h4></li>
</ol>
<ul>
<li>第一步，明确函数的功能<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个n*n棋盘上放置n个皇后使其两两均不在同一行、同一列、同一条对角线上，求合法方案数。</span></span><br><span class="line"><span class="comment">//考虑每行和没每列均只能放置一个皇后，问题归结为求全排列中的合法放置方案数，即求全排列中两两不在同一对角线的方案并统计。</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步，寻找递归结束条件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从第一位开始填入数字，直到处理完最后一位即index+1位时输出当前排列</span></span><br><span class="line"><span class="comment">//判断当前方案是否合法有两种方式，暴力法和回溯法</span></span><br><span class="line"><span class="comment">//暴力法：在每一次递归边界遍历任两个皇后，判断是否在同一条对角线</span></span><br><span class="line"><span class="comment">//回溯法：每次处理第index位时，遍历之前的皇后检查是否有冲突，若有冲突，则无需继续处理之后的位置，直接返回上一层即可。</span></span><br><span class="line"><span class="comment">//回溯法比暴力法效率要高。</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;   <span class="comment">//能到达递归边界的方案一定是合法方案</span></span><br><span class="line">        count++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，找出函数的等价关系式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;   <span class="comment">//能到达递归边界的方案一定是合法方案</span></span><br><span class="line">        count++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举1-n，将x填入P[index]位置。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">true</span>;  <span class="comment">//true表示不会冲突</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)&#123; <span class="comment">//</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">				P[index]=x;</span><br><span class="line">				hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">				generateP(index+<span class="number">1</span>);</span><br><span class="line">				hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-7-递归的优化"><a href="#3-2-7-递归的优化" class="headerlink" title="3.2.7 递归的优化"></a>3.2.7 递归的优化</h4></li>
</ul>
<p><strong>记录重复计算的子问题</strong><br>递归有时候是会产生大量重复计算的，例如求Fibonacci的第n项，例如f(5)=f(4)+f(3)，而f(4)会重复计算f(3)，优化时可保存下来已经被计算过的子问题即arr[n]=f(n),若未计算过，则置arr[n]=-1。在递归时判断一下是否计算过，若计算过则直接取出结果即可，否则再进行递归计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断有没计算过</span></span><br><span class="line">    <span class="keyword">if</span>(arr[n] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//计算过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没有计算过，递归计算,并且把结果保存到 arr数组里</span></span><br><span class="line">        arr[n] = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>考虑是否可以递推实现</strong><br>递归往往都是自上往下递归的，直到递归到最底，再一层一层把值返回。但是当n比较大的时候栈空间可能会不够。这时候可以考虑自底向上的做法，这种做法被称为<strong>递推</strong>。例如Fibonacci数列的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> n;</span><br><span class="line">       <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> f2 = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           sum = f1 + f2;</span><br><span class="line">           f1 = f2;</span><br><span class="line">           f2 = sum;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-贪心"><a href="#4-贪心" class="headerlink" title="4. 贪心"></a>4. 贪心</h2><h3 id="4-1-简单贪心"><a href="#4-1-简单贪心" class="headerlink" title="4.1 简单贪心"></a>4.1 简单贪心</h3><p>总是考虑当前状态下局部最优解，来使全局的结果达到最优。</p>
<h3 id="4-2-开区间不相交问题"><a href="#4-2-开区间不相交问题" class="headerlink" title="4.2 开区间不相交问题"></a>4.2 开区间不相交问题</h3><p><strong>题目描述</strong><br>给出n个开区间(x,y)，计算最多可以选择多少个区间，使得这些开区间两两没有交集。<br><strong>输入</strong><br>输入第一行为n表示n个开区间，第二行n个开区间对(x,y)。<br><strong>输出</strong><br>输出1行为方案个数。<br><strong>样例输入</strong><br>4<br>2 4 1 3 3 5 6 7<br><strong>样例输出</strong><br>3<br><strong>思路</strong></p>
<blockquote>
<p>按左端点从大到小排序，若左端点相同则按右端点从小到大排序<br> lastX记录上一个被选区间的左端点。<br> 若当前区间的右端点在上一个区间左端点的左边<font color=Crmison>(&lt;=)</font>则方案数+1</p>
</blockquote>
<h3 id="4-3-闭区间选点问题"><a href="#4-3-闭区间选点问题" class="headerlink" title="4.3 闭区间选点问题"></a>4.3 闭区间选点问题</h3><p><strong>题目描述</strong><br>给出n个闭区间[x,y]，计算最少需要确定多少个点，使得这些闭区中都至少存在一个点。<br><strong>输入</strong><br>输入第一行为n表示n个开区间，第二行n个闭区间对[x,y]。<br><strong>输出</strong><br>输出1行为方案个数。<br><strong>样例输入</strong><br>3<br>1 4 2 6 5 7<br><strong>样例输出</strong><br>2<br><strong>思路</strong></p>
<blockquote>
<p>按左端点从大到小排序，若左端点相同则按右端点从小到大排序<br> lastX记录上一个被选区间的左端点。<br> 若当前区间的右端点在上一个区间左端点的左边<font color=Crmison>(&lt;)</font>则方案数+1</p>
</blockquote>
<h1 id="二、经典题目"><a href="#二、经典题目" class="headerlink" title="二、经典题目"></a>二、经典题目</h1><h2 id="2-1-问题-B-分组统计"><a href="#2-1-问题-B-分组统计" class="headerlink" title="2.1 问题 B: 分组统计"></a>2.1 问题 B: 分组统计</h2><p><strong>题目描述</strong><br>先输入一组数，然后输入其分组，按照分组统计出现次数并输出，参见样例。<br><strong>输入</strong><br>输入第一行表示样例数m，对于每个样例，第一行为数的个数n，接下来两行分别有n个数，第一行有n个数，第二行的n个数分别对应上一行每个数的分组，n不超过100。<br><strong>输出</strong><br>输出m行，格式参见样例，按从小到大排。<br><strong>样例输入</strong><br>1<br>7<br>3 2 3 8 8 2 3<br>1 2 3 2 1 3 1<br><strong>样例输出</strong><br>1={2=0,3=2,8=1}<br>2={2=1,3=0,8=1}<br>3={2=1,3=1,8=0}<br><strong>思路</strong></p>
<ul>
<li>利用一个二维矩阵A[i][j]记录数字j在组别i中出现的次数</li>
<li>flagS[j]和flagG[i]分别记录数字j和组别i是否出现，这里容易出错 </li>
<li>找出最大组别编号和最大数字，若组号i和数字j均存在，则输出result[i][j]</li>
<li><font color=Crmison>易错点:组号i小于n，但样例数大小j范围未知，二维数组的第二维应初始化大一些，否则容易错误50%</font><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);	</span><br><span class="line">			<span class="comment">//在循环内部定义数组就无须初始化为0了 </span></span><br><span class="line">			<span class="keyword">int</span> sample[<span class="number">110</span>]=&#123;&#125;,flagS[<span class="number">2010</span>]=&#123;&#125;,group[<span class="number">110</span>]=&#123;&#125;,flagG[<span class="number">110</span>]=&#123;&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> maxs=<span class="number">0</span>,maxg=<span class="number">0</span>; <span class="comment">//找出最大样例和最大组别，方便输出。 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,sample+i);</span><br><span class="line">				<span class="keyword">if</span>(sample[i]&gt;maxs) maxs=sample[i];</span><br><span class="line">				flagS[sample[i]]=<span class="number">1</span>; </span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> result[<span class="number">110</span>][<span class="number">2010</span>]=&#123;&#125;;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,group+i);</span><br><span class="line">				<span class="keyword">if</span>(group[i]&gt;maxg) maxg=group[i];</span><br><span class="line">				flagG[group[i]]=<span class="number">1</span>;</span><br><span class="line">				<span class="comment">//记录统计结果 </span></span><br><span class="line">				result[group[i]][sample[i]]++; </span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			<span class="comment">//输出统计结果 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxg;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(flagG[i]==<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d=&#123;"</span>,i);</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxs;j++)&#123;</span><br><span class="line">						<span class="keyword">if</span>(flagS[j]==<span class="number">1</span>)&#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">"%d=%d"</span>,j,result[i][j]);</span><br><span class="line">							<span class="keyword">if</span>(j&lt;maxs) <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);	</span><br><span class="line">				&#125; 		</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>算法复杂度和黑盒测试</title>
    <url>/2020/04/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>了解算法复杂度很重要，我们在编写算法时常常要注意算法复杂度以避免出现程序运行超时的结果，此外，了解常用OJ的黑盒测试方法也有助于编写正确高效的算法。本篇简单介绍了三种算法复杂度和黑盒测试的代码写法，并简单罗列了OJ在判定时出现的一些结果，以便找到出错原因。</p>
<h1 id="一、算法复杂度"><a href="#一、算法复杂度" class="headerlink" title="一、算法复杂度"></a>一、算法复杂度</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>时间复杂度是算法执行基本运算(如加减乘除)的次数所处的等级，是评判算法时间效率的有效标准，较高的时间复杂度会让评测系统返回“运行超时”，<font color=Crmison>对一般的OJ系统来说，一秒能承受的运算次数大概是10<sup>7</sup>至10<sup>8</sup>。</font></p>
<blockquote>
<ol>
<li>讲时间复杂度是不带系数的，称为时间复杂度常数，例如基本运算次数为cn,cn<sup>2</sup>，则时间复杂度分别为O(n)，O(n<sup>2</sup>)。</li>
<li>高等级的幂次会覆盖低等级的幂次，因此O(3n<sup>2</sup>+n+2)=O(n<sup>2</sup>)。</li>
<li>当某些算法实现较为复杂时，其常数会比较大，这时即使时间复杂度相同其性能也会有较大差距。</li>
<li>不同级别时间复杂度比较：O(1)&lt;O(logn)&lt;O(n)&lt;O(n<sup>2</sup>)。</li>
</ol>
</blockquote>
<h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>空间复杂度和时间复杂度的写法相同，表示算法需要消耗的最大数据空间。一般来说空间都是足够使用的，只要不开好几个10<sup>7</sup>以上的数组，<font color=Crmison>故一般会使用以空间换时间的算法策略。</font></p>
<h2 id="3-编码复杂度"><a href="#3-编码复杂度" class="headerlink" title="3. 编码复杂度"></a>3. 编码复杂度</h2><p>编码复杂度是一个定性的概念，没有一个量化标准，就是指代码的冗长程度。如果使用了冗长的算法思想则编码复杂度就会很大。</p>
<h1 id="二、黑盒测试"><a href="#二、黑盒测试" class="headerlink" title="二、黑盒测试"></a>二、黑盒测试</h1><p>OJ后台会准备若干组数据(一般是放在一个文件里)让程序运行，并将运行结果在字符串意义上进行比较，若完全相同，则称通过了本题的黑盒测试，否则返回不同判定结果，根据黑盒测试对每组数据单独测试还是一次性全部测试，分为单点和多点测试。</p>
<h2 id="1-单点测试"><a href="#1-单点测试" class="headerlink" title="1. 单点测试"></a>1. 单点测试</h2><p>PAT采取的是单点测试，它会对每组数据都给出相应的测评结果，并且每组数据都有得分值，题目总得分等于通过数据得分值之和。所以它仅要求编写的程序能一次运行一组数据，采用普通写法。</p>
<h2 id="2-多点测试"><a href="#2-多点测试" class="headerlink" title="2. 多点测试"></a>2. 多点测试</h2><p>大部分OJ如Codeup等都是采用多点测试，它要求编写的程序能够一次性运行所有的数据，并要求所有输出结果都必须完全正确才算通过测试，故需要用到循环结构。多点测试能够考验算法编写的严谨性。题目一般会有3种输入格式，需要采取不同的输入方式。</p>
<blockquote>
<p>三种输入类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环输入直到文件末尾</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">    ...<span class="comment">//scanf返回值为成功读入的参数个数，当读取文件到达末尾时才会读取失败，此时返回-1，C语言中用EOF(End Of File)代替-1。</span></span><br><span class="line">    <span class="comment">//在运行框输入数据时并不会触发EOF，需要手动输入&lt;Ctrl+Z&gt;键，再按&lt;Enter&gt;键触发。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str)!=EOF)&#123;...&#125;</span><br><span class="line"><span class="keyword">while</span>(gets(str)!=<span class="literal">NULL</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入直到满足某个条件时退出</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b), a||b)&#123;</span><br><span class="line">    ...<span class="comment">//当a和b中有一个不为零时就进行循环。注意！输入多少数据(&amp;a和&amp;b)，判零条件就有几个(a||b)，否则输入输出的格式会出错。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入题目指定组数的数据</span></span><br><span class="line"><span class="keyword">while</span>(T--)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>另外要<font color=Crmison>注意！多点测试中每一次循环都要重置一下变量和数组(memset函数或fill函数)，否则在下一组数据来临之前变量和数组的状态就不是初始状态了。</font></p>
<h1 id="三、OJ常见评测结果"><a href="#三、OJ常见评测结果" class="headerlink" title="三、OJ常见评测结果"></a>三、OJ常见评测结果</h1><h2 id="1-答案正确-Accepted-AC"><a href="#1-答案正确-Accepted-AC" class="headerlink" title="1. 答案正确(Accepted, AC)"></a>1. 答案正确(Accepted, AC)</h2><p>若为单点测试，则每通过一组数据就会返回一个Accepted,若是多点测试，那么只有当通过了所有数据时，才会返回Accepted。</p>
<h2 id="2-编译错误-Compile-Error-CE"><a href="#2-编译错误-Compile-Error-CE" class="headerlink" title="2. 编译错误(Compile Error, CE)"></a>2. 编译错误(Compile Error, CE)</h2><p>出现这种情况有可能是选错了语言。</p>
<h2 id="3-答案错误-Wrong-Answer-WA"><a href="#3-答案错误-Wrong-Answer-WA" class="headerlink" title="3. 答案错误(Wrong Answer, WA)"></a>3. 答案错误(Wrong Answer, WA)</h2><p>代码逻辑问题或输出的内容有误。</p>
<h2 id="4-运行超时-Time-Limit-Excees-TLE"><a href="#4-运行超时-Time-Limit-Excees-TLE" class="headerlink" title="4. 运行超时(Time Limit Excees, TLE)"></a>4. 运行超时(Time Limit Excees, TLE)</h2><p>一般来说，导致该结果是由于算法的时间复杂度导致的，也可能是某组数据使得代码某处死循环了。</p>
<h2 id="5-运行错误-Runtime-Error-RE"><a href="#5-运行错误-Runtime-Error-RE" class="headerlink" title="5. 运行错误(Runtime Error, RE)"></a>5. 运行错误(Runtime Error, RE)</h2><p>段错误(非法访问内存，如数组越界、指针乱指)、浮点错误(例如除数为0、模数为0)、递归爆栈(一般由于递归层数过深)。</p>
<h2 id="6-内存超限-Memory-Limit-Exceeded-MLE"><a href="#6-内存超限-Memory-Limit-Exceeded-MLE" class="headerlink" title="6. 内存超限(Memory Limit Exceeded, MLE)"></a>6. 内存超限(Memory Limit Exceeded, MLE)</h2><p>如果程序使用太多空间，例如数组太大可能会导致此结果。</p>
<h2 id="7-格式错误-Presentation-Error-PE"><a href="#7-格式错误-Presentation-Error-PE" class="headerlink" title="7. 格式错误(Presentation Error, PE)"></a>7. 格式错误(Presentation Error, PE)</h2><p>多输出了空格或换行。</p>
<h2 id="8-输出超限-Output-Limit-Exceeded-OLE"><a href="#8-输出超限-Output-Limit-Exceeded-OLE" class="headerlink" title="8. 输出超限(Output Limit Exceeded, OLE)"></a>8. 输出超限(Output Limit Exceeded, OLE)</h2><p>输出了过量的内容，如大量调试信息或者特殊数据导致的死循环。</p>
]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C和C++的常用语法</title>
    <url>/2020/04/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/C%E5%92%8CC++%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在算法机试中，最适合使用的就是C语言和C++语言，C++可以向下兼容C，且其基本语法除了输入输出部分，其余顺序结构、循环结构、数组、指针都是几乎一样的。C++中的cin和cout消耗时间比C中的scanf和printf多得多，而C中有一些不太顺手的设定可以使用C++来取代，故我们在机试时通常选择C++的编译器，而混用C和C++的语法来优化算法。本篇简单介绍一下机试中常用的C/C++基本语法。</p>
<h1 id="一、C程序的组成"><a href="#一、C程序的组成" class="headerlink" title="一、C程序的组成"></a>一、C程序的组成</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件"></a>1.头文件</h2><p><code>#include &lt;stdio.h&gt;</code>即是头文件，用来添加程序中需要使用到的库函数，其中<code>stdio.h</code>是标准输入输出库，是一个.h格式的文件，其中包含了一些与输入输出有关的东西，其他功能的库文件还有<code>math.h</code>，负责数学函数,<code>string.h</code>负责字符串相关函数，等等。当我们需要用到这些库函数时就必须将其头文件include起来。此外，C++中的等价写法为<code>#include &lt;csdio&gt;</code>,<code>#include &lt;cmath&gt;</code>,<code>include &lt;cstring&gt;</code>。</p>
<h2 id="2-主函数"><a href="#2-主函数" class="headerlink" title="2.主函数"></a>2.主函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数是一个程序的入口，也就是程序开始执行的地方，一个程序最多只能有一个主函数。<font color=Crimson>注意！请不要在同一个程序中使用cout和printf，有时会出问题。</font></p>
<h1 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h1><h2 id="1-变量的定义"><a href="#1-变量的定义" class="headerlink" title="1. 变量的定义"></a>1. 变量的定义</h2><p><code>变量类型 变量名;</code><br><code>变量类型 变量名 = 初值;</code><br>变量名区分大小写。</p>
<h2 id="2-变量类型"><a href="#2-变量类型" class="headerlink" title="2. 变量类型"></a>2. 变量类型</h2><p><img src="1.png" alt="基本数据类型"></p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><font color=Crimson>短整型(short): </font> 2Byte，机试中一般用不到。<br><font color=Crimson>整型(int): </font> 4Byte,绝对值在10<sup>9</sup>范围内整数都可以定义为Int型。<br><font color=Crimson>长整型(long long): 8Byte,赋值大于2<sup>31</sup>-1的初值，需要在初值后面加上LL，否则编译错误。</font></p>
<h3 id="2-2-浮点型"><a href="#2-2-浮点型" class="headerlink" title="2.2 浮点型"></a>2.2 浮点型</h3><p><font color=Crimson>单精度(float): </font> 有效精度6-7位。<br><font color=Crimson>双精度(double): </font> 有效精度15-16位,因此机试中碰到浮点型一般都是用double来存储。</p>
<blockquote>
<p>浮点数<font>在经过容易损失精度得计算后</font>，计算结果总是不精确得，有一定得误差，故需要引入一个极小数eps来修正误差，从而进行各种比较操作，可以取eps为10<sup>-8</sup>,变量b的浮动范围为[b-eps,b+eps],各种比较操作的宏定义如下：</p>
</blockquote>
<p>a==b:<img src="4.png" alt="a==b"> a&gt;b:<img src="5.png" alt="a&gt;b"> a&lt;b:<img src="6.png" alt="a&lt;b"> a&gt;=b:<img src="7.png" alt="a&gt;=b"> a&lt;=b:<img src="8.png" alt="a&lt;=b"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> db1=<span class="number">4</span>*<span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>);   <span class="comment">//PI的损失精度的计算</span></span><br><span class="line"><span class="keyword">double</span> db2=<span class="number">3</span>*<span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="number">3.0</span>)/<span class="number">2</span>);</span><br><span class="line">db1==db2;  <span class="comment">//flase;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);    <span class="comment">//定义pi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;  <span class="comment">//注意该用括号的地方用括号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Equ(a,b) ((fabs((a)-(b)))&lt;(eps))  <span class="comment">//a==b,不等于可使用!Equ(a,b)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> More(a,b) (((a)-(b))&gt;(eps))   <span class="comment">//a&gt;b</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Less(a,b) (((a)-(b))&lt;(-eps))  <span class="comment">//a&lt;b</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MoreEqu(a,b) (((a)-(b))&gt;(-eps))  <span class="comment">//a&gt;=b</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LessEqu(a,b) (((a)-(b))&lt;(eps))   <span class="comment">//a&lt;=b</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-字符型"><a href="#2-3-字符型" class="headerlink" title="2.3 字符型"></a>2.3 字符型</h3><p><font color=Crimson>字符常量和字符变量: </font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'z'</span>, c2 = <span class="string">'j'</span>, c3 = <span class="number">117</span>;</span><br></pre></td></tr></table></figure>
<p>字符常量统一使用ASCII编码，小写字母比大写字母码值大32。0-9（48-57），A-Z（65-90），a-z（97-122）。<br><font color=Crimson>转义字符: </font>\n（换行）、\t（Tab）、<font color=Crimson>\0（代表空字符NULL，其ASCII码为0，请注意\0不是空格）</font></p>
<p><font color=Crimson>字符串常量: </font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">25</span>]=<span class="string">"wo ai de ren ye ai wo"</span>;</span><br></pre></td></tr></table></figure>
<p>C语言中无基本数据类型可存储字符串常量，只能用字符数组，而C++中有string类型。</p>
<h3 id="2-4-布尔型"><a href="#2-4-布尔型" class="headerlink" title="2.4 布尔型"></a>2.4 布尔型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag1=<span class="number">0</span>, flag2=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>bool在C++中可直接使用，在C中必须添加<code>stdbool.h</code>,但机试选择C++编译器，故可不添加。用整型赋值时true(非零)，false(零)。bool可以%d格式输出0或1。</p>
<h2 id="3-强制类型转换"><a href="#3-强制类型转换" class="headerlink" title="3. 强制类型转换"></a>3. 强制类型转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(新类型名)变量名;</span><br></pre></td></tr></table></figure>
<p>其中(int)f直接将小数部分切掉，即向下取整。在赋值时，编译器可以自动进行转换，但在计算过程中需要手动强制类型转换。</p>
<h2 id="4-符号常量和const常量-宏定义、宏替换"><a href="#4-符号常量和const常量-宏定义、宏替换" class="headerlink" title="4. 符号常量和const常量(宏定义、宏替换)"></a>4. 符号常量和const常量(宏定义、宏替换)</h2><p><font color=Crimson><code>#define 标识符 常量</code> : </font> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14</span></span><br></pre></td></tr></table></figure>
<p><font color=Crimson><code>const 数据类型 变量名 = 常量;</code> : </font>  推荐方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p><font color=Crimson><code>#define 标识符 任何语句或片段</code> : </font>  不推荐。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># difine ADD(a,b) ((a)+(b))</span></span><br></pre></td></tr></table></figure>
<p>由于宏定义是直接将对应部分替换然后进行编译和运行，故能加括号的地方应添加括号，否则会出现逻辑错误。</p>
<h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h2><p><font color=Crimson>7个常用算术运算符 : </font>  <code>+ - * / % ++ --</code><br><code>+ - * /</code>优先级与四则运算相同， %和/优先级相同，且当/和%的除数为0时会导致程序异常退出或得到错误”1.#INF00”。<br><font color=Crimson>6个关系运算符 : </font> <code>&lt; &gt; &lt;= &gt;= == !=</code><br><font color=Crimson>3个逻辑运算符 : </font> <code>&amp;&amp; || ！</code><br><font color=Crimson>1个条件运算符(c中唯一的三目运算符) : </font> <code>A ? B : C</code><br><font color=Crimson>6个位运算符 : </font> &lt;&lt;(左移) &gt;&gt;(右移) &amp;(位与) |(位或) ^(位异或) ~(位取反)<br>运算符的优先级和结合性参见<a href="https://zh.cppreference.com/w/c/language/operator_precedence" target="_blank" rel="noopener">https://zh.cppreference.com/w/c/language/operator_precedence</a><br>程序中无穷大的数INF的设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br></pre></td></tr></table></figure>
<p>二者等价。</p>
<h1 id="三、顺序结构"><a href="#三、顺序结构" class="headerlink" title="三、顺序结构"></a>三、顺序结构</h1><h2 id="1-赋值表达式"><a href="#1-赋值表达式" class="headerlink" title="1. 赋值表达式"></a>1. 赋值表达式</h2><p>给多个变量赋值，可使用连续等号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">n = m = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>复合赋值运算符<code>+= -= *= /= %=</code>可以加快编译速度，提高代码可读性，故在程序中经常用到。</p>
<h2 id="2-使用C语言中的scanf和printf输入-输出"><a href="#2-使用C语言中的scanf和printf输入-输出" class="headerlink" title="2. 使用C语言中的scanf和printf输入/输出"></a>2. 使用C语言中的scanf和printf输入/输出</h2><h3 id="2-1-scanf-“格式控制”-变量地址"><a href="#2-1-scanf-“格式控制”-变量地址" class="headerlink" title="2.1 scanf(“格式控制”,变量地址)"></a>2.1 scanf(“格式控制”,变量地址)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>,&amp;hh,&amp;mm,&amp;ss);  <span class="comment">//输入hh:mm:ss</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%lf%c"</span>,&amp;a,&amp;b,&amp;c);  <span class="comment">//输入a,b,c</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b); <span class="comment">//输入a b</span></span><br></pre></td></tr></table></figure>
<p>scanf函数的格式控制符如下图所示：<br><img src="2.png" alt="scanf格式控制"></p>
<ol>
<li><p>格式控制和我们在控制台输入的格式一致。</p>
</li>
<li><p>&amp;为取地址符，char数组名本来就是一个地址，故不需要&amp;。</p>
</li>
<li><p><font color=Crmison>除了控制符%c可以读入一个空白符(空格、换行、Tab)以外,scanf的其他格式符的输入均以空白符为结束判断标志。</font></p>
</li>
<li><p>scanf中可以用转义字符，不过一般用不到。</p>
</li>
</ol>
<h3 id="2-2-printf-“格式控制”-变量名称"><a href="#2-2-printf-“格式控制”-变量名称" class="headerlink" title="2.2 printf(“格式控制”, 变量名称)"></a>2.2 printf(“格式控制”, 变量名称)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br></pre></td></tr></table></figure>
<p>printf函数的格式控制符如下图所示：<br><img src="3.png" alt="printf格式控制"></p>
<ol>
<li><p>printf中不使用&amp;。</p>
</li>
<li><p>注意double类型变量scanf的格式符为%lf,printf的格式符为%f。</p>
</li>
<li><p>printf中可使用转义字符\n、\t等。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%%"</span>); <span class="comment">//输出%</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\\"</span>); <span class="comment">//输出\</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>3种实用的输出格式:<blockquote>
<p><strong>%md</strong>    &emsp;使不足m位的int变量以M位右对齐输出，高位空格补齐；若变量本身超过m位则保持原样。<br><strong>%0md</strong>   &nbsp;相比于%md高位补0。<br><strong>%.mf</strong>   &nbsp;使浮点数保留m位小数输出，使用“四舍六入五成双”规则，而不是四舍五入。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>C++中的输入与输出函数cin与cout</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  //string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; //控制double型精度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;db&gt;&gt;c&gt;&gt;str;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;db&lt;&lt;<span class="string">" "</span>&lt;&lt;str&lt;&lt;<span class="string">"haha"</span>&lt;&lt;<span class="string">"\n"</span>&lt;<span class="built_in">endl</span>;  <span class="comment">//"\n"和endl都表示换行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str,<span class="number">100</span>); <span class="comment">//读入一行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;  <span class="comment">//使用C++中的string容器输入一行</span></span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;<span class="number">123.4567</span>&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//控制double型变量输出小数点后两位。</span></span><br></pre></td></tr></table></figure>
<p>cin与cout在输入/输出大量数据的情况下表现得非常糟糕，有时题目中数据还没有输入完毕就已经超时，故还是推荐使用scanf与printf输入与输出。</p>
<h2 id="3-使用getchar和putchar输入-输出字符"><a href="#3-使用getchar和putchar输入-输出字符" class="headerlink" title="3. 使用getchar和putchar输入/输出字符"></a>3. 使用getchar和putchar输入/输出字符</h2><p>getchar用来输入单个字符，注意它能够读入空白符，它经常使用在某些scanf使用不便的场合。putchar用来输出单个字符。</p>
<h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>编译时会自动跳过注释部分，不执行。</p>
<h2 id="5-typedef"><a href="#5-typedef" class="headerlink" title="5. typedef"></a>5. typedef</h2><p>用于给复杂的数据类型起一个别名，用别名代替原来的写法，提高编码效率。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br></pre></td></tr></table></figure>
<h2 id="6-常用math函数"><a href="#6-常用math函数" class="headerlink" title="6. 常用math函数"></a>6. 常用math函数</h2><p><font color=Crmison>除了abs在C编译器中需要添加stdlib.h外，其它数学函数使用时需要添加头文件math.h和cmath。注意!</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">// double型变量取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>; <span class="comment">//int型变量取绝对值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//向上取整</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> p)</span></span>; <span class="comment">//返回x的p次方</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回根号x</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回以自然对数e为底数的logx,c语言中没有对任意底数求对数的函数，只能使用此公式和换底公式来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;  <span class="comment">//三角函数,x必须为弧度制，如pi/2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//反三角函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//对x四舍五入到整数位，以%d格式printf时需取整(int)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;<span class="number">0.0</span>) ? <span class="built_in">floor</span>(x+<span class="number">0.5</span>) : <span class="built_in">ceil</span>(x<span class="number">-0.5</span>);&#125;  <span class="comment">//有些编译器如PAT不支持round函数，可利用floor和ceil写一个。</span></span><br></pre></td></tr></table></figure>

<h1 id="四、选择结构"><a href="#四、选择结构" class="headerlink" title="四、选择结构"></a>四、选择结构</h1><h2 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1. if语句"></a>1. if语句</h2><p>用于分支条件较少的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(B)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A)&#123;   <span class="comment">//if语句嵌套</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(B)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2. switch语句"></a>2. switch语句</h2><p>用于分支条件较多的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式n;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除break则会从第一个匹配的case开始执行之后的所有语句。</p>
<h1 id="五、循环结构"><a href="#五、循环结构" class="headerlink" title="五、循环结构"></a>五、循环结构</h1><h2 id="1-while语句"><a href="#1-while语句" class="headerlink" title="1. while语句"></a>1. while语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(A)&#123;  <span class="comment">//推荐</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(A);  <span class="comment">//不推荐</span></span><br></pre></td></tr></table></figure>

<h2 id="2-for语句"><a href="#2-for语句" class="headerlink" title="2. for语句"></a>2. for语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(A;B;C)&#123;   <span class="comment">//注意！C中A位置不允许定义变量而C++可以。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-break和continue语句"><a href="#3-break和continue语句" class="headerlink" title="3. break和continue语句"></a>3. break和continue语句</h2><p>break：跳出循环体。continue：跳出当前循环，即continue后面的代码不执行，直接进入下一轮循环。</p>
<h1 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h1><p>如果数组大小较大（大概10<sup>6</sup>级别），则需要将其定义在主函数外面，否则会使程序异常退出，因为函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的全局变量来自静态存储区，允许申请的空间较大。<br>数组的长度计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);  <span class="comment">//数组占内存总空间，除以单个元素占内存空间大小</span></span><br></pre></td></tr></table></figure>
<h2 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[数组大小];  <span class="comment">//数组大小必须是整数常量，不可以是变量。</span></span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//后面未被初始化的元素将根据编译器内部实现的不同而被赋以不同的初值（可能是很大的随机数），但一般默认为0。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2. 二维数组"></a>2. 二维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[第一维大小][第二维大小];</span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">6</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;&#125;,&#123;<span class="number">8</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-字符数组"><a href="#3-字符数组" class="headerlink" title="3. 字符数组"></a>3. 字符数组</h2><ol>
<li>初始化：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = &#123;<span class="string">'G'</span>,<span class="string">'o'</span>,<span class="string">'o'</span>,<span class="string">'d'</span>,<span class="string">' '</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'y'</span>,<span class="string">'!'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = <span class="string">"Good story!"</span>;  <span class="comment">//直接赋值字符串，注意！仅限于初始化，程序其他位置不允许这样直接赋值整个字符串。</span></span><br></pre></td></tr></table></figure>
<font color=Crmison>注意！定义了数组或字符指针之后，需要做一个初始化，否则里面将是随机值，以后将无法判断改字符串是否为空。</font><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名,‘\<span class="number">0</span>’,<span class="keyword">sizeof</span>(数组名));</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strlen</span>(str) == <span class="number">0</span>)  <span class="comment">//推荐判空方式</span></span><br><span class="line"> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'\0'</span>)  /避免使用，容易crash</span><br></pre></td></tr></table></figure></li>
<li>输入输出：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;str[<span class="number">0</span>]);  <span class="comment">//%c能读入空白符（空格，TAB，换行），%s以空白符为结束符。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>]=getchar();  <span class="comment">//getchar()可以读入空白符。注意！在scanf("%s\n")和gets(str)之间应先使用getchar()吸收掉\n，否则不能读取str,因为gets(str)以\n为结束符。</span></span><br><span class="line"><span class="built_in">putchar</span>(str[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">gets(str);     <span class="comment">//gets()以换行符\n为结束符，可以读入空格。PAT OJ中不支持gets()函数。</span></span><br><span class="line"><span class="built_in">puts</span>(str);    <span class="comment">//输出一个字符串并紧跟换行</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><font color=Crmison>3. 字符数组的存放方式：</font><br>每一个一维数组的末尾都有一个空字符\0，占一位，表示存放的字符串的结尾，puts和printf就是通过识别\0来输出字符串的。故在定义字符数组时长度一定要比实际存储字符串的长度至少多1。\0在使用gets和scanf(“%s”)时会自动添加，其他的输入如getchar()则需要在字符串末尾手动添加\0，否则puts和printf将由于无法识别字符串末尾而输出一大堆乱码。</p>
<h2 id="4-memset——对数组中每一个元素赋相同的值"><a href="#4-memset——对数组中每一个元素赋相同的值" class="headerlink" title="4. memset——对数组中每一个元素赋相同的值"></a>4. memset——对数组中每一个元素赋相同的值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">memset</span>(数组名，值，<span class="keyword">sizeof</span>(数组名));  <span class="comment">//速度快，但它是按字节赋值，即对每一个字节赋同样的值，故常用它赋0或-1不容易出错。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-string-h头文件"><a href="#5-string-h头文件" class="headerlink" title="5. string.h头文件"></a>5. string.h头文件</h2><p>包含了很多关于字符数组的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(str)</span></span>; <span class="comment">//返回字符数组中第一个\0之前的字符的个数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(str1,dtr2)</span></span>; <span class="comment">//按字典序返回两个字符串大小的比较结果: 大于0的数(str1 &gt; str2)、返回0(str1 == str2)、小于0的数(str1 &lt; str2),返回值根据不同编译器处理而有不同的返回值，通常为1、0、-1。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(str1,str2)</span></span>; <span class="comment">//将str2复制给str1，包括\0。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcat</span><span class="params">(str1,str2)</span></span>; <span class="comment">//将str2拼接到str1的后面。</span></span><br></pre></td></tr></table></figure>

<h2 id="6-sscanf与sprintf"><a href="#6-sscanf与sprintf" class="headerlink" title="6. sscanf与sprintf"></a>6. sscanf与sprintf</h2><p>处理字符串格式输入输出问题的利器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n); <span class="comment">//将str中的内容以%d格式写入n中，从左至右。</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, n); <span class="comment">//将n以%d格式写入字符数组str中，从右至左。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d:%f,%s"</span>,&amp;n1,&amp;n2,&amp;n3);</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d:%.2f,%s"</span>,n1,n2,n3);</span><br></pre></td></tr></table></figure>
<p>sscanf还支持正则表达式，可解决字符串中的复杂问题。</p>
<h1 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h1><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回类型 函数名称(参数类型 参数)&#123;</span><br><span class="line">    函数主题</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> c)</span></span>;  <span class="comment">//值传递,传入的是实参的一个副本，故不能改变实参的值</span></span><br></pre></td></tr></table></figure>

<h2 id="2-以数组作为函数参数"><a href="#2-以数组作为函数参数" class="headerlink" title="2. 以数组作为函数参数"></a>2. 以数组作为函数参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[][<span class="number">5</span>])</span></span>;  <span class="comment">//第一维度可不写长度，第二维度需要写明长度，可以再函数内部修改实参数组中的元素的值。</span></span><br><span class="line"></span><br><span class="line">func(a,b);  <span class="comment">//调用时只需要写数组名。</span></span><br></pre></td></tr></table></figure>
<p>注意！数组可以作为函数的参数却不允许作为函数返回值，若想返回数组只有将返回的数组作为参数传入。函数可以嵌套调用，也可以递归调用。</p>
<h1 id="八、指针"><a href="#八、指针" class="headerlink" title="八、指针"></a>八、指针</h1><p>C语言中用指针来表示内存地址，它是一个unsigned类型的整数，若这个内存地址恰好是某个变量的地址，则称这个指针指向该变量，变量的地址一般指它占用的字节中第一个字节的地址。在变量前加上取地址运算符&amp;即可得到变量的地址。</p>
<h2 id="1-指针变量"><a href="#1-指针变量" class="headerlink" title="1. 指针变量"></a>1. 指针变量</h2><p>指针变量用来存放指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义和初始化</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span>* p=&amp;a;  <span class="comment">//C++写法，地址是赋值给p而不是*p的，*是类型的一部分。</span></span><br><span class="line"><span class="keyword">int</span> *p1=&amp;b,p2;  <span class="comment">//C写法</span></span><br><span class="line"><span class="keyword">int</span> *q1,*q2,*q3; <span class="comment">//基类型(int)必须和指针变量存储的地址类型相同。</span></span><br><span class="line"><span class="keyword">char</span>* str=<span class="string">"I love china!"</span>;</span><br><span class="line">*(str+<span class="number">1</span>);  <span class="comment">//获得str+1位置的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,a+n);  <span class="comment">//输出包括a+n位置及后面所有字符的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line">*p;  <span class="comment">//获得变量a的值，对*p的操作等同于对a操作。 </span></span><br><span class="line">p+<span class="number">1</span>;  <span class="comment">//p所指的int型变量的下一个int型变量地址，跨越了一整个Int型(4Byte)。</span></span><br><span class="line">p++,p--;</span><br><span class="line">p1-p2;  <span class="comment">//2个指针之间相差的Int型变量的个数。</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>注意！若指针不进行初始化则指向的地址是随机的，而且很可能随机指向系统工作区，那么就会出错。</font></p>
<h2 id="2-使用指针变量作为函数参数"><a href="#2-使用指针变量作为函数参数" class="headerlink" title="2. 使用指针变量作为函数参数"></a>2. 使用指针变量作为函数参数</h2><p>使用指针变量作为函数参数时，在函数内部对指针变量(形参)本身进行修改并不能使传入的指针变量(实参)改变，因为传入的指针变量相当于传入一个副本，能够使实参改变的只能是该函数中对指针指向的数据进行的修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* m, <span class="keyword">int</span>* n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=*m;</span><br><span class="line">    *m=*n;</span><br><span class="line">    *n=temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(p,p1);</span><br></pre></td></tr></table></figure>

<h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h2><p>引用(&amp;，区分取地址符)可以不使用指针，也能达到修改传入参数的目的，且引用不产生副本，而是给<font color=Crmison>原变量(而不是常量，常量不可使用引用)</font>起了个别名，故旧名字与新名字指向同一个东西，对引用变量的操作就是对原变量的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>;</span><br><span class="line">func(p2);</span><br></pre></td></tr></table></figure>
<p>指针的引用：通过将指针的引用作为形参，从而达到将传入的地址交换以交换两个变量的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* &amp;m, <span class="keyword">int</span>* &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp=m;</span><br><span class="line">    m=n;</span><br><span class="line">    n=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(p,p1);   <span class="comment">//swap(&amp;p,&amp;p1)写法错误，因为&amp;p,&amp;p1为常量，而常量不可使用引用。</span></span><br></pre></td></tr></table></figure>

<h1 id="九、结构体-struct-的使用"><a href="#九、结构体-struct-的使用" class="headerlink" title="九、结构体(struct)的使用"></a>九、结构体(struct)的使用</h1><p>需要将一些相关的变量放在一起存储时，需要用到结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span> &#123;</span></span><br><span class="line">    <span class="comment">//一些基本的数据结构或自定义的数据类型。</span></span><br><span class="line">&#125;结构体变量名;</span><br></pre></td></tr></table></figure>

<h2 id="1-结构体的定义"><a href="#1-结构体的定义" class="headerlink" title="1. 结构体的定义"></a>1. 结构体的定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> major[<span class="number">20</span>];</span><br><span class="line">    StudentInfo* next;  <span class="comment">//结构体内不能定义自己，会引起循环定义问题，但可以定义自身类型的指针变量，它可以定义除自身外的任何数据类型。注意！结构体指针变量不能在匿名结构体内定义。</span></span><br><span class="line">&#125;Alice,stu[<span class="number">1000</span>];  <span class="comment">//直接定义结构体变量</span></span><br><span class="line"></span><br><span class="line">StudentInfo Bob,*p;</span><br></pre></td></tr></table></figure>

<h2 id="2-访问结构体内的元素"><a href="#2-访问结构体内的元素" class="headerlink" title="2. 访问结构体内的元素"></a>2. 访问结构体内的元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stu[<span class="number">0</span>].id;</span><br><span class="line">stu[<span class="number">0</span>].gender;</span><br><span class="line"></span><br><span class="line">(*p).id;</span><br><span class="line">(*p).name;</span><br><span class="line">(*p).next;</span><br><span class="line"></span><br><span class="line">p-&gt;id;</span><br><span class="line">p-&gt;name;</span><br><span class="line">p-&gt;next;</span><br></pre></td></tr></table></figure>

<h2 id="3-结构体的初始化和赋值"><a href="#3-结构体的初始化和赋值" class="headerlink" title="3. 结构体的初始化和赋值"></a>3. 结构体的初始化和赋值</h2><p>结构体使用构造函数来进行初始化，对于一个普通定义的结构体，其内部会生成一个<font color=Crmison>默认构造函数(但不可见)</font>，如studentInfo(){}，正是由于默认构造函数的存在才可以直接定义结构体变量而不进行初始化，因为它没有让用户提供任何初始化参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    StudentInfo(<span class="keyword">int</span> _id, <span class="keyword">char</span> _gender)&#123;   <span class="comment">//自定义构造函数</span></span><br><span class="line">        id=_id;</span><br><span class="line">        gender=_gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StudentInfo(<span class="keyword">int</span> _id, <span class="keyword">char</span> _gender): id(_id), gender(_gender) &#123;&#125;   <span class="comment">//构造函数的简化写法</span></span><br><span class="line">&#125;stu[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="string">'M'</span>,<span class="number">2</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line"></span><br><span class="line">StudentInfo stu = StudentInfo(<span class="number">10086</span>,<span class="string">'M'</span>);   <span class="comment">//初始化结构体</span></span><br><span class="line">stu[<span class="number">2</span>]=stu;  <span class="comment">//C++中相同类型结构体之间可以直接赋值，而C语言中不可以。</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>注意！若自定义了构造函数而不想进行初始化，则需要手动添加默认构造函数。</font>只要参数和类型不完全相同，就可以定义任意多个构造函数，以适应不同的初始化场合。</p>
<h2 id="4-共用体"><a href="#4-共用体" class="headerlink" title="4. 共用体"></a>4. 共用体</h2><p>共用体可定义在结构体内部，用于建立有不同类型数据组成的组合型的数据结构。原则上，共用体的大小取决于占据最多内存的成员的长度，但会受到最宽基本类型成员大小的影响。即:共用体的总大小为共用体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> MyUnion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> chs[<span class="number">11</span>];</span><br><span class="line">&#125;u = &#123; <span class="number">10</span> &#125;, u2 = &#123;.chs=<span class="string">"niko"</span>&#125;;   <span class="comment">// 初始化;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> MyUnion mu = &#123; <span class="number">1</span> &#125;;  <span class="comment">// 默认初始化第一个成员</span></span><br><span class="line"><span class="keyword">union</span> MyUnion mu2 = &#123; .chs = <span class="string">"hello"</span> &#125;;  <span class="comment">// 指定要初始化的成员</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithms,C,C++</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基本语法</title>
    <url>/2020/04/20/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、Java应用程序的结构"><a href="#一、Java应用程序的结构" class="headerlink" title="一、Java应用程序的结构"></a>一、Java应用程序的结构</h1><h2 id="1-程序的组成"><a href="#1-程序的组成" class="headerlink" title="1. 程序的组成"></a>1. 程序的组成</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  <span class="comment">//要运行java程序，必须有一个main方法，public和static的位置可以互换，但其它部分位置固定</span></span><br><span class="line">    System.out.println(<span class="string">"We will not use 'Hello, World!"</span><span class="string">');</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>java区分大小写；</li>
<li>public关键字为访问修饰符，用于控制程序的其他部分对这段代码的访问级別；</li>
<li>关键字 class 表明 Java 程序中的全部内容都包含在类中；</li>
<li>class 后面紧跟类名，名字必须以字母开头，后面可以跟字母和数字的任意组合，采用驼峰命名法，不能使用java保留字；</li>
<li><font color=Crmison>源代码的文件名必须与public类的名字相同，并用 .java 作为扩展名。源文件可以包含多个类定义，但最多只能包含一个public类定义。可以没有public类定义，此时文件名可随意。</font></li>
<li><font color=Crmison>成功编译后会得到一个包含这个类字节码的文件。Java 编译器将字节码文件自动地命名为 ClassName. class, 并与源文件存储在同一个目录下。</font></li>
<li>运行已编译的程序时，Java 虚拟机将从指定类中的 main 方法开始执行,故<font color=Crmison>在类的源文件中必须包含一个 main方法。</font></li>
<li><font color-Crmison>在 Java SE 1.4 及以后的版本中<font color=Crmison>强制 main方法是 public 的。</font></li>
<li>Java 中的 <font color=Crmison>main 方法必须是静态static的。</font></li>
<li>在 Java 中，每个句子必须用分号结束。特别需要说明，回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。</li>
</ul>
<h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*比较长的一段话，注意不能嵌套*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*多行注释，可自动生成文档。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="二、8种基本数据类型"><a href="#二、8种基本数据类型" class="headerlink" title="二、8种基本数据类型"></a>二、8种基本数据类型</h1><p>4种整型，2种浮点型，1种用于表示 Unicode 编码的字符单元的字符类型 char和 1 种用于表示真值的 boolean 类型。</p>
<h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><p><img src="Java%E6%95%B4%E5%9E%8B.png" alt="Java整型"></p>
<ul>
<li><font color=Crmison>int：</font>10<sup>9</sup>以内；</li>
<li><font color=Crmison>long：</font>10<sup>10</sup>——10<sup>18</sup>，数值有一个后缀L或l；</li>
<li>二进制从Java7开始，要加上前缀0b或0B；八进制加前缀0(容易混淆数值，不推荐)；十六进制加前缀0x或0X；</li>
<li>从Java7开始还可以为数字字面量加下划线让程序更易读，Java编译器会去除这些下划线。如1_000_000或0b1111_0100_0010_0200_0000。</li>
<li><font color=Crmison>Java中所有的数值类型所占据的字节数量与平台无关</font>，而C和C++会随着平台改变而改变。</li>
<li><font color=Crmison>注意!Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。</font></li>
</ul>
<h2 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a>2. 浮点型</h2><h3 id="2-1-两种浮点类型"><a href="#2-1-两种浮点类型" class="headerlink" title="2.1 两种浮点类型"></a>2.1 两种浮点类型</h3><p><img src="%E6%B5%AE%E7%82%B9%E5%9E%8B.png" alt="浮点型"></p>
<ul>
<li>float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。</li>
<li>也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。</li>
<li>绝大部分应用程序都采用 double 类型。在很多情况下，float 类型的精度很难满足需求。</li>
<li><font color=Crmison>可以使用十六进制表示浮点数值。</font>例如，0.125=2<sup>—3</sup>可以表示成 0xl.0p-3。在十六进制表示法中， 使用 p 表示指数， 而不是 e。 注意， 尾数采用十六进制，指数采用十进制。指数的基数是 2。</li>
</ul>
<h3 id="2-2-浮点型的计算"><a href="#2-2-浮点型的计算" class="headerlink" title="2.2 浮点型的计算"></a>2.2 浮点型的计算</h3><ul>
<li>所有的浮点数值计算都遵循 IEEE 754 规范。</li>
<li>三个特殊浮点值表示溢出和出错情况：<br>  <font color=Crmison>正无穷大(常量 <code>Double.POSITIVE_INFINITY</code>或<code>Flocat.POSITIVE_INFINITY</code>)</font><br>  <font color=Crmison>负无穷大(<code>Double.NEGATIVE_INFINITY</code>或<code>Float.NEGATIVE_INFINITY</code>)</font><br>  <font color=Crmison>NaN(非数值，<code>Double.NaN</code>或<code>Float.NaN</code>):注意！所有非数值都认为是不相同的。</font>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = Double.NaN) <span class="comment">// is never true 错误判断方法</span></span><br><span class="line"><span class="keyword">if</span> (Double.isNaN(x)) <span class="comment">// check whether x is "not a number" 正确判断方法</span></span><br></pre></td></tr></table></figure></li>
<li>浮点数值采用二进制系统表示，故无法精确表示1/10，如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal类</li>
</ul>
<h2 id="3-Unicode编码与字符编码表"><a href="#3-Unicode编码与字符编码表" class="headerlink" title="3. Unicode编码与字符编码表"></a>3. Unicode编码与字符编码表</h2><p>设计 Unicode 编码的目的是将世界不同地区的不同编码标准如美国的 ASCII、 西欧语言中的ISO 8859-1 俄罗斯的 KOI-8、 中国的 GB 18030 和 BIG-5 等统一起来，起初Unicode是固定的16位，而经过一段时间的发展，Unicode 字符超过了 65 536 个，其主要原因是增加了大量的汉语、 日语和韩语中的表意文字。为了解决这个问题，设计了不同的变长编码方式，如UTF-8和UTF-16，要理解这两种编码方式，必须首先理解Unicode码点等含义。<br><font color=Crmison>码点：</font>是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中，码点采用 <font color=Crmison>U+十六进制</font> 书写,Unicode 的码点可以分成 17 个代码级别，从U+10000 到 U+10FFFF。<br><font color=Crmison>基本的多语言级别：</font>码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；<br><font color=Crmison>辅助字符级别：</font>其余的 16个级别的码点从 U+10000 到 U+10FFFF , 其中包括一些辅助字符。</p>
<h3 id="3-1-UTF-16字符编码表"><a href="#3-1-UTF-16字符编码表" class="headerlink" title="3.1 UTF-16字符编码表"></a>3.1 UTF-16字符编码表</h3><p>UTF-16 编码采用不同长度(2字节和4字节)的编码表示所有 Unicode 码点。在基本的多语言级别中，每个字符用 16 位表示，通常被称为<font color=Crmison>代码单元</font>; 而辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的 2048 字节内， 通常被称为替代区域，其中 U+D800 ~ U+DBFF 用于第一个代码单元，U+DC00 ~ U+DFFF 用于第二个代码单元，而这些替代区域Unicode规定不对应与任何字符。这样设计十分巧妙，我们可以从中迅速地知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。参见<a href="https://zh.wikipedia.org/wiki/UTF-16#从U+0000至U+D7FF以及从U+E000至U+FFFF的码位" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/UTF-16#从U+0000至U+D7FF以及从U+E000至U+FFFF的码位</a><br><font color=Crmison>UTF-16编码算法：</font></p>
<ul>
<li>码位减去 0x10000，得到的值的范围为20比特长的 0…0xFFFFF。</li>
<li>高位的10比特的值（值的范围为 0…0x3FF）被加上 0xD800 得到第一个码元或称作高位代理，值的范围是 0xD800…0xDBFF。由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理。</li>
<li>低位的10比特的值（值的范围也是 0…0x3FF）被加上 0xDC00 得到第二个码元或称作低位代理，现在值的范围是 0xDC00…0xDFFF。由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理。</li>
</ul>
<p><font color=Crmison>UTF-16编码示例：</font><br><img src="UTF-16.png" alt="UTF-16编码示例"></p>
<h3 id="3-2-UTF-8字符编码表"><a href="#3-2-UTF-8字符编码表" class="headerlink" title="3.2 UTF-8字符编码表"></a>3.2 UTF-8字符编码表</h3><p>UTF-8编码也采用不同字节编码所有Unicode码点(1字节-6字节)参见<a href="https://zhuanlan.zhihu.com/p/72254734" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72254734</a><br><font color=Crmison>UTF-16编码规则表：</font><br><img src="UTF-8.png" alt="UTF-8编码规则表"><br><font color=Crmison>UTF-16编码示例：</font><br>汉字「吕」的 Unicode 编码是 U+5415，对应二进制为 0101010000010101，总共有 15 位。因为两字节最多表示 11 位，三字节最多表示 16 位，所以使用三字节编码。对应二进制拆成（从低位到高位）三部分，分别是 0101, 010000, 010101，再拼上编码前缀得到 11100101, 10010000, 10010101，对应十六进制为 0xe5, 0x90, 0x95，这就是汉字「吕」的 UTF-8 编码。</p>
<h2 id="4-char类型"><a href="#4-char类型" class="headerlink" title="4. char类型"></a>4. char类型</h2><ul>
<li>char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。</li>
<li>char 类型的字面量值要用单引号括起来。</li>
<li>char 类型的值可以用转义序列\u和十六进制值表示，其范围从 \u0000 到 \uffff。</li>
<li>除了转义序列 \u 之外， 还有一些用于表示特殊字符的转义序列：<br><img src="%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97.png" alt="转义序列"></li>
<li>所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\02122’ 或 “Hello\n”。转义序列 \u还可以出现在加引号的字符常量或字符串之外（<font color=Crmison>而其他所有转义序列不可以</font>。</li>
<li><font color=Crmison>Unicode 转义序列会在解析代码之前得到处理。</font><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\u005B\ u00SD args)</span></span>;  <span class="comment">//\u005B 和 \u005D 是 [ 和 ] 的编码。</span></span><br><span class="line"><span class="string">"\u0022+\u0022"</span>;   <span class="comment">//""+""  即空串</span></span><br><span class="line"><span class="comment">// \u00A0 is a newline   </span></span><br><span class="line"><span class="comment">//\u00A0为换行符，故会产生一个语法错误</span></span><br><span class="line"><span class="comment">// Look inside c:\users   </span></span><br><span class="line"><span class="comment">//也会产生一个语法错误， 因为 \u 后面并未跟着 4 个十六进制数。</span></span><br></pre></td></tr></table></figure>
<h2 id="5-boolean类型"><a href="#5-boolean类型" class="headerlink" title="5. boolean类型"></a>5. boolean类型</h2>boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件。<font color=Crmison>要注意！整型值和布尔值之间不能进行相互转换。</font></li>
</ul>
<h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><h2 id="1-变量的声明"><a href="#1-变量的声明" class="headerlink" title="1. 变量的声明"></a>1. 变量的声明</h2><ol>
<li>变量名必须是一个以字母开头并由字母或数字构成的序列。</li>
<li>需要注意，与大多数程序设计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括 ‘A’ ~ ‘Z’、 ‘a’ ~ ‘z’、或在某种语言中表示字母的任何 Unicode 字符。</li>
<li>但 V 和 ‘©’这样的符号不能出现在变量名中，空格也不行。可以使用 Character 类的<code>isJavaldentifierStart</code> 和 <code>isJavaldentifierPart</code> 方法来检查哪些 Unicode 字符属于 Java 中的“ 字母”。</li>
<li>另外， 不能使用 Java 保留字作为变量名。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j; <span class="comment">//不提倡</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b; <span class="comment">//提倡，可读性强</span></span><br><span class="line">Box box;</span><br><span class="line">Box aBox;</span><br></pre></td></tr></table></figure>

<h2 id="2-变量的初始化"><a href="#2-变量的初始化" class="headerlink" title="2. 变量的初始化"></a>2. 变量的初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> vacationDays;  <span class="comment">//声明一个变量之后，必须用赋值语句对变量进行显式初始化,否则不能使用</span></span><br><span class="line">vacationDays=<span class="number">12</span>;  <span class="comment">//可以将变量的声明和初始化放在同一行中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 Java 中可以将声明放在代码中的任何地方,但应尽可能地靠近变量第一次使用的地方。</span></span><br><span class="line"><span class="keyword">int</span> vacationDays = <span class="number">12</span>;       <span class="comment">//在 Java 中， 不区分变量的声明与定义。</span></span><br></pre></td></tr></table></figure>
<h2 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> CM_PER_INCH = <span class="number">2.54</span>; <span class="comment">//关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类常量的定义位于 main 方法的外部。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> CM_PER_INCH = <span class="number">2.54</span>; <span class="comment">//使用关键字 static final 可设置一个类常量,可使其在一个类中的多个方法中使用</span></span><br><span class="line">                                            <span class="comment">//如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量，ClassName.常量名。</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>const 是 Java 保留的关键字，但目前并没有使用。</font></p>
<h1 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h1><p><code>+ - * / %</code>加、减、乘、除、取余数</p>
<ol>
<li><font color=Crmison>需要注意， 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。</font></li>
<li>在默认情况下， 虚拟机设计者允许对中间计算结果采用扩展的精度。但是， 对于使用 <code>strictfp</code> 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。</li>
<li>如果将一个类标记为strictfp, 这个类中的所有方法都要使用严格的浮点计算。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-数学函数与数学常量"><a href="#1-数学函数与数学常量" class="headerlink" title="1. 数学函数与数学常量"></a>1. 数学函数与数学常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;  <span class="comment">//静态导入Math包后，就不需要使用 Math.方法名 来调用了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决负整数取余数问题的方法,n%2=-1，若n为负整数</span></span><br><span class="line">floorMod(position+adjustment,<span class="number">12</span>);  <span class="comment">//（对于负除数，floorMod 会得到负数结果，不过这种情况在实际中很少出现。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三角函数方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span>  <span class="title">sin</span><span class="params">(<span class="keyword">double</span> a )</span> ： 返回角的三角正弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> a)</span>  ： 返回角的三角余弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span>  a)</span>  ： 返回角的三角正切</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> a)</span> : 返回角的反正弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> a)</span>  : 返回角的反余弦</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> a)</span>  ： 返回角的反正切</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">toRadians</span><span class="params">(<span class="keyword">double</span> a)</span> : 将角转换为弧度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  doueble <span class="title">toDegrees</span><span class="params">(<span class="keyword">double</span> a)</span> : 将弧度转化为角</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//指数函数方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> a)</span> : 用于获取e的a次方；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> a)</span> : 即lna</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> a)</span> : 即log10a</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a )</span>:用于取a的平方根；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">cbrt</span><span class="params">(<span class="keyword">double</span> a)</span> : 用于取a的立方根；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> : 用于求a的b次方；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//取整函数方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span>：返回大于等于a的整数值，返回值类型为<span class="keyword">double</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span> : 返回小于等于a的整数值，返回值类型为<span class="keyword">double</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rint</span><span class="params">(<span class="keyword">double</span> a)</span> : 返回与a最接近的整数值，返回值类型为<span class="keyword">double</span>；（如果两个同为整数且同样接近，选取偶数值的那个）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">( )</span>:返回带正号的 <span class="keyword">double</span> 值，该值大于等于 0.0 且小于 1.0。</span></span><br><span class="line"><span class="function"><span class="comment">//四舍五入函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a )</span>: 其值等于Math.<span class="title">floor</span><span class="params">(a + <span class="number">0.5</span>)</span>，返回值类型为<span class="keyword">long</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">float</span> a )</span>: 其值等于Math.<span class="title">floor</span><span class="params">(a + <span class="number">0.5</span>)</span>，返回值类型为<span class="keyword">int</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求绝对值运算和最值运算，这里的类型就是double，float，int和long类型</span></span><br><span class="line"><span class="keyword">static</span> 类型 abs(类型); 返回对应类型的绝对值</span><br><span class="line"><span class="keyword">static</span> 类型 max(类型<span class="number">1</span>,类型<span class="number">2</span>); 返回对应类型的最大值</span><br><span class="line"><span class="keyword">static</span> 类型 min(类型<span class="number">1</span>,类型<span class="number">2</span>); 返回对应类型的最小值</span><br></pre></td></tr></table></figure>

<h2 id="2-数值类型之间的合法自动转换"><a href="#2-数值类型之间的合法自动转换" class="headerlink" title="2. 数值类型之间的合法自动转换"></a>2. 数值类型之间的合法自动转换</h2><p><img src="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="类型转换"><br>其中6个实心箭头，表示无信息丢失的转换；有 3 个虚箭头，表示可能有精度损失的转换。当进行二元操作时，会将两个操作数自动转换为同一种类型，再进行计算，转换规则为：</p>
<ul>
<li>如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。</li>
<li>否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。</li>
<li>否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 </li>
<li>否则， 两个操作数都将被转换为 int 类型。</li>
</ul>
<h2 id="3-强制类型转换cast"><a href="#3-强制类型转换cast" class="headerlink" title="3. 强制类型转换cast"></a>3. 强制类型转换cast</h2><p>当存在信息丢失的可能时，需要进行强制类型转换才可以，比如long—&gt;int,强制类型转换会进行截断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(目标类型)变量; <span class="comment">//不要在 boolean 类型与任何数值类型之间进行强制类型转换， 这样可以防止发生错误。</span></span><br><span class="line">b?<span class="number">1</span>:<span class="number">0</span>;   <span class="comment">//极少情况下使用</span></span><br></pre></td></tr></table></figure>

<h2 id="4-结合赋值运算符"><a href="#4-结合赋值运算符" class="headerlink" title="4. 结合赋值运算符"></a>4. 结合赋值运算符</h2><p><code>+= -= *= /= %=</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x += <span class="number">3.5</span>; <span class="comment">//等价 (int)(x+3.5) 运算符得到一个值， 其类型与左侧操作数的类型不同， 就会发生强制类型转换。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-自增与自减运算符"><a href="#5-自增与自减运算符" class="headerlink" title="5. 自增与自减运算符"></a>5. 自增与自减运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">12</span>;</span><br><span class="line">n++;    <span class="comment">//由于这些运算符会改变变量的值，所以它们的操作数不能是数值。</span></span><br><span class="line">n--     <span class="comment">//不推荐使用++,容易产生bug。</span></span><br><span class="line">++n;</span><br><span class="line">--n;</span><br></pre></td></tr></table></figure>

<h2 id="6-关系运算符和boolean运算符"><a href="#6-关系运算符和boolean运算符" class="headerlink" title="6. 关系运算符和boolean运算符"></a>6. 关系运算符和boolean运算符</h2><ul>
<li>关系运算符：<br><code>== != &lt; &gt; &lt;= &gt;=</code></li>
<li>boolean运算符:<br><code>&amp;&amp; || ! ?:</code></li>
</ul>
<h2 id="7-位运算符"><a href="#7-位运算符" class="headerlink" title="7. 位运算符"></a>7. 位运算符</h2><p><code>&amp; | ^(异或) ~ &lt;&lt;(左移) &gt;&gt;(右移)</code></p>
<ol>
<li>利用 &amp; 并结合使用适当的 2 的幂， 可以把其他位掩掉， 而只保留其中的某一位。</li>
<li><font color=Crmison><code>&gt;&gt;&gt;</code> 运算符会用 0 填充高位，这与<code>&gt;&gt;</code>不同，它会用符号位填充高位。不存在<code>&lt;&lt;&lt;</code>运算符。</font></li>
<li><font color=Crmison>移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作数模 64 )。</font></li>
<li>C/C++中<code>&gt;&gt;</code>对于负数生成的结果可能会依赖于具体的实现。Java 则消除了这种不确定性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(n &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&lt;&lt;<span class="number">35</span>;  <span class="comment">//等价8或者1&lt;&lt;3</span></span><br></pre></td></tr></table></figure>

<h2 id="8-括号与运算符的优先级"><a href="#8-括号与运算符的优先级" class="headerlink" title="8. 括号与运算符的优先级"></a>8. 括号与运算符的优先级</h2><p><img src="%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A71.png" alt="运算符优先级1"><br><img src="%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A72.png" alt="运算符优先级2"></p>
<h2 id="9-枚举类型"><a href="#9-枚举类型" class="headerlink" title="9. 枚举类型"></a>9. 枚举类型</h2><p>用于变量的取值只在一个有限的集合内的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;; <span class="comment">//定义枚举类型</span></span><br><span class="line">Size s = Size.MEDIUM; <span class="comment">//声明变量，只能存储Size中给定的枚举值或null值，null 表示这个变量没有设置任何值。</span></span><br></pre></td></tr></table></figure>

<h1 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h1><blockquote>
<p>Java 字符串就是 Unicode 字符序列。<br>Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。<br>每个用双引号括起来的字符串都是 String类的一个实例。<br><font color=Crmison>String 类对象为不可变字符串，不能修改字符串中的任一字符，但是可以修改整个字符串变量，让它引用另外一个字符串。</font><br>字符串存放在一个公共存储池(堆)中，字符串变量指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同的字符。即：编译器可以让字符串共享。<br><font color=Crmison>Java 将自动地进行垃圾回收。 如果修改字符串变量后之前的字符串所占的一块内存不再使用了， 系统最终会将其回收。</font></p>
</blockquote>
<h2 id="1-String中的各种字符串操作"><a href="#1-String中的各种字符串操作" class="headerlink" title="1. String中的各种字符串操作"></a>1. String中的各种字符串操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting = <span class="string">"Hello"</span>;</span><br><span class="line">String expletive = <span class="string">"Expletive"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串 substring方法</span></span><br><span class="line">String s = greeting.substring(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">//"Hel"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接 +</span></span><br><span class="line">String message = expletive + greeting; <span class="comment">//当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串（任何一个 Java 对象都可以转换成字符串）。</span></span><br><span class="line">nt age = <span class="number">13</span>;</span><br><span class="line">String rating = <span class="string">"PC"</span> + age;   <span class="comment">//PG13</span></span><br><span class="line">System.out.println(<span class="string">"The answer is "</span> + answer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//join方法：把多个字符串放在一起， 用一个定界符分隔</span></span><br><span class="line">String all = String.join(<span class="string">" / "</span>, <span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>);  <span class="comment">//"S / H / L / XL"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改字符串变量，达到修改字符的效果</span></span><br><span class="line">greeting = greeting.substring(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">"p!"</span>; <span class="comment">//共享享带来的高效率远远胜过于提取、 拼接字符串所带来的低效率。因为对字符串进行的操作往往只是比较。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测字符串是否相等</span></span><br><span class="line">s.equals(t); </span><br><span class="line"><span class="string">"Hello"</span>.equals(greeting);</span><br><span class="line"><span class="string">"Hello"</span>.equalsIgnoreCase(<span class="string">"hel1o"</span>);   <span class="comment">//判断是否相等而不区分大小写</span></span><br><span class="line"><span class="keyword">if</span> (greeting.compareTo(<span class="string">"Hel1o"</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测字符串是否放置在同一个位置上</span></span><br><span class="line">greeting == <span class="string">"Hello"</span>;  <span class="comment">//可能正确也可能错误，因为实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = greeting.length(); <span class="comment">//返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。</span></span><br><span class="line"><span class="keyword">int</span> cpCount = greeting.codePointCount(<span class="number">0</span>, greeting.length()); <span class="comment">//得到实际的长度，即码点数量</span></span><br><span class="line"></span><br><span class="line">s.charAt(n); <span class="comment">//返回位置 n 的代码单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = greeting.offsetByCodePoints(<span class="number">0</span>, i);   <span class="comment">//得到第 i 个码点</span></span><br><span class="line"><span class="keyword">int</span> cp = greeting.codePointAt(index);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字符串的码点</span></span><br><span class="line"><span class="keyword">int</span>[] codePoints = str.codePointsO.toArray();</span><br><span class="line"><span class="comment">//把一个码点数组转换为一个字符串</span></span><br><span class="line">String str = <span class="keyword">new</span> String(codePoints, <span class="number">0</span>, codePoints.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个新字符串。 这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。</span></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个新字符串。这个字符串用 newString 代替原始字符串中所有的 oldString。可以用 String 或 StringBuilder 对象作为 CharSequence 参数。</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">( CharSequence oldString,CharSequence newString)</span></span></span><br></pre></td></tr></table></figure>
<p>Java 中的 String类包含了 50 多个方法。详参<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p>
<h2 id="2-空串与null串"><a href="#2-空串与null串" class="headerlink" title="2. 空串与null串"></a>2. 空串与null串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String e = <span class="string">""</span>; <span class="comment">// 空串,它是长度为0的字符串，有自己的内容(空)</span></span><br><span class="line">String str=<span class="keyword">null</span>; <span class="comment">//这表示目前没有任何对象与该变量关联</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>)  <span class="comment">//检查一个字符串是否为 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() != <span class="number">0</span>) <span class="comment">//检查一个字符串既不是 null 也不为空串，注意！首先要检查 str 不为 null。因为如果在一个 mill 值上调用方法， 会出现错误。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-使用StringBuilder类构建字符串"><a href="#3-使用StringBuilder类构建字符串" class="headerlink" title="3. 使用StringBuilder类构建字符串"></a>3. 使用StringBuilder类构建字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(ch); <span class="comment">// appends a single character</span></span><br><span class="line">bui1der.append(str); <span class="comment">// appends a string</span></span><br><span class="line">String completedString = builder.toString();</span><br></pre></td></tr></table></figure>
<ol>
<li>StringBuffer是StringBuilder的前身，其效率稍有些低， 但允许采用<font color=Crmison>多线程的方式</font>执行添加或删除字符的操作。</li>
<li>如果所有字符串在一个<font color=Crmison>单线程中编辑 （通常都是这样)，</font>则应该用 StringBuilder 替代它。</li>
</ol>
<h1 id="六、输入输出"><a href="#六、输入输出" class="headerlink" title="六、输入输出"></a>六、输入输出</h1><h2 id="1-读取输入"><a href="#1-读取输入" class="headerlink" title="1. 读取输入"></a>1. 读取输入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//当使用的类不是定义在基本java.lang 包中时，一定要使用import指示字将相应的包加载进来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Scanner 类的各种方法实现输入</span></span><br><span class="line">String name = in.nextLine();   <span class="comment">//nextLine()可读入空白符</span></span><br><span class="line">String firstName = in.next();  <span class="comment">//以空白符结束</span></span><br><span class="line"><span class="keyword">int</span> age = in.nextlnt();   <span class="comment">//读取一个整数</span></span><br><span class="line"><span class="keyword">double</span> num = nextDouble();  <span class="comment">//读取一个浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">( )</span> <span class="comment">//检测输人中是否还有其他单词。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//检测是否还有表示整数或浮点数的下一个字符序列。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNextDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用Console类从控制台读取密码</span></span></span><br><span class="line"><span class="function">Console cons </span>= System.console();</span><br><span class="line">String username = cons.readLine(<span class="string">"User name: "</span>)；</span><br><span class="line"><span class="keyword">char</span>[] passwd = cons.readPassword(<span class="string">"Password:"</span>);  <span class="comment">//为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示字符串 prompt 并且读取用户输入，直到输入行结束。args 参数可以用来提供输人格式。有关这部分内容将在下一节中介绍。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[] readPassword(String prompt, Object...args)</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readLine</span><span class="params">(String prompt, Object...args)</span></span></span><br></pre></td></tr></table></figure>
<p>采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有能够读取一个单词或一个数值的方法。</p>
<h2 id="2-格式化输出"><a href="#2-格式化输出" class="headerlink" title="2. 格式化输出"></a>2. 格式化输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">10000.0</span> / <span class="number">3.0</span>;</span><br><span class="line">System.out.print(x);</span><br><span class="line">System.out.printf(<span class="string">"%8.2f"</span>, x); <span class="comment">//Java SE5.0沿用了C中的printf方法用于对输出进行各种格式控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出</span></span><br><span class="line">String message = String.format(<span class="string">"Hello, %s. Next year, you'll be %d"</span>, name , age);</span><br></pre></td></tr></table></figure>
<p><img src="printf%E8%BD%AC%E6%8D%A2%E7%AC%A6.png" alt="printf转换符"><br>还可以在printf中给出控制格式化输出的各种标志:<br><img src="printf%E6%A0%87%E5%BF%97.png" alt="printf标志"><br>printf方法中日期与时间的格式化选项，格式包括两个字母， 以 t 开始， 以表中的任意字母结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%tc"</span>, <span class="keyword">new</span> Date());  <span class="comment">//打印当前完整的日期和时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用格式化的参数索引</span></span><br><span class="line">System.out.printf(<span class="string">"l$s %2$tB %2$te, %2$tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> DateQ);  <span class="comment">//%1$表示对第1个参数格式化， Due date: February 9, 2015</span></span><br><span class="line">System.out .printf(<span class="string">"%s %tB %&lt;te, %&lt;tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> DateO); <span class="comment">//&lt; 示前而格式说明中的参数将被再次使用</span></span><br></pre></td></tr></table></figure>
<p><img src="%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.png" alt="日期和时间"><br><img src="%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B41.png" alt="日期和时间"><br>以上有关printf方法中日期与时间的格式化选项已过时，新代码应使用java.time 包中的方法。<br>printf格式说明符的语法图：<br><img src="printf%E8%AF%AD%E6%B3%95.png" alt="printf语法"><br><font color=Crmison>许多格式化规则是本地环境特有的。例如，在德国，组分隔符是句号而不是逗号，Monday 被格式化为 Montag,java可以控制控制应用的国际化行为。</font></p>
<h2 id="3-文件输入与输出"><a href="#3-文件输入与输出" class="headerlink" title="3. 文件输入与输出"></a>3. 文件输入与输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若读取文件时不设置字符编码，则会使用运行该java程序的默认编码，若在不同的机器上运行可能会有不同的表现</span></span><br><span class="line"><span class="comment">//可使用Scannner的任意方法对文件进行读取</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">"myfile.txt"</span>), <span class="string">"UTF-8"</span>); <span class="comment">//如果文件名中包含反斜杠符号，需要在每个反斜杠之前再加一个额外的反斜杠：“ c:\\mydirectory\\myfile.txt ”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line"><span class="comment">//可以像输出到 System.out—样使用 print、 println 以及 printf命令。</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"myfile.txt"</span>, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p><font color=Crmison>如果用一个不存在的文件构造一个Scanner,或者用一个不能被创建的文件名构造一个PrintWriter,那么就会发生异常。Java 编译器认为这些异常比“被零除”异常更严重。</font></p>
<h1 id="七、控制流程"><a href="#七、控制流程" class="headerlink" title="七、控制流程"></a>七、控制流程</h1><h2 id="1-块作用域"><a href="#1-块作用域" class="headerlink" title="1. 块作用域"></a>1. 块作用域</h2><ol>
<li>块，即复合语句，是由一对大括号括起来的若干条简单的 Java 语句。</li>
<li>一个块可以嵌套在另一个块中。</li>
<li>但是，<font color=Crmison>不能在嵌套的两个块中声明同名的变量，否则无法通过编译。</font></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2. 条件语句"></a>2. 条件语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition1)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition3)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(condition);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x = <span class="number">0</span>; x != <span class="number">10</span>; x += <span class="number">0</span> .<span class="number">1</span>) <span class="comment">//由于浮点数的舍入误差，该循环永远不可能结束</span></span><br></pre></td></tr></table></figure>

<h2 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4. switch语句"></a>4. switch语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (choice) &#123;   <span class="comment">//case标签范围：类型为 char、byte、 short 或 int 的常量表达式。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">//枚举常量。</span></span><br><span class="line">        ...         <span class="comment">//从 Java SE 7开始， case 标签还可以是字符串字面量。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Size sz = . . .;</span><br><span class="line"><span class="keyword">switch</span> (sz) &#123;</span><br><span class="line">    <span class="keyword">case</span> SMALL: <span class="comment">// 无需使用Size.SMALL</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-中断控制流程语句"><a href="#5-中断控制流程语句" class="headerlink" title="5. 中断控制流程语句"></a>5. 中断控制流程语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不带标签的break语句，用于跳出当前循环</span></span><br><span class="line"><span class="keyword">while</span>(c)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带标签的break语句，用于跳出多重嵌套的循环语句,也可以应用到任何语句中。</span></span><br><span class="line"><span class="comment">//标签必须放在希望跳出的最外层循环之前， 并且必须紧跟一个冒号。</span></span><br><span class="line">read_data:</span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span> read_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">label:</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(condition) <span class="keyword">break</span> label;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continue语句跳过本次循环剩余部分，进入下一次循环</span></span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、大数值"><a href="#八、大数值" class="headerlink" title="八、大数值"></a>八、大数值</h1><p>Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算，类提供的方法参见java文档<a href="https://docs.oracle.com/javase/8/docs/api/。" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/。</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.*</span><br><span class="line"></span><br><span class="line">Biglnteger a = Biglnteger.valueOf(<span class="number">100</span>); <span class="comment">//将普通的数值转换为大数值</span></span><br><span class="line">Biglnteger c = a.add(b); <span class="comment">// c = a + b</span></span><br><span class="line">Biglnteger d = c.multiply(b.add(Biglnteger.valueOf(<span class="number">2</span>))); <span class="comment">// d = c * (b + 2) 大数值不能使用 + 和 *</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>与 C++ 不同， Java 没有提供运算符重载功能。 程序员无法重定义 <code>+</code> 和 <code>*</code> 运算符，虽然为字符串的连接重栽了<code>+</code> 运算符，但没有重载其他的运算符。</font></p>
<h1 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h1><h2 id="1-数组的创建-初始化-匿名数组"><a href="#1-数组的创建-初始化-匿名数组" class="headerlink" title="1. 数组的创建/初始化/匿名数组"></a>1. 数组的创建/初始化/匿名数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];  <span class="comment">//也可用int a[];声明数组，但是不推荐，创建一个数字数组则所有元素会被初始化为0</span></span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">100</span>]; <span class="comment">//元素初始化为 false</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">10</span>]; <span class="comment">//对象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> actualSize = . . .;</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[actualSize];   <span class="comment">//Java允许在运行时确定数组的大小。</span></span><br><span class="line"></span><br><span class="line">a.length; <span class="comment">//获取数组中元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] smallPrimes = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125;; <span class="comment">//创建数组的同时进行初始化</span></span><br><span class="line">small Primes = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;;  <span class="comment">//匿名数组初始化，可以在不创建新变量的情况下重新初始化一个数组</span></span><br><span class="line"><span class="keyword">new</span> elementType[<span class="number">0</span>];  <span class="comment">//创建一个长度为 0 的数组,与null不同。</span></span><br></pre></td></tr></table></figure>
<p>如果经常需要在运行过程中扩展数组的大小， 应该使用数组列表（array list)。</p>
<h2 id="2-数组的for-each循环"><a href="#2-数组的for-each循环" class="headerlink" title="2. 数组的for each循环"></a>2. 数组的for each循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> element : a)</span><br><span class="line">    System.out.println(element);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(a));  <span class="comment">//以[2,3,5,7,11,13]方式打印数组</span></span><br></pre></td></tr></table></figure>

<h2 id="3-数组拷贝"><a href="#3-数组拷贝" class="headerlink" title="3. 数组拷贝"></a>3. 数组拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] luckyNumbers = smallPrimes;  <span class="comment">//将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组</span></span><br><span class="line">luckyNumbers[<span class="number">5</span>] = <span class="number">12</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果数组元素是数值型，那么多余的元素将被赋值为 0 ; </span></span><br><span class="line"><span class="comment">//如果数组元素是布尔型，则将赋值为 false。</span></span><br><span class="line"><span class="comment">//相反，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</span></span><br><span class="line"><span class="keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length*<span class="number">2</span>); <span class="comment">//将一个数组的所有值拷贝到一个新的数组中去,第二个参数为新数组大小，该方法常用来增加数组大小</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>java中没有指针运算，不能通过 a+1 得到数组的下一个元素。[]被预定义为检查数组边界。</font></p>
<h2 id="4-命令行参数"><a href="#4-命令行参数" class="headerlink" title="4. 命令行参数"></a>4. 命令行参数</h2><p>main函数中的String[] args表明main 方法将接收一个字符串数组， 也就是命令行参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在命令行输入命令可读入内容到args数组中,程序名并没有存储在 args 数组中</span></span><br><span class="line">java Message -g cruel world   <span class="comment">//args[0]:"-g"  args[l]:"cruel"  args[2]:"cruel" "world"</span></span><br></pre></td></tr></table></figure>

<h2 id="4-数组排序"><a href="#4-数组排序" class="headerlink" title="4. 数组排序"></a>4. 数组排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(type[] a)</span> <span class="comment">//类型为 int、long、short、 char、 byte、boolean、float 或 double 的数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> type <span class="title">copyOf</span><span class="params">(type[]a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> type <span class="title">copyOfRange</span><span class="params">(type[]a , <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(type[] a)</span> <span class="comment">//采用优化的快速排序算法对数组进行排序。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[]a , type v)</span>    <span class="comment">//采用二分搜索算法查找值 v</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[]a, <span class="keyword">int</span> start, <span class="keyword">int</span> end, type v)</span>  <span class="comment">//类型为 int、 long、 short、 char、 byte、 boolean 、 float 或 double 的有序数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(type[]a , type v)</span> <span class="comment">//将数组的所有数据元素值设置为 V</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(type[]a, type[]b)</span> <span class="comment">//如果两个数组大小相同， 并且下标相同的元素都对应相等， 返回 true。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="5-多维数组"><a href="#5-多维数组" class="headerlink" title="5. 多维数组"></a>5. 多维数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">double</span>[][] balances = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>[][] magicSquare = &#123; &#123;<span class="number">16</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">13</span>&#125;， &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">8</span>&#125;, (<span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>&#125;, &#123;<span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span>[] row : a)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> value : row)</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速打印</span></span><br><span class="line">System.out.println(Arrays.deepToString(a)); <span class="comment">//输出[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换二维数组中的两行</span></span><br><span class="line"><span class="keyword">double</span>[] temp = balances[i];</span><br><span class="line">balances[i] = balances[i + <span class="number">1</span>];</span><br><span class="line">balances[i + <span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure>

<h2 id="6-不规则数组"><a href="#6-不规则数组" class="headerlink" title="6. 不规则数组"></a>6. 不规则数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先分配一个具有所含行数的数组</span></span><br><span class="line"><span class="keyword">int</span>[][] odds = <span class="keyword">new</span> <span class="keyword">int</span>[NMAX + <span class="number">1</span>][];</span><br><span class="line"><span class="comment">//接下来，分配这些行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= NMAX ; n++)</span><br><span class="line">    odds[n] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的对象与类</title>
    <url>/2020/04/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<p>Java 是完全面向对象(OOP)的，而面向对象更加适用于解决规模较大的问题。</p>
<h1 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h1><h2 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h2><p><strong>类</strong>：类是构造对象的模板或蓝图，由类<strong>构造对象</strong>的过程称为<strong>创建类的实例</strong>。<br><strong>封装</strong>: 从形式上看，封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。<br><strong>实例域</strong>：对象中的数据。<br><strong>方法</strong>：操纵数据的过程。<br><strong>状态</strong>：对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。<br>并不是所有的类都具有面向对象特征，例如Math类只封装了功能，它不需要也不必隐藏数据。</p>
<h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h2><p>三个主要特征：</p>
<ol>
<li>对象的行为（behavior)—可以对对象施加哪些操作，或可以对对象施加哪些方法。 </li>
<li>对象的状态（state )—对象状态的改变必须通过调用方法实现，否则会破坏封装性。 </li>
<li>对象标识（identity )—每个对象都有一个唯一的身份。</li>
</ol>
<p>对象与对象变量的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date deadline;  <span class="comment">//变量deadline不是一个对象， 实际上也没有引用对象,因此还不能将任何 Date 方法应用于这个变量上。</span></span><br><span class="line">deadline = <span class="keyword">new</span> Date();   <span class="comment">//一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</span></span><br><span class="line">                        <span class="comment">//表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 deadline 中。</span></span><br><span class="line">Date birthday = <span class="keyword">new</span> Date();</span><br><span class="line">deadline = birthday;   </span><br><span class="line"></span><br><span class="line">deadline = <span class="keyword">null</span>;  <span class="comment">//显式地将对象变量设置为 null,表明这个对象变量目前没有引用任何对象。该对象不能使用任何方法。</span></span><br><span class="line">                <span class="comment">//局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。</span></span><br></pre></td></tr></table></figure>


<h2 id="3-类之间的关系"><a href="#3-类之间的关系" class="headerlink" title="3. 类之间的关系"></a>3. 类之间的关系</h2><ol>
<li>依赖（“uses-a”）:一个类的方法操纵另一个类的对象，即一个类依赖于另一个类。又称为<font color=Crmison>耦合度</font>，实际开发中应让这种耦合最小。</li>
<li>聚合（“has-a”） :类 A 的对象包含类 B 的对象。</li>
<li>继承（“is-a”）:用于表示特殊与一般关系。如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。</li>
</ol>
<p>表示关系的UML符号：<br><img src="UML.png" alt="UML"></p>
<h1 id="二、使用预定义类"><a href="#二、使用预定义类" class="headerlink" title="二、使用预定义类"></a>二、使用预定义类</h1><h2 id="1-Java类库中的LocalDate类"><a href="#1-Java类库中的LocalDate类" class="headerlink" title="1. Java类库中的LocalDate类"></a>1. Java类库中的LocalDate类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Local Date.now(); <span class="comment">//使用类中的静态工厂方法</span></span><br><span class="line">LocalDate.of(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>); <span class="comment">//提供年、 月和日来构造对应一个特定日期的对象：</span></span><br><span class="line"></span><br><span class="line">LocalDate newYearsEve = Local Date.of(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>); <span class="comment">//将构造的对象保存在一个对象变量中供再次使用。</span></span><br><span class="line">LocalDate aThousandDaysLater = newYearsEve.plusDays(<span class="number">1000</span>); <span class="comment">//得到距当前对象指定天数的一个新日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function">LocalDate <span class="title">minusDays</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//生成当前日期之后或之前 n 天的日期。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMonthValue</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDayOfMonth</span><span class="params">( )</span> <span class="comment">//得到当前日期的年、 月和日。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">DayOfWeek getDayOfWeek</span>; <span class="comment">//得到当前日期是星期几， 作为 DayOfWeek 类的一个实例返回。 调用 getValue 来得到1 ~ 7 之间的一个数， 表示这是星期几， 1 表示星期一， 7 表示星期日。</span></span><br></pre></td></tr></table></figure>
<h2 id="2-CregorianCalendar类"><a href="#2-CregorianCalendar类" class="headerlink" title="2. CregorianCalendar类"></a>2. CregorianCalendar类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CregorianCalendar someDay = <span class="keyword">new</span> CregorianCalendar(<span class="number">1999</span>, <span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">someDay.add(Calendar.DAY_0F_M0NTH, <span class="number">1000</span>);  <span class="comment">//更改器方法</span></span><br><span class="line">year = someDay.get(Calendar.YEAR); <span class="comment">//访问器方法</span></span><br><span class="line">month = someDay.get(Calendar.MONTH)+ <span class="number">1</span>; </span><br><span class="line">day = someDay.get(Ca1endar.DAY_0F_M0NTH);</span><br></pre></td></tr></table></figure>

<h1 id="三、用户自定义类"><a href="#三、用户自定义类" class="headerlink" title="三、用户自定义类"></a>三、用户自定义类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//私有数据域</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">  <span class="keyword">private</span> Local Date hireDay;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器与类同名</span></span><br><span class="line"><span class="comment">//构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的，否则会产生编译错误。</span></span><br><span class="line"><span class="comment">//每个类可以有一个以上的构造器</span></span><br><span class="line"><span class="comment">//构造器可以有 0 个、1 个或多个参数，没有返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span> <span class="params">(String n , <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month , <span class="keyword">int</span> day)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    salary = s;</span><br><span class="line">    hireDay = Local Date,of(year, month, day);   <span class="comment">//注意， 不要在构造器中定义与实例域重名的局部变量。否则实例域会被覆盖从而使构造器失效。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//域访问器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Local Date <span class="title">getHireDay</span><span class="params">()</span> <span class="comment">//注意不要编写返回引用可变对象的访问器方法。否则会破坏封装性，由第三方改变类中的私有状态。该方法就违反了这个设计原则</span></span></span><br><span class="line"><span class="function"></span>&#123;                               <span class="comment">//如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone )。</span></span><br><span class="line">    <span class="comment">//return hireDay;</span></span><br><span class="line">    <span class="keyword">return</span> (Date)hireDay.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//域更改器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span>   <span class="comment">//raiseSalary 方法有两个参数。 第一个参数称为隐式参数， 是出现在方法名前的Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;  <span class="comment">//关键字 this 表示隐式参数</span></span><br><span class="line"> salary += raise;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-多个源文件的使用"><a href="#1-多个源文件的使用" class="headerlink" title="1. 多个源文件的使用"></a>1. 多个源文件的使用</h2><p>在开发中习惯于将每一个类存在一个单独的源文件中，这时既可以显式编译也可以隐式编译。当 Java 编译器发现 EmployeeTest.java 使用 Employee 类时会查找名为 Employee.class 的文件。如果没有找到这个文件， 就会自动地搜索 Employee.java, 然后，对它进行编译。如果 Employee,java 版本较已有的 Employee.class 文件版本新，Java 编译器就会自动地重新编译这个文件。</p>
<h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h2><p>封装一个类一般提供下面三项内容：</p>
<ol>
<li>私有的数据域；</li>
<li>公有的域访问器方法；</li>
<li>一个公有的域更改器方法。</li>
</ol>
<h2 id="3-基于类的访问权限"><a href="#3-基于类的访问权限" class="headerlink" title="3. 基于类的访问权限"></a>3. 基于类的访问权限</h2><p><font color=Crmison>类中的方法可以访问所属类对象的私有特性, 而不仅限于访问隐式参数的私有特性。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-私有方法"><a href="#4-私有方法" class="headerlink" title="4. 私有方法"></a>4. 私有方法</h2><p>绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。有些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密， 或者需要一个特别的协议以及一个特别的调用次序。在 Java 中，为了实现一个私有的方法， 只需将关键字 public 改为 private 即可。只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方法是公有的， 就不能将其删去，因为其他的代码很可能依赖它。</p>
<h2 id="5-final-实例域"><a href="#5-final-实例域" class="headerlink" title="5. final 实例域"></a>5. final 实例域</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类）。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">//必须确保在每一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于可变的类， 使用 final 修饰符可能会对读者造成混乱</span></span><br><span class="line">    <span class="comment">//final 关键字只是表示存储在 evaluations 变量中的对象引用不会再指示其他 StringBuilder对象。不过这个对象可以更改。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringBuiIcier evaluations;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、静态域与静态方法"><a href="#四、静态域与静态方法" class="headerlink" title="四、静态域与静态方法"></a>四、静态域与静态方法</h1><h2 id="1-静态域"><a href="#1-静态域" class="headerlink" title="1. 静态域"></a>1. 静态域</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextld = <span class="number">1</span>;  <span class="comment">//如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="2. 静态常量"></a>2. 静态常量</h2><p>静态变量使用得比较少，但静态常量却使用得比较多。静态常量可以被设置为public，因为final常量不允许被修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out = . . .; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h2><p>使用静态方法的两种情况：</p>
<ol>
<li>一 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow)。</li>
<li>一个方法只需要访问类的静态域。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法不能访问实例域， 因为它不能操作对象。但是，静态方法可以访问自身类中的静态域</span></span><br><span class="line"><span class="comment">//可以认为静态方法是没有 this 参数的方法。</span></span><br><span class="line"><span class="comment">//可以使用对象调用静态方法但没必要。因为静态方法与对象实例域毫无关系。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextId; <span class="comment">// returns static field  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类名调用该方法</span></span><br><span class="line"><span class="keyword">int</span> n = Employee.getNextld();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color=Crmison>如果一个域是静态的基本数据类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化的值就是null。static关键字不能应用于局部变量，因此它只能作用于域。</font></p>
</blockquote>
<h2 id="4-工厂方法"><a href="#4-工厂方法" class="headerlink" title="4. 工厂方法"></a>4. 工厂方法</h2><p>工厂方法是静态方法的另一种常见用途，类似 LocalDate 和 NumberFormat 的类使用静态工厂方法来构造对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NumberFormat currencyFormatter = NumberFormat.getCurrencylnstance();</span><br><span class="line">NumberFormat percentFormatter = NumberFormat.getPercentlnstance()；</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.1</span>;</span><br><span class="line">System.out.println(currencyFormatter.format(x)); <span class="comment">// prints $O.10</span></span><br><span class="line">System.out.println(percentFomatter.format(x)); <span class="comment">// prints 10%</span></span><br></pre></td></tr></table></figure>
<p>使用工厂方法的两个原因：</p>
<ol>
<li>无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例和百分比实例采用不用的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而 Factory 方法将返回一个 DecimalFormat类对象，这是 NumberFormat 的子类。</li>
</ol>
<h2 id="5-main方法"><a href="#5-main方法" class="headerlink" title="5. main方法"></a>5. main方法</h2><ol>
<li>main方法也是一种静态方法，不能操作所在类的实例域。静态的main 方法将执行并创建程序所需要的对象。</li>
<li>每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。可独立的对类进行测试。</li>
</ol>
<h1 id="五、方法参数"><a href="#五、方法参数" class="headerlink" title="五、方法参数"></a>五、方法参数</h1><ol>
<li><strong>按值调用</strong>：表示方法接收的是调用者提供的值，即形参为实参的一个拷贝，对形参的修改不能改变实参的值。</li>
<li><strong>按引用调用</strong>：表示方法接收的是调用者提供的变量地址。</li>
<li>Java 总是采用<font color=Crmison>按值调用</font>，方法不能修改传递给它的任何参数变量的内容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripieValue</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// doesn't work</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x = <span class="number">3</span> * x;      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;  </span><br><span class="line">tripieValue(percent);    <span class="comment">//一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span> <span class="params">(Employee x)</span> <span class="comment">// works</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x.raiseSa1ary(<span class="number">200</span>);  </span><br><span class="line">&#125;</span><br><span class="line">harry = <span class="keyword">new</span> Employee(. . .);</span><br><span class="line">tripleSalary(harry);     <span class="comment">//一个方法可以改变一个对象参数的状态。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x , Employee y)</span> <span class="comment">// doesn't work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee temp = x; </span><br><span class="line">    x = y; </span><br><span class="line">    y = temp;        <span class="comment">//一个方法不能让对象参数引用一个新的对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、对象构造"><a href="#六、对象构造" class="headerlink" title="六、对象构造"></a>六、对象构造</h1><h2 id="1-重载"><a href="#1-重载" class="headerlink" title="1. 重载"></a>1. 重载</h2><ol>
<li><strong>方法签名</strong>：要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名。返回类型不是方法签名的一部分。</li>
<li><strong>重载</strong>：多个方法有相同的名字、 不同的参数，便产生了重载。不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。</li>
<li><strong>重载解析</strong>:通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误。</li>
</ol>
<h2 id="2-默认域初始化"><a href="#2-默认域初始化" class="headerlink" title="2. 默认域初始化"></a>2. 默认域初始化</h2><ol>
<li>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。</li>
<li><font color=Crmison>域与局部变量不同，</font>必须明确地初始化方法中的局部变量。</li>
</ol>
<h2 id="3-无参数的构造器"><a href="#3-无参数的构造器" class="headerlink" title="3. 无参数的构造器"></a>3. 无参数的构造器</h2><ol>
<li>如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。</li>
<li>如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。此时必须显式提供一个不带参数的构造器才可以将所有的实例域设置为默认值。</li>
</ol>
<h2 id="4-显式域初始化"><a href="#4-显式域初始化" class="headerlink" title="4. 显式域初始化"></a>4. 显式域初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始值为常量值，用在当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时。</span></span><br><span class="line">    <span class="comment">//在执行构造器之前，先执行赋值操作。</span></span><br><span class="line">    <span class="keyword">private</span> String name =<span class="string">""</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始值不一定是常量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;  <span class="comment">//静态域在类加载时即被加载且未被赋初值的会被赋予默认值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用初始化块</span></span><br><span class="line">    <span class="comment">//在一个类的声明中，可以包含多个代码块</span></span><br><span class="line">    <span class="comment">//首先运行初始化块，然后才运行构造器的主体部分。</span></span><br><span class="line">    <span class="comment">//不常见</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextld;</span><br><span class="line">        nextld++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类第一次加载的时候， 将会进行静态域的初始化</span></span><br><span class="line">    <span class="comment">//所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">        nextld = generator.nextInt(lOOOO); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 Java SE 7 以后，java 程序首先会检查是否有一个 main 方法。</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Hel1o, World"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>域初始化的顺序很复杂，调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值（0、false 或 null）。</li>
<li><font color=Crmison>按照在类声明中出现的次序</font>， 依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li>
<li>执行这个构造器的主体。</li>
</ol>
<h2 id="5-参数名"><a href="#5-参数名" class="headerlink" title="5. 参数名"></a>5. 参数名</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String aNaie, <span class="keyword">double</span> aSalary)</span> </span>&#123;</span><br><span class="line">    name = aName ;</span><br><span class="line">    salary = aSalary; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String naie, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>,sal ary = salary; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-利用this调用同一个类中的另一个构造器"><a href="#6-利用this调用同一个类中的另一个构造器" class="headerlink" title="6. 利用this调用同一个类中的另一个构造器"></a>6. 利用this调用同一个类中的另一个构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可有效减少代码重复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123; <span class="comment">// calls Employee(String, double)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Employee #"</span> + nextld, s);</span><br><span class="line">    nextld++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、包"><a href="#七、包" class="headerlink" title="七、包"></a>七、包</h1><p>使用包的主要原因是确保类名的唯一性，而不会产生冲突。</p>
<h2 id="1-类的导入"><a href="#1-类的导入" class="headerlink" title="1. 类的导入"></a>1. 类的导入</h2><p>一个类可以使用所属包中的所有类， 以及其他包中的公有类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.time.LocalDate today = java.tine.LocalDate.now();  <span class="comment">//繁琐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//import 语句应该位于源文件的顶部(但位于 package 语句的后面)。</span></span><br><span class="line"><span class="comment">//只能使用星号（*) 导入一个包， 而不能使用 import java.* 或import java.*.* 导入以 java 为前缀的所有包。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">LocalDate today = Local Date.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时若在程序直接使用 Date 类的时候， 就会出现一个编译错误，因为二者均包含Date类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可明确指出使用哪个包中的Date</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若两个Date均需要使用应添加上完整包名</span></span><br><span class="line">java.util.Date deadline = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">java.sql.Date today = <span class="keyword">new</span> java.sql.Date(...);</span><br></pre></td></tr></table></figure>
<h2 id="2-静态导入"><a href="#2-静态导入" class="headerlink" title="2. 静态导入"></a>2. 静态导入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line">out.println(<span class="string">"Goodbye, World!"</span>); <span class="comment">// System.out</span></span><br><span class="line">exit(<span class="number">0</span>); <span class="comment">//System.exit</span></span><br></pre></td></tr></table></figure>

<h2 id="3-将类放入包中"><a href="#3-将类放入包中" class="headerlink" title="3. 将类放入包中"></a>3. 将类放入包中</h2><p>如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包(没有名字)中。<br><img src="%E5%8C%85%E7%9B%AE%E5%BD%95.png" alt="包目录"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstmann.corejava;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line">javac PackageTest.java</span><br><span class="line">javac com/horstmann/corejava/Employee.java</span><br></pre></td></tr></table></figure>
<p><font color=Crmison>编译器在编译源文件的时候不检查目录结构。</font>如果源文件不在指定package中且不依赖于其他包， 就不会出现编译错误。但是， 最终的程序将无法运行，因为虚拟机找不到类。</p>
<h2 id="4-包作用域"><a href="#4-包作用域" class="headerlink" title="4. 包作用域"></a>4. 包作用域</h2><ol>
<li>标记为 public 的部分可以被任意的类使用；</li>
<li>标记为 private 的部分只能被定义它们的类使用。</li>
<li>如果没有指定 public 或 private , 这个部分（类、方法或变量）可以被同一个包中的所有方法访问。</li>
</ol>
<h1 id="八、类路径"><a href="#八、类路径" class="headerlink" title="八、类路径"></a>八、类路径</h1><p>类路径是所有包含类文件的路径的集合。<br>类路径包含三种情况：</p>
<ol>
<li>基目录 /home/user/classdir 或 c:\classes</li>
<li>当前目录 (.); </li>
<li>JAR 文件 /home/user/archives/archive.jar 或c:\archives\archive.jar</li>
</ol>
<p>类路径所列出的目录和归档文件是搜寻类的起始点。</p>
<h2 id="1-虚拟机搜寻类文件的过程"><a href="#1-虚拟机搜寻类文件的过程" class="headerlink" title="1. 虚拟机搜寻类文件的过程"></a>1. 虚拟机搜寻类文件的过程</h2><ol>
<li>首先要查看存储在 jre/lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。</li>
<li>若找不到相应类文件，再查看类路径。</li>
</ol>
<blockquote>
<p>/home/user/classdir/com/horstmann/corejava/Employee.class<br>com/horstmann/corejava/Employee.class 从当前目录开始<br>com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</p>
</blockquote>
<h2 id="2-编译器搜寻类文件的过程"><a href="#2-编译器搜寻类文件的过程" class="headerlink" title="2. 编译器搜寻类文件的过程"></a>2. 编译器搜寻类文件的过程</h2><ol>
<li>如果引用了一个类，而没有指出这个类所在的包， 那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。</li>
<li>如果找到了一个以上的类， 就会产生编译错误。</li>
<li>编译器还要查看源文件是否比类文件新，如果是这样的话，那么源文件就会被自动地重新编译。</li>
</ol>
<h2 id="3-设置类路径"><a href="#3-设置类路径" class="headerlink" title="3. 设置类路径"></a>3. 设置类路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用 -classpath (或 -cp) 选项指定类路径</span></span><br><span class="line">java -classpath /home/user/dassdir: .:/home/user/archives/archive.jar HyProg</span><br><span class="line">java -classpath c:\classdir; .;c:\archives\archive.jar MyProg</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 CLASSPATH 环境变量</span></span><br><span class="line">export CLASSPATH=/home/user/classdir:.:/ home/user/archives/archive.jar  <span class="comment">//Bourne Again shell ( bash)</span></span><br><span class="line">set CLASSPATH=c:\classdir;.;c:\archives\archive.jar <span class="comment">//Windows shell</span></span><br></pre></td></tr></table></figure>

<h1 id="九、文档注释"><a href="#九、文档注释" class="headerlink" title="九、文档注释"></a>九、文档注释</h1><p>利用JDK中的javadoc命令工具，可以由源文件生成一个 HTML 注释(/** */)文档。文档注释与源代码在同一个文件中，在修改源代码的同时， 重新运行 javadoc 就可以轻而易举地保持两者的一致性。</p>
<h2 id="1-注释的插入"><a href="#1-注释的插入" class="headerlink" title="1. 注释的插入"></a>1. 注释的插入</h2><p>javadoc抽取信息生成文档的位置如下，也应当在这些位置编写注释：</p>
<ol>
<li>包 </li>
<li>公有类与接口</li>
<li>公有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ol>
<p>文档注释的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自由格式文本：标记如<span class="doctag">@author</span>或 <span class="doctag">@param</span>等</span></span><br><span class="line"><span class="comment">* 第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽取出来形成概要页。</span></span><br><span class="line"><span class="comment">* 在自由格式文本中，可以使用 HTML 修饰符，如&lt;em&gt;&lt;/em&gt;等</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-类注释"><a href="#2-类注释" class="headerlink" title="2. 类注释"></a>2. 类注释</h2><p>类注释必须放在 import 语句之后，类定义之前。</p>
<h2 id="3-方法注释"><a href="#3-方法注释" class="headerlink" title="3. 方法注释"></a>3. 方法注释</h2><p>每一个方法注释必须放在所描述的方法之前。可以使用以下标记：<br><code>@param</code>:对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。<br><code>@return</code>:这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。<br><code>©throws</code>:这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。</p>
<h2 id="4-域注释"><a href="#4-域注释" class="headerlink" title="4. 域注释"></a>4. 域注释</h2><p>只需要对公有域（通常指的是静态常量）建立文档。</p>
<h2 id="5-通用注释"><a href="#5-通用注释" class="headerlink" title="5. 通用注释"></a>5. 通用注释</h2><p>用于类文档的注释中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 姓名</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@deprecated</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@see</span> 引用   <span class="doctag">@see</span> com.horstraann.corejava.Employee#raiseSalary(double) </span></span><br><span class="line"><span class="comment">            <span class="doctag">@see</span> &lt;a href="m«w.horstmann . com/corejava. htinl "&gt;The Core ]ava home page&lt;/a&gt;</span></span><br><span class="line"><span class="comment">            Isee "Core Java 2 volume 2n</span></span><br><span class="line"><span class="comment">&#123;<span class="doctag">@link</span> package.class#feature label &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-包与概述注释"><a href="#6-包与概述注释" class="headerlink" title="6. 包与概述注释"></a>6. 包与概述注释</h2><p>要想产生包注释，就需要在每一个包目录中添加一个单独的文件。有两种方式添加：</p>
<ol>
<li>提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;—&lt;/body&gt; 之间的所有文本都会被抽取出来。</li>
<li>提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** 和 */ 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。</li>
</ol>
<p>还可以为所有的源文件提供一个概述性的注释。名为overview,html 的文件中，这个文件位于包含所有源文件的父目录中。标记&lt;body&gt;—&lt;/body&gt;间的所有文本将被抽取出来。</p>
<h2 id="7-注释的抽取"><a href="#7-注释的抽取" class="headerlink" title="7. 注释的抽取"></a>7. 注释的抽取</h2><p>详见<a href="http://docs.oracle.com/javase/8/docs/guides/javadoc" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/guides/javadoc</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//docDirectory为HTML文件的存放目录</span></span><br><span class="line"><span class="number">1</span>. 切换到包含想要生成文档的源文件目录。</span><br><span class="line"><span class="number">2</span>. javadoc -d docDirectory nameOfPackage   <span class="comment">//如果省略了 -d docDirectory 选项， 那 HTML 文件就会被提取到当前目录下。</span></span><br><span class="line"><span class="number">3</span>. javadoc -d docDirectory nameOfPackage1 nameOfPackage2 . . .</span><br><span class="line"><span class="number">4</span>. javadoc -d docDirectory *.java  <span class="comment">//文件在默认包中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用 -author 和 -version 选项在文档中包含@author 和@version 标记（默认情况下，这些标记会被省略)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用-link为标准类添加超链接</span></span><br><span class="line">javadoc -link http:<span class="comment">//docs.oracle.eom/:javase/8/docs/api *.java  //所有的标准类库类都会自动地链接到 Oracle 网站的文档。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 -linksource 选项，则每个源文件被转换为 HTML (不对代码着色，但包含行编号) 并且每个类和方法名将转变为指向源代码的超链接。</span></span><br></pre></td></tr></table></figure>

<h1 id="十、类设计技巧"><a href="#十、类设计技巧" class="headerlink" title="十、类设计技巧"></a>十、类设计技巧</h1><ol>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型</li>
<li>不是所有的域都需要独立的域访问器和域更改器</li>
<li>将职责过多的类进行分解</li>
<li>类名和方法名要能够体现它们的职责</li>
<li>优先使用不可变的类</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的继承</title>
    <url>/2020/05/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="一、类、超类和子类"><a href="#一、类、超类和子类" class="headerlink" title="一、类、超类和子类"></a>一、类、超类和子类</h1><h2 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="1. 定义子类"></a>1. 定义子类</h2><p>已存在的类称为超类、基类或父类; 新类称为子类、派生类或孩子类。在设计类时，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> //在 <span class="title">Java</span> 中， 所有的继承都是公有继承</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//定义子类特有数据域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义子类特有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;  <span class="comment">//属于 Employee 类的对象不能使用该方法，但Manager 类自动地继承了超类 Employee 中的方法。</span></span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus; </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖超类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();  <span class="comment">//子类不能直接访问超类的私有域，应通过关键字super调用超类的域访问器来访问。</span></span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。</span></span><br><span class="line">        <span class="comment">//如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器， 则 Java 编译器将报告错误。</span></span><br><span class="line">        <span class="comment">//调用构造器的语句只能作为另一个构造器的第一条语句出现。</span></span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);  <span class="comment">//通过 super调用超类构造器实现对超类私有域进行初始化</span></span><br><span class="line">        bonus = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Manager boss = <span class="keyword">new</span> Manager(<span class="string">"Carl Cracker"</span> , <span class="number">80000</span>，<span class="number">1987</span>, <span class="number">12</span> , <span class="number">15</span>);</span><br><span class="line">boss.setBonus(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;  <span class="comment">//变量 staff[0] 与 boss 引用同一个对象。但编译器将 staff[0]看成 Employee 对象。故staff[0]不能调用子类特有方法setBonus()</span></span><br><span class="line">staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, <span class="number">50000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">"Tony Tester"</span> , <span class="number">40000</span>, <span class="number">1990</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Employee e : staff)         <span class="comment">//e 既可以引用 Employee 类型的对象，也可以引用 Manager 类型的对象。</span></span><br><span class="line">    System.out.println(e.getName() + <span class="string">" "</span> + e.getSalary());  <span class="comment">//虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。</span></span><br></pre></td></tr></table></figure>
<ol>
<li>super关键字与this引用不同，它不是一个对象引用，它只是一个指示编译器调用超类方法的特殊关键字。</li>
<li>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。</li>
<li>在覆盖方法时， 一定要保证返回类型的兼容性。<font color=Crmison>允许子类将覆盖方法的返回类型定义为原返回类型的子类型。</font>称该方法具有<strong>可协变的返回类型</strong></li>
<li><font color=Crmison>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</font> </li>
</ol>
<blockquote>
<p><strong>多态</strong>：一个对象变量可以指示多种实际类型的现象被称为多态。<br><strong>动态绑定</strong>：在<strong>运行时</strong>能够自动地选择调用哪个方法的现象称为动态绑定。<br><strong>静态绑定</strong>：如果是 private 方法、 static 方法、 final 方法或者构造器， 那么<strong>编译器</strong>将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定。</p>
</blockquote>
<h2 id="2-继承层次"><a href="#2-继承层次" class="headerlink" title="2. 继承层次"></a>2. 继承层次</h2><p><strong>继承层次</strong>：由一个公共超类派生出来的所有类的集合被称为继承层次。<br><strong>继承链</strong>：从某个特定的类到其祖先的路径被称为该类的继承链。<br><font color=Crmison>Java 不支持多继承(extends)。</font></p>
<h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h2><ol>
<li>即超类变量既可以引用一个超类对象， 也可以引用一个超类的任何一个子类的对象。</li>
<li>不能将一个超类的引用赋给子类变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 Java 中，子类数组的引用可以转换成超类数组的引用， 而不需要采用强制类型转换。</span></span><br><span class="line">Manager[] managers = <span class="keyword">new</span> Manager[<span class="number">10</span>];</span><br><span class="line">EmployeeQ staff = managers; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有数组都要牢记创建它们的元素类型， 并负责监督仅将类型兼容的引用存储到数组中。</span></span><br><span class="line"><span class="comment">//这里使用 new managers[10] 创建的数组是一个经理数组。如果试图存储一个 Employee 类型的引用就会引发 ArrayStoreException 异常。</span></span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, . . .); <span class="comment">//ArrayStoreException 异常</span></span><br></pre></td></tr></table></figure>

<h2 id="4-理解方法调用"><a href="#4-理解方法调用" class="headerlink" title="4. 理解方法调用"></a>4. 理解方法调用</h2><p>x.f(param)调用过程：</p>
<ol>
<li>编译器査看对象的声明类型和方法名。编译器将会一一列举所有x所声明类中名为f的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）。</li>
<li>编译器进行重载解析。以获得需要调用的方法名字和参数类型。</li>
<li>编译器采用静态绑定或动态绑定方式生成一条调用f(param)的指令。</li>
<li>当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x <strong>所引用对象的实际类型</strong>最合适的那个类的方法。若没有则在其超类中寻找。</li>
</ol>
<p>虚拟机预先为每个类创建了一个方法表, 其中列出了所有方法(包括继承的方法)的签名和实际调用的方法。这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。</p>
<h2 id="5-阻止继承：final-类和方法"><a href="#5-阻止继承：final-类和方法" class="headerlink" title="5. 阻止继承：final 类和方法"></a>5. 阻止继承：final 类和方法</h2><p>不允许扩展的类被称为 final 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Executive</span> <span class="keyword">extends</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  <span class="comment">//final方法不能被覆盖</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-强制类型转换"><a href="#6-强制类型转换" class="headerlink" title="6. 强制类型转换"></a>6. 强制类型转换</h2><p>将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检査。但是只有引用子类变量的超类引用可以被强制类型转换为子类引用。一般只有在会使用到 Manager 中特有的方法时才需要进行类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能在继承层次内进行类型转换。 </span></span><br><span class="line"><span class="comment">//在将超类转换成子类之前，应该使用instanceof进行检查。</span></span><br><span class="line">Manager boss = (Manager)staff[<span class="number">0</span>];   <span class="comment">//ok</span></span><br><span class="line">Manager boss = (Manager)staff[<span class="number">1</span>]; <span class="comment">// Error  //若未捕获ClassCastException 异常，程序就会终止执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager) </span><br><span class="line">&#123;</span><br><span class="line">    boss = (Manager)staff[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x <span class="keyword">instanceof</span> C  <span class="comment">//若x为null则不会产生异常只是返回false。</span></span><br></pre></td></tr></table></figure>

<h2 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7. 抽象类"></a>7. 抽象类</h2><p>抽象类一般作为派生其他类的基类，而不作为想使用的特定的实例类。通常它只包含一些通用的属性和方法，而这些通用方法往往只是一个定义不需要具体的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用abstract关键字修饰方法就无需实现该方法</span></span><br><span class="line"><span class="comment">//包含一个或多个抽象方法的类本身必须被声明为抽象的。</span></span><br><span class="line"><span class="comment">//抽象类的子类也可以为抽象类</span></span><br><span class="line"><span class="comment">//类即使不含抽象方法，也可以将类声明为抽象类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不能被实例化。可以定义一个抽象类的对象变量，但是不能构造抽象类对象，它只能引用非抽象子类的对象。</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student(<span class="string">"Vinee Vu"</span> , <span class="string">"Economics"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="8-受保护访问"><a href="#8-受保护访问" class="headerlink" title="8. 受保护访问"></a>8. 受保护访问</h2><ol>
<li>由于类中的私有域对所有其他类包括子类都是不可见的，因此若子类的方法想访问超类的某个域或方法，可将超类中的方法或域声明为protected。但子类方法中只能访问属于该类的对象的protected方法而不能访问其它子类对象的受保护方法。</li>
<li>不过<font color=Crmison>子类中的方法只能够访问子类对象中继承的超类的受保护域，而不能访问超类对象中的这个域，如此可避免滥用受保护机制。</font></li>
<li>在实际应用中，要谨慎使用 <strong>protected 属性</strong>。因为有可能会违背OOP提倡的数据封装原则。</li>
<li><strong>受保护的方法</strong>更具有实际意义。它对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。</li>
</ol>
<h2 id="9-控制可见性的4个访问修饰符"><a href="#9-控制可见性的4个访问修饰符" class="headerlink" title="9. 控制可见性的4个访问修饰符"></a>9. 控制可见性的4个访问修饰符</h2><p><strong>private</strong>:仅对本类可见。<br><strong>public</strong>:对所有类可见。<br><strong>protected</strong>:对本包和所有子类可见。<br><strong>默认</strong>：对本包可见。<br>其中只有public和默认可用于修饰类。</p>
<h1 id="二、Object是所有类的超类"><a href="#二、Object是所有类的超类" class="headerlink" title="二、Object是所有类的超类"></a>二、Object是所有类的超类</h1><ol>
<li>可以使用 Object 类型的变量引用任何类型的对象。</li>
<li>在 Java 中，只有基本类型不是对象。</li>
<li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, <span class="number">35000</span>);</span><br><span class="line">Employee e = (Employee)obj ;</span><br><span class="line"></span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">obj = staff; <span class="comment">// OK</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="1. equals方法"></a>1. equals方法</h2><p>是基类Object中的一个可覆盖方法，在基类中，该方法与<code>==</code>运算符等价，比较的都是对象的内存地址， 可在子类中覆盖改写该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//equals方法改写原则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//若引用同一个对象则返回true,实际是比较两个对象的默认hashcode是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//若显示参数为null则返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测。</span></span><br><span class="line">        <span class="comment">//如果所有的子类都拥有统一的语义，就使用 instanceof 检测。</span></span><br><span class="line">        <span class="comment">//if (!(otherObject instanceof ClassName)) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//若两个对象所属的类不同则返回false，getClass 方法将返回一个对象所属的类</span></span><br><span class="line">                                                                </span><br><span class="line">        <span class="comment">//比较两个相同类的不为null的对象的数据域是否相等</span></span><br><span class="line">        Employee other = (Employee)otherObject; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果两个参数都为 null， Objects.equals(a，b) 调用将返回 true; 如果其中一个参数为 null ,则返回 false ; 否则， 如果两个参数都不为 null，则调用 a.equals(b)</span></span><br><span class="line">        <span class="comment">// //使用 =比较基本类型域，使用 equals 比较对象域。</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name,other.name) &amp;&amp; salary == other.salary </span><br><span class="line">                &amp;&amp; Object.equals(hireDay,other.hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(otherObject)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//在子类中定义 equals 方法时，首先调用超类的 equals,若检测失败对象就不可能相等。</span></span><br><span class="line">        Manager other = (Manager)otherObject;          </span><br><span class="line">        <span class="keyword">return</span> bonus == other.bonus; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-相等测试与继承"><a href="#2-相等测试与继承" class="headerlink" title="2. 相等测试与继承"></a>2. 相等测试与继承</h2><p>设计equals方法的原则：<br><strong>自反性：</strong>对于任何非空引用 x, x.equals(x) 应该返回 true。<br><strong>对称性：</strong>对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true , x.equals(y) 也应该返回 true。<br><strong>传递性：</strong>对于任何引用 x、y 和 z, 如果 x.equals(y) 返回 true， y.equals(z) 返回 true, x.equals(z) 也应该返回 true。<br><strong>一致性：</strong>如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。<br>对于任意非空引用 x, x.equals(null) 应该返回 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(type[]a , type[] b)</span>   <span class="comment">//如果两个数组长度相同， 并且在对应的位置上数据元素也均相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span>  <span class="comment">//如果a和b都为null，返回true;如果只有其中之一为 null，则返回false;否则返回a.equals(b)。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-hashCode方法"><a href="#3-hashCode方法" class="headerlink" title="3. hashCode方法"></a>3. hashCode方法</h2><p>由于 hashCode方法定义在 Object 类中， 因此每个对象都有一个默认的散列码，其值为对象的存储地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String的散列码是由内容导出的</span></span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length0；i++)</span><br><span class="line">    hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder 类中没有定义hashCode 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在重写hashcode方法时可以调用 Objects.hash并提供多个参数，这个方法会对各个参数调用 Objects.hashCode，并组合这些散列值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects,hash(name, salary, hireDay); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object . .. objects)</span> <span class="comment">//返回一个散列码，由提供的所有对象的散列码组合而得到。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a )</span>  <span class="comment">//如果 a 为 null 返回 0， 否则返回 a.hashCode()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">((int11ong|<span class="keyword">short</span>|<span class="keyword">byte</span>|<span class="keyword">double</span>|f1oat|<span class="keyword">char</span>|<span class="keyword">boolean</span>)</span> value) <span class="comment">//返回给定值的散列码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(type[] a )</span> <span class="comment">//计算数组 a 的散列码。这个散列码由数组元素的散列码组合得到。</span></span></span><br></pre></td></tr></table></figure>
<p>java规定<font color=Crmison>如果重新定义 equals方法，就必须重新定义 hashCode 方法。</font>因为Hashcode是用于散列数据的快速存取的，如利用 HashSet/HashMap/HashTable类来存储数据时，都是根据存储对象的hashcode值来判断是否相同。如果我们对一个对象重写了 equals方法，意思是只要对象的成员变量的值相等那么equals就返回true，但不重写hashcode方法，那么我们再new一个新的对象的时候，当原对象.equals(新对象)等于true的时候，两者的hashcode值是不相等的。由此产生了理解上的不一致，比如在存储散列集合（如Set类）的时候，将会存储了两个一样的对象，导致混淆，因此，<font color=Crmison>也就必须重写hashcode方法,且Equals与hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( )就必须与 y.hashCode( ) 具有相同的值。</font></p>
<h2 id="4-toString方法"><a href="#4-toString方法" class="headerlink" title="4. toString方法"></a>4. toString方法</h2><p>Object 类定义了 toString 方法， 用来打印输出对象所属的类名和散列码即<code>类名@散列码</code>。toString方法是一种非常有用的调试工具。在标准类库中，许多类都定义了 toString方 法， 以便用户能够获得一些有关对象状态的必要信息。因此java建议为自定义的每一个类增加 toString 方法。<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.out);  <span class="comment">//因为 PrintStream 类的设计者没有覆盖 toString方法故得到java.io.PrintStream@2f6684的结果。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()  <span class="comment">//getClaSS( ).getName( ) 获得类名的字符</span></span><br><span class="line">串</span><br><span class="line">        + <span class="string">"[name="</span> + name</span><br><span class="line">        + <span class="string">",salary="</span> + salary</span><br><span class="line">        + <span class="string">",hireDay="</span> + hireDay</span><br><span class="line">        + <span class="string">"]"</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString()</span><br><span class="line">        + <span class="string">"[bonus="</span> + bonus</span><br><span class="line">        + <span class="string">"]"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);          </span><br><span class="line">String message = <span class="string">"The current position is "</span> + p;  <span class="comment">//此处编译器会自动的调用p.toString()方法，以便获得这个对象的字符串描述。</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span>+x;  <span class="comment">//可替代x.toString()的调用，与 toString 不同的是，如果 x 是基本类型，这条语句照样能够执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] luckyNumbers = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125; ;  </span><br><span class="line">String s = <span class="string">""</span> + luckyNumbers;       <span class="comment">//[I@la46e30（前缀 [I 表明是一个整型数组）。</span></span><br><span class="line">String s = Arrays.toString(luckyNumbers);   <span class="comment">//[2,3,5,7,11,13]</span></span><br><span class="line"></span><br><span class="line">Arrays.deepToString;  <span class="comment">//打印多维数组</span></span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getSuperclass</span><span class="params">( )</span></span>;  <span class="comment">//以 Class 对象的形式返回这个类的超类信息。</span></span><br></pre></td></tr></table></figure></p>
<h1 id="三、泛型数组列表ArrayList"><a href="#三、泛型数组列表ArrayList" class="headerlink" title="三、泛型数组列表ArrayList"></a>三、泛型数组列表ArrayList</h1><p>ArrayList 是一个采用类型参数的泛型类,它在添加或删除元素时， 具有自动调节数组容量的功能。<font color=Crmison>&lt;&gt;中的类型不能是基本数据类型。</font></p>
<h2 id="1-创建ArrayList"><a href="#1-创建ArrayList" class="headerlink" title="1. 创建ArrayList"></a>1. 创建ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();  <span class="comment">//构造一个空数组列表</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//可以结合new操作符使用“菱形”语法,编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，编译器会检査这个变量、 参数或</span></span><br><span class="line">                                                <span class="comment">//方法的泛型类型，然后将这个类型放在&lt;&gt;中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 Java SE 5.0 以后的版本中， 没有后缀 &lt;...&gt; 仍然可以使用ArrayList, 它将被认为是一个删去了类型参數的“ 原始” 类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象</span></span><br><span class="line">staff.add(<span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, ...)); <span class="comment">//在数组列表的尾端添加一个元素，如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</span></span><br><span class="line"></span><br><span class="line">staff.ensureCapacity(l00);  <span class="comment">//可以指定数组大小，则在100次调用add之间不用重新分配空间。</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;(l00); <span class="comment">//可以把初始容量传递给 ArrayList 构造器。表明它拥有保存100个元素的潜力，重新分配空间的话会超过100</span></span><br><span class="line"></span><br><span class="line">staff.size();  <span class="comment">//返回数组列表中包含的实际元素数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">( )</span>  <span class="comment">//将数组列表的存储容量削减到当前尺寸。垃圾回收器将回收多余的存储空间。应该在确认不会添加任何元素时，再调用该方法否则添加元素时需要花时间再次移动存储块。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-访问数组列表元素"><a href="#2-访问数组列表元素" class="headerlink" title="2. 访问数组列表元素"></a>2. 访问数组列表元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.set(i, harry);  <span class="comment">//设置第i个元素，只有i小于或等于数组列表中当前实际元素个数时才可以调用。</span></span><br><span class="line"></span><br><span class="line">Employee e = staff.get(i);  <span class="comment">//获得数组列表的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//灵活扩展数组</span></span><br><span class="line">ArrayList&lt;X&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (. . .) </span><br><span class="line">&#123; </span><br><span class="line">    x = . .;</span><br><span class="line">    list.add(x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方便访问数组</span></span><br><span class="line">X[] a = <span class="keyword">new</span> X[list.size()];</span><br><span class="line">list.toArray(a); </span><br><span class="line"></span><br><span class="line">staff.add(i,e);  <span class="comment">//在数组列表的中间插入元素</span></span><br><span class="line">Employee e = staff.remove(i);  <span class="comment">//从数组列表中间删除一个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Employee e : staff)   <span class="comment">//可以使用“ foreach” 循环遍历数组列表：</span></span><br></pre></td></tr></table></figure>

<h2 id="3-类型化与原始数组列表的兼容性"><a href="#3-类型化与原始数组列表的兼容性" class="headerlink" title="3. 类型化与原始数组列表的兼容性"></a>3. 类型化与原始数组列表的兼容性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ArrayList list)</span> </span>&#123; . . . &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">find</span><span class="params">(String query)</span> </span>&#123; . . . &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee〉staff = . . .;   <span class="comment">//可以将一个类型化的数组列表传递给 update 方法,无需任何类型转换，但是这样不安全</span></span><br><span class="line">employeeDB.update(staff);   <span class="comment">//也可以将 staff 对象传递给 update 方法。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) ArrayList&lt;Employee&gt; result = employeeDB.find(query);  <span class="comment">//将一个原始 ArrayList 赋给一个类型化 ArrayList 会得到一个警告。一旦能确保不会造成严重的后果，可以用@SuppressWamings("unchecked") 标注来标记这个变量能够接受类型转换。</span></span><br></pre></td></tr></table></figure>

<h1 id="四、对象包装器与自动装箱"><a href="#四、对象包装器与自动装箱" class="headerlink" title="四、对象包装器与自动装箱"></a>四、对象包装器与自动装箱</h1><ol>
<li><strong>包装器：</strong>所有的基本类型都有一个与之对应的类，称为包装器。Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean (前 6 个类派生于公共的超类 Number)。<font color=Crmison>对象包装器是不可变的，不可改变其值，还是final的，不可定义其子类。</font></li>
<li>自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到<strong>固定的对象</strong>中。此时若用<code>==</code>比较两个值相同的包装器对象则一定为true。</li>
<li>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   <span class="comment">//效率远低于int[],仅在构造小型集合时使用它。</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">3</span>);  <span class="comment">//自动装箱；会自动变换为list.add(Integer.valueOf(3));</span></span><br><span class="line"><span class="keyword">int</span> n = list.get(i);  <span class="comment">//自动拆箱；会自动翻译成 int n = list.get(i).intValue();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//算术表达式中也能自动装箱和拆箱</span></span><br><span class="line">Integer n = <span class="number">3</span>;</span><br><span class="line">n++;    <span class="comment">//编译器会自动地插入一条对象拆箱的指令， 然后进行自增计算， 最后再将结果装箱。</span></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">1000</span>;</span><br><span class="line">Integer b = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b)    <span class="comment">//一般为false，而java中若将经常出现的值包装到同一个对象中，这种比较就有可能成立。为了避免这种不确定性，一般在两个包装器对象比较时调用 equals 方法。</span></span><br><span class="line"></span><br><span class="line">Integer n = <span class="keyword">null</span>;  <span class="comment">//可以引用null</span></span><br><span class="line">System.out.println(<span class="number">2</span> * n);  <span class="comment">//会抛出一个 NullPointerException 异常</span></span><br><span class="line"></span><br><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">Double x = <span class="number">2.0</span>;</span><br><span class="line">System.out.println(<span class="keyword">true</span> ? n : x);  <span class="comment">//输出1.0；如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱，提升为 double, 再装箱为 Double。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = Integer.parseInt(s);  <span class="comment">//将字符串转换成整型。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">(IntHolder x)</span>   <span class="comment">//org.omg.CORBA 包中定义的持有者类型， 包括 IntHolder、BooleanHolder 等，都包含一个公有域值，可以改变x的值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     x.value = <span class="number">3</span> * x.value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i )</span>  <span class="comment">//以一个新 String 对象的形式返回给定数值 i 的十进制表示。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> radix )</span>  <span class="comment">//返回数值 i 的基于给定 radix 参数进制的表示。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,<span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Static Integer <span class="title">valueOf</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Number <span class="title">parse</span><span class="params">(String s)</span>  <span class="comment">//返回数字值，假设给定的 String 表示了一个数值。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="五、参数数量可变的方法"><a href="#五、参数数量可变的方法" class="headerlink" title="五、参数数量可变的方法"></a>五、参数数量可变的方法</h1><p>也称为变参方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//printf方法的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String fmt , Object... args)</span>   <span class="comment">//... 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除 fmt参数之外）。Object…参数类型与 Object[]完全一样。</span></span></span><br><span class="line"><span class="function">        </span>&#123;                                                   <span class="comment">//如果调用者提供的是整型数组或者其他基本类型的值，自动装箱功能将把它们转换成对象。</span></span><br><span class="line">            <span class="keyword">return</span> format(fmt, args);                       <span class="comment">//现在将扫描 fmt 字符串， 并将第 i 个格式说明符与 args[i] 的值匹配起来。</span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"%d %s"</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">new</span> Integer(n), <span class="string">"widgets"</span> &#125; ); <span class="comment">//编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上，并在必要的时候进行自动装箱.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义变参方法:计算若干个数值的最大值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span> <span class="params">(<span class="keyword">double</span>... values)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> largest = Double.NECATIVEJNFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> v : values) </span><br><span class="line">        <span class="keyword">if</span> (v &gt; largest) largest = v;</span><br><span class="line">    <span class="keyword">return</span> largest; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> m = max(<span class="number">3.1</span>, <span class="number">40.4</span>, -<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span></span><br></pre></td></tr></table></figure>
<p>允许将一个数组传递给可变参数方法的<strong>最后一个参数</strong>,因此，可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。</p>
<h1 id="六、枚举类"><a href="#六、枚举类" class="headerlink" title="六、枚举类"></a>六、枚举类</h1><p>所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL , MEDIUM, LARGE, EXTRAJARGE &#125;;  <span class="comment">//实际上定义了一个类刚好有4个实例，由于Enum中equlas方法直接用==实现，故在比较两个枚举变量值时直接使用==即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在枚举类型中添加一些构造器、 方法和域。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size</span><br><span class="line">&#123;</span><br><span class="line">    SMALL(<span class="string">"S"</span>), MEDIUM(<span class="string">"M"</span>), LARGE(<span class="string">"L"</span>), EXTRA_LARGE(<span class="string">"XL"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span> </span>&#123; <span class="keyword">this</span>,abbreviation = abbreviation; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> abbreviation; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Size.SMALL.toString();  <span class="comment">//返回字符串"SMALL"。</span></span><br><span class="line">Size s = Enum.valueOf(Size,class, "SMALL");  //将 s 设置成 Size.SMALL</span><br><span class="line"></span><br><span class="line">Size[] values = Size.values();  <span class="comment">//返回一个包含全部枚举值的数组。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordinal</span> <span class="params">()</span>  <span class="comment">//返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( E other )</span> <span class="comment">//如果枚举常量出现在 Other 之前， 则返回一个负值；如果 this=other，则返回 0; 否则，返回正值。枚举常量的出现次序在 enum 声明中给出。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h1><p>能够分析类能力的程序称为反射，反射库提供了一个非常丰富且精心设计的工具集，使用它的主要人员是工具构造者，而不是应用程序员。反射的功能：</p>
<ol>
<li>在运行时分析类的能力。</li>
<li>在运行时查看对象，例如，编写一个 toString 方法供所有类使用。</li>
<li>实现通用的数组操作代码。</li>
<li>利用 Method 对象， 这个对象很像C++中的函数指针。</li>
</ol>
<h2 id="1-Class类"><a href="#1-Class类" class="headerlink" title="1. Class类"></a>1. Class类</h2><p>Class类中保存着Java 运行时系统始终为所有对象维护的一个被称为运行时的类型标识，虚拟机利用运行时类型信息选择相应的方法执行。通过Class类可以访问这些信息。一个Class对象将表示<strong>一个特定类的属性</strong>。<br>Class 类实际上是一个<strong>泛型类</strong>。例如， Employee.class 的类型是 Class&lt;Employee&gt;,但是它将已经抽象的概念更加复杂化了。在大多数实际问题中， 可以忽略类型参数， 而使用原始的 Class 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">Class cl = e.getClass(); <span class="comment">//返回一个 Class 类型的实例。</span></span><br><span class="line"></span><br><span class="line">System.out.println(e.getClass().getName() + <span class="string">" "</span> + e.getName()); <span class="comment">//Class的 getName返回类的名字。返回 Employee Harry Hacker或Manager Harry Hacker</span></span><br><span class="line"></span><br><span class="line">Random generator = <span class="keyword">new</span> Random():</span><br><span class="line">Class cl = generator.getClass();</span><br><span class="line">String name = cl.getName(); <span class="comment">// "java.util .Random"。如果类在一个包里，包的名字也作为类名的一部分</span></span><br><span class="line"></span><br><span class="line">String className = <span class="string">"java.util.Random"</span>;</span><br><span class="line">Class cl = Class.forName(className);   <span class="comment">//获得类名对应的 Class 对象。</span></span><br><span class="line">                                        <span class="comment">//这个方法只有在 dassName 是类名或接口名时才能够执行。否则将抛出一个 checked exception(已检查异常），在使用时必须提供一个异常处理器。</span></span><br><span class="line"></span><br><span class="line">Class dl = Random<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// if you import java.util</span></span><br><span class="line">Class cl <span class="number">2</span> = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;   <span class="comment">//一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。</span></span><br><span class="line">Class cl <span class="number">3</span> = Double[]<span class="class">.<span class="keyword">class</span></span>;   <span class="comment">//通过T.class获得Class对象。</span></span><br><span class="line"></span><br><span class="line">Double[ ] class.getName( ) //返回 [Ijava.lang.Double;</span><br><span class="line">int[ ].class.getName( ) //返回 [I  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e.getClass() == Employee<span class="class">.<span class="keyword">class</span>)  //可以使用</span>==比较两个Class对象</span><br><span class="line"></span><br><span class="line">e.getClass().newInstance(); <span class="comment">//来动态地创建一个与类e具有相同类型的实例</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">"java.util.Random"</span>;</span><br><span class="line">Object m = Class.forName(s).newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p>若程序中没有提供捕获异常的处理器对异常情况进行处理，程序在运行时发生异常就会终止执行，并在控制台上打印一条信息给出异常类型。<br><strong>已检查异常</strong>：编译器将会检查是否为调用了抛出已检查异常方法的相关代码提供了异常处理器，否则将不能通过编译。<br><strong>未检查异常</strong>：编译器不要求强制处置的异常，虽然你有可能出现错误，但是我不会在编译的时候检查，需要自己精心编写代码来避免。例如访问 null 引用等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    String name = . . .; </span><br><span class="line">    Class cl = Class.forName(name); <span class="comment">//如果类名不存在， 则将跳过 try 块中的剩余代码，程序直接进人 catch 子句，否则跳过catch子句的处理器代码。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) </span><br><span class="line">&#123;</span><br><span class="line">     e.printStackTrace();   <span class="comment">//利用Throwable 类（Exception类的超类）的 printStackTrace 方法打印出栈的轨迹。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-利用反射分析类的能力"><a href="#3-利用反射分析类的能力" class="headerlink" title="3. 利用反射分析类的能力"></a>3. 利用反射分析类的能力</h2><p>在 java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、方法和构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Class;</span><br><span class="line"></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name )</span>   <span class="comment">//返回指定名称的公有域</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span>  <span class="comment">//返回类中声明的给定名称的域， 或者包含声明的全部域的数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果类中没有域， 或者 Class 对象描述的是基本类型或数组类型， 这些方法将返回一个长度为 0 的数组。</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span>  <span class="comment">//getFields 方法将返回一个包含 Field 对象的数组， 这些对象记录了这个类或其超类的公有域。</span></span></span><br><span class="line"><span class="function">Filed[] <span class="title">getDeclaredFie1ds</span><span class="params">()</span>  <span class="comment">//getDeclaredField 方法也将返回包含 Field 对象的数组， 这些对象记录了这个类的全部域。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回包含 Method 对象的数组</span></span></span><br><span class="line"><span class="function"><span class="comment">//getMethods 将返回所有的公有方法， 包括从超类继承来的公有方法；</span></span></span><br><span class="line"><span class="function"><span class="comment">//getDeclaredMethods 返回这个类或接口的全部方法， 但不包括由超类继承了的方法。</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclareMethods</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回包含 Constructor 对象的数组</span></span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getConstructors</span><span class="params">()</span>  <span class="comment">//返回公有构造器</span></span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span>  <span class="comment">//返回所有构造器</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getDeclaringClass</span><span class="params">( )</span>  <span class="comment">//返冋一个用于描述类中定义的构造器、 方法或域的 Class 对象。</span></span></span><br><span class="line"><span class="function">Class[] <span class="title">getExceptionTypes</span> <span class="params">( )</span> <span class="comment">//( 在 Constructor 和 Method 类中）返回一个用于描述方法抛出的异常类型的 Class 对象数组。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">( )</span>  <span class="comment">//返回一个用于描述构造器、 方法或域的修饰符的整型数值。使用 Modifier 类中的这个方法可以分析这个返回值。用不同的位开关描述 public 和 static 这样的修饰符使用状况</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">( )</span> <span class="comment">//返冋一个用于描述构造器、 方法或域名的字符串。</span></span></span><br><span class="line"><span class="function">Class[] <span class="title">getParameterTypes</span> <span class="params">( )</span> <span class="comment">//( 在 Constructor 和 Method 类 中）返回一个用于描述参数类型的 Class 对象数组。 </span></span></span><br><span class="line"><span class="function">Class <span class="title">getReturnType</span><span class="params">( )</span>  <span class="comment">//( 在 Method 类中）返回一个用于描述返H类型的 Class 对象。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> modifiers )</span> <span class="comment">//返回对应 modifiers 中设置的修饰符的字符串表示。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这些方法将检测方法名中对应的修饰符在 modifiers 值中的位，即方法和构造器是否是public、 private 或 final。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFinal</span> <span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">islnterface</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNative</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrivate</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProtected</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPublic</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStrict</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSynchronized</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVolati1e</span><span class="params">(<span class="keyword">int</span> modifiers )</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-在运行时使用反射分析对象"><a href="#4-在运行时使用反射分析对象" class="headerlink" title="4. 在运行时使用反射分析对象"></a>4. 在运行时使用反射分析对象</h2><ol>
<li>在编写程序时， 如果知道想要査看的域名和类型，查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域,从而<font color=Crmison>进一步查看运行时数据域的实际内容。</font></li>
<li>反射机制的默认行为受限于 Java 的访问控制。除非拥有访问权限，否则Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。可利用需要调用 Field、 Method 或Constructor 对象的 setAccessible 方法来覆盖访问控制。</li>
<li>当调用get方法获得域值时参数为基本数据类型，则反射机制将会自动地将这个域值打包到相应的对象包装器中。也可以调用Field 类中的 getDouble 等方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>, <span class="number">35000</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1989</span>);</span><br><span class="line">Class cl = harry.getClass; </span><br><span class="line">Field f = cl .getDeclaredField(<span class="string">"name"</span>); </span><br><span class="line"></span><br><span class="line">f.setAtcessible(<span class="keyword">true</span>);   <span class="comment">//覆盖访问控制</span></span><br><span class="line"></span><br><span class="line">Object v = f.get(harry);  <span class="comment">//获得name域运行时的具体值为"Harry Hacker"</span></span><br><span class="line">f.set(obj,value);  <span class="comment">//将 obj 对象的 f 域设置成新值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ObjectAnalyzer().toString(<span class="keyword">this</span>);  <span class="comment">//利用ObjectAnalyzer类的toString方法可为每个自定义类重写一个通用的toString方法，很方便。将打印类的所有信息，包括运行时的具体域值。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">( )</span>  <span class="comment">//返回反射对象的可访问标志的值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(AccessibleObject[] array,<span class="keyword">boolean</span> flag)</span>  <span class="comment">//是一种设置对象数组可访问标志的快捷方法。</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-使用反射编写泛型数组代码"><a href="#5-使用反射编写泛型数组代码" class="headerlink" title="5. 使用反射编写泛型数组代码"></a>5. 使用反射编写泛型数组代码</h2><p>将一个 Employee[]临时地转换成 Object[] 数组， 然后再把它转换回来是可以的，但一从开始就是 Object[] 的数组却永远不能转换成 Employee[] 数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，这个 CopyOf 方法可以用来扩展任意类型的数组， 而不仅是对象数组。</span></span><br><span class="line"><span class="comment">//应该将 goodCopyOf 的参数声明为 Object 类型，而不要声明为对象型数组（Object[])。整型数组类型 int[] 可以被转换成 Object，但不能转换成对象数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cl = a.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Class componentType = cl.getComponentType();</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    Object newArray = Array.newInstance(componentType, newLength):</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">get</span><span class="params">(Object array,<span class="keyword">int</span> index)</span>  <span class="comment">//( xxx 是 boolean、byte、 char、 double、 float、 int、 long、 short 之中的一种基本类型。)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> xxx <span class="title">getXxx</span><span class="params">(Object array,<span class="keyword">int</span> index)</span> <span class="comment">//这些方法将返回存储在给定位置上的给定数组的内容。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object array,<span class="keyword">int</span> index,Object newValue)</span>  <span class="comment">//( xxx 是 boolean、 byte、char、double、float、 int、 long、 short 之中的一种基本类型。)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">setXxx</span><span class="params">(Object array,<span class="keyword">int</span> index,xxx newValue)</span>      <span class="comment">//这些方法将一个新值存储到给定位置上的给定数组中。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Object array)</span>  <span class="comment">//返回数组的长度。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class componentType,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class componentType,<span class="keyword">int</span>[] lengths)</span>  <span class="comment">//返回一个具有给定类型、给定维数的新数组。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="6-利用反射调用任意方法"><a href="#6-利用反射调用任意方法" class="headerlink" title="6. 利用反射调用任意方法"></a>6. 利用反射调用任意方法</h2><p>利用反射中的Method类的invoke方法可以回调任意对象的任意方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  <span class="comment">//第一个参数是隐式参数， 其余的对象提供了显式参数，对于静态方法，第一个参数可以被忽略， 即可以将它设置为 null。</span></span></span><br><span class="line"><span class="function">                                           <span class="comment">//如果返回类型是基本类型， invoke 方法会返回其包装器类型。必须相应地完成类型转换。</span></span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class... parameterTypes)</span>  <span class="comment">//利用Class类中的getMethod方法获得Method对象</span></span></span><br><span class="line"><span class="function">                                                        <span class="comment">//也可以通过调用 getDeclareMethods 方法， 然后对返回的 Method 对象数组进行查找， 直到发现想要的方法为止。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">Method ml = Employee.class.getMethod("getName");</span><br><span class="line">Method m2 = Employee.class.getMethod("raiseSalary", double.class);</span><br><span class="line"></span><br><span class="line">String n = (String) ml.invoke(harry);  </span><br><span class="line"><span class="keyword">double</span> s = (Double) m2.invoke(harry);</span><br><span class="line">f.invoke(<span class="keyword">null</span>, x);          <span class="comment">//有可能存在若干个相同名字的方法，鉴于此，还必须提供想要的方法的参数类型。</span></span><br></pre></td></tr></table></figure>
<p>反射的优缺点：</p>
<ol>
<li>反射对于编写系统程序来说极其实用，但是通常不适于编写应用程序。</li>
<li>如果在调用方法的时候提供了一个错误的参数，那么 invoke 方法将会抛出一个异常；</li>
<li>且使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。</li>
<li>反射是很脆弱的，即编译器很难帮助人们发现程序中的错误， 因此只有在运行时才发现错误并导致异常。</li>
</ol>
<p>因此建议仅在必要的时候才使用 Method 对象，而最好使用接口以及 Java SE8 中 的 lambda 表达式，它们的代码的执行速度更快，更易于维护。</p>
<h1 id="八、继承的设计技巧"><a href="#八、继承的设计技巧" class="headerlink" title="八、继承的设计技巧"></a>八、继承的设计技巧</h1><ol>
<li>将公共操作和域放在超类；</li>
<li>不要使用受保护的域；</li>
<li>使用继承实现<strong>严格</strong>“ is-a” 关系，即超类中不能存在子类不需要的域；</li>
<li>除非<strong>所有</strong>继承的方法都有意义，否则不要使用继承；</li>
<li>在覆盖方法时，不要改变预期的行为；</li>
<li>使用多态(具有动态邦迪机制)，而非类型信息；</li>
<li>不要过多地使用反射。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的接口、lambda 表达式与内部类</title>
    <url>/2020/05/21/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h1><h2 id="1-接口概念"><a href="#1-接口概念" class="headerlink" title="1. 接口概念"></a>1. 接口概念</h2><p>接口<strong>不是类</strong>，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义，即<font color=Crmison>必须实现</font>接口中定义的所有方法。一个类可以实现（implement)—个或多个接口，并在需要接口的地方,随时使用实现了相应接口的对象。</p>
<ol>
<li>接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字public。<font color=Crmison>不过，在实现接口时，必须把方法声明为 public;</font>否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。</li>
<li>在接口中还可以定义常量。</li>
<li>接口绝不能含有实例域。</li>
<li>在 Java SE8 之前，也不能在接口中实现方法。现在已经可以在接口中提供简单方法了，这些方法不能引用实例域——接口没有实例。</li>
<li>Java是一种<font color=Crmison>强类型语言</font>：在调用方法的时候，编译器将会检查这个方法是否存在。</li>
<li>接口中的域将被自动设为 public static final。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Comparable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">////实现该接口的类必须实现此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;  <span class="comment">//实现该方法附加要求：在调用X.compareTo(y)的时候，这个方法必须确实比较两个对象的内容，并返回比较的结果。当x小于y时，返回一个负数；当x等于 时，返回0；</span></span><br><span class="line">                                 <span class="comment">//否则返回一个正数。 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object otherObject)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee other = (Employee) otherObject;  <span class="comment">//需要进行强制类型转换，不推荐</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 JavaSE 5.0 中，Comparable 接口已经改进为泛型类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;    //推荐方式</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);  <span class="comment">//x &lt; y 时，Double.compare(x, y) 调用会返回 -1 ; 如果 x &gt; y 则返回 1。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求对象所属的类必须实现了 Comparable 接口，因为要向 sort 方法提供对象的比较方式。 </span></span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee (<span class="string">"Harry Hacker"</span> , <span class="number">35000</span>);</span><br><span class="line">staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee (<span class="string">"Carl Cracker"</span> , <span class="number">75000</span>);</span><br><span class="line">staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee (<span class="string">"Tony Tester"</span> , <span class="number">38000</span>);</span><br><span class="line">Arrays.sort(staff) ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">( Object[] a )</span> <span class="comment">//使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了Comparable 接口的类， 并且元素之间必须是可比较的。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span> <span class="comment">//用这个对象与 other 进行比较。如果这个对象小于 other 则返回负值； 如果相等则返回0；否则返回正值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span> <span class="comment">//如果 x &lt; y 返回一个负整数；如果 x 和 y 相等，则返回 0; 否则返回一个负整数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span> x , <span class="keyword">double</span> y)</span> <span class="comment">//如果 x &lt; y 返回一个负数；如果 x 和 y 相等则返回 0; 否则返回一个负数</span></span></span><br></pre></td></tr></table></figure>

<p><font color=Crmison>与 equals 方法一样，在继承过程中有可能会出现子类父类对象混合比较的问题。</font>修改方式和equals一样，有两种不同情况，即根据子类语义是否改变来决定是用getClass方法还是instanceof方法检查类型是否一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != other.getClass()) <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();  <span class="comment">//若子类语义发生改变</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-接口的特性"><a href="#2-接口的特性" class="headerlink" title="2. 接口的特性"></a>2. 接口的特性</h2><ol>
<li>接口不是类，尤其不能使用 new 运算符实例化一个接口,但可以声明接口的变量，接口变量<strong>必须</strong>引用实现了接口的类对象。</li>
<li>与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。</li>
<li>接口可以只定义常量而不定义方法，但这样应用接口似乎有点偏离了接口概念的初衷，最好不要这样使用它。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口的声明和引用</span></span><br><span class="line">Comparable x;</span><br><span class="line">x = <span class="keyword">new</span> Employee(...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) &#123; . . . &#125;  <span class="comment">//可以使用instance 检查一个对象是否实现了某个特定的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口的继承或扩展</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Powered</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">milesPerGallon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">double</span> SPEED.LIHIT = <span class="number">95</span>; <span class="comment">//接口不能包含实例域或静态方法，但却可以包含常量</span></span><br><span class="line">                            <span class="comment">//接口中的域将被自动设为 public static final。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Comparable</span>  //类可以实现多个接口，却只能拥有一个超类</span></span><br></pre></td></tr></table></figure>

<h2 id="3-接口与抽象类"><a href="#3-接口与抽象类" class="headerlink" title="3. 接口与抽象类"></a>3. 接口与抽象类</h2><p>接口与抽象类的区别在于一个类可以实现多个接口，而一个类只能扩展一个抽象类，Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂，效率也会降低。而接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h2 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4. 静态方法"></a>4. 静态方法</h2><p>在 Java SE 8 中，允许在接口中增加静态方法，但是认为这有违于将接口作为抽象规范的初衷，通常的做法都是将静态方法放在伴随类中，例如java标准库中出现的Collection/Collections 或 Path/Paths等成对的接口和实用工具类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以为 Path 接口增加静态方法，如此伴随类paths就不再必要了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">get</span><span class="params">(String first, String... more)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileSystems.getDefault().getPath(first, more);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-默认方法"><a href="#5-默认方法" class="headerlink" title="5. 默认方法"></a>5. 默认方法</h2><p>可以为接口方法提供一个默认实现。必须用 default 修饰符标记，默认方法可以调用任何其他方法，<strong>实现该接口的类继承该方法且无需覆盖默认方法</strong>。有些情况下，默认方法可能很有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection 接口可以定义一个默认方法isEmpty，这样实现 Collection 的程序员就不用操心实现 isEmpty 方法了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// An abstract method</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有太大用处， 因为 Comparable 的每一个实际实现都要覆盖这个方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//所有元素都相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> <span class="keyword">implements</span> <span class="title">Collection</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认方法的一个重要用法是<strong>“接口演化”</strong>,假设之后为Collection接口又增加了一个 stream 非默认方法，那么 Bag 类将不能编译，即为接口增加一个非默认方法不能保证<font color=Crmison>“源代码兼容”</font>。不过， 假设不重新编译这个类，而只是使用原先的一个包含这个类的 JAR 文件。这个类仍能正常加载，程序仍然可以正常构造 Bag 实例，不会出现编译错误(<font color=Crmison>即为接口增加方法可以保证“二进制兼容”</font>)，不过如果程序在运行时在一个 Bag 实例上调用 stream方法，就会出现一个 AbstractMethodError。</li>
<li>将方法实现为一个默认方法就可以正常编译Bag类，另外如果没有重新编译而直接加载这个类， 并在一个 Bag 实例上调用 stream 方法， 将调用 Collection.stream 方法。</li>
</ul>
<h2 id="6-解决默认方法冲突"><a href="#6-解决默认方法冲突" class="headerlink" title="6. 解决默认方法冲突"></a>6. 解决默认方法冲突</h2><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，java解决该冲突的规则为：</p>
<blockquote>
<ol>
<li><font color=Crmison>超类优先</font>。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。即”类优先”规则。</li>
<li><font color=Crmison>接口冲突</font>。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li>
</ol>
</blockquote>
<p>若两个接口都没有为<strong>共享方法</strong>提供默认实现，则不会存在冲突。由于“java的类优先规则”，千万不要让一个接口中的默认方法重新定义 Object 类中的某个方法，因为这样的方法绝对无法超越 Object.toString 或 Objects.equals。</p>
<h1 id="二、接口示例"><a href="#二、接口示例" class="headerlink" title="二、接口示例"></a>二、接口示例</h1><h2 id="1-接口与回调"><a href="#1-接口与回调" class="headerlink" title="1. 接口与回调"></a>1. 接口与回调</h2><p>回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">10000</span>, listener);   <span class="comment">//定时器需要知道调用哪一个方法，并要求传递的对象所属的类实现了java.awt.event 包的 ActionListener 接口。</span></span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();   <span class="comment">//发出一声铃响。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timer(<span class="keyword">int</span> interval , ActionListener listener)  <span class="comment">//构造一个定时器， 每隔 interval 毫秒通告 listener—次</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Comparator-接口"><a href="#2-Comparator-接口" class="headerlink" title="2. Comparator 接口"></a>2. Comparator 接口</h2><p>利用Arrays.sort的数组和比较器(comparator)版本可以改变String类的比较规则，其中比较器是实现了 Comparator 接口的类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparators</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first, T second)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first, String second)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] friends = &#123; <span class="string">"Peter"</span>, <span class="string">"Paul"</span>, <span class="string">"Mary"</span> &#125;;</span><br><span class="line">Arrays,sort(friends, <span class="keyword">new</span> LengthComparator());</span><br></pre></td></tr></table></figure>

<h2 id="3-对象克隆-Cloneable-接口"><a href="#3-对象克隆-Cloneable-接口" class="headerlink" title="3. 对象克隆(Cloneable 接口)"></a>3. 对象克隆(Cloneable 接口)</h2><ol>
<li>这个接口从超类Object类中继承了一个安全的 clone 方法，它没有指定clone 方法。只是作为一个标记接口，指示类设计者了解克隆过程。</li>
<li>clone 方法是 Object 的一个 protected 方法，只能由其子类对象克隆其自己，即子类的方法中只能调用其所属类的clone方法，而不能调用其它子类对象的clone方法。</li>
<li>默认的克隆操作是<font color=Crmison>浅拷贝</font>，并没有克隆对象中引用的其他对象，这样一来，原对象和克隆的对象仍然会<strong>共享一些域信息</strong>。</li>
<li>如果原对象和浅克隆对象共享的子对象是不可变的(或子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用)，那么这种共享就是安全的。</li>
<li>不过，通常子对象都是可变的，必须重新定义 clone 方法来建立一个<font color=Crmison>深拷贝</font>，同时克隆所有子对象。</li>
<li>即使 clone 的默认（浅拷贝）实现能够满足要求， 还是需要实现 Cloneable 接口， 将 clone重新定义为 public，再调用 super.clone(),否则会生成一个受査异常CloneNotSupportedException。</li>
<li>子类只能调用受保护的 clone 方法来克隆它自己的对象。 必须重新定义 clone 为 public 才能允许所有方法克隆对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//如果在一个对象上调用 clone, 但这个对象的类并没有实现 Cloneable 接口，Object 类 的 clone 方法就会拋出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// call Object.clone()</span></span><br><span class="line">        Employee cloned = (Employee) <span class="keyword">super</span>.clone() ; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// clone mutable fields</span></span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有数组类型都有一个 public 的 clone 方法， 而不是 protected: 可以用这个方法建立一个新数组， 包含原数组所有元素的副本。</span></span><br><span class="line"><span class="keyword">int</span>[] luckyNumbers = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] cloned = luckyNumbers.done();</span><br><span class="line">cloned[<span class="number">5</span>] = <span class="number">12</span>; <span class="comment">// 不会改变luckyNumbers[5]</span></span><br></pre></td></tr></table></figure>

<h1 id="三、lambda-表达式"><a href="#三、lambda-表达式" class="headerlink" title="三、lambda 表达式"></a>三、lambda 表达式</h1><h2 id="1-为什么引入-lambda-表达式"><a href="#1-为什么引入-lambda-表达式" class="headerlink" title="1. 为什么引入 lambda 表达式"></a>1. 为什么引入 lambda 表达式</h2><p> lambda 表达式是一个可传递的代码块，该代码块可传递到某个对象，可以在以后执行一次或多次，实现回调，类似以上ActionListener 的 actionPerformed方法。Java 是一种面向对象语言，不能直接传递代码段，必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码，利用lambda表达式可以让这种形式的代码块表达的更加简洁。</p>
<h2 id="2-lambda-表达式的语法"><a href="#2-lambda-表达式的语法" class="headerlink" title="2. lambda 表达式的语法"></a>2. lambda 表达式的语法</h2><p>带参数变量的表达式就被称为 lambda 表达式，lambda 表达式就是一个代码块， 以及必须传人代码的变量规范。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数， 箭头（-&gt;) 以及一个表达式。无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是会由上下文推导得出。</span></span><br><span class="line">(String first, String second) -&gt; first.length() - second.length()  <span class="comment">//可以在需要 int 类型结果的上下文中使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 &#123;&#125;中，并包含显式的 return语句。</span></span><br><span class="line">(String first, String second) -&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>;i &gt;= <span class="number">0</span>;i-- ) System.out.println(i); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。</span></span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); <span class="comment">//编译器可以推导出 first 和 second 必然是字符串，因为这个 lambda 表达式将赋给一个字符串比较器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果方法只有一个参数， 而且这个参数的类型可以推导得出，那么甚至还可以省略小括号</span></span><br><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">"The time is "</span> + <span class="keyword">new</span> Date()<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//labmda表达式的应用</span></span><br><span class="line"><span class="string">Arrays.sort(planets, (first, second) -&gt; first.length() - second .length());</span></span><br><span class="line"><span class="string">Timer t = new Timer(1000, event -&gt; System.out.println ("</span>The time is <span class="string">" + new Date()));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ActionListener listener = event -&gt; </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    System.out.println(text);</span></span><br><span class="line"><span class="string">    Toolkit.getDefaultToolkitO.beep();</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">new Timer(delay, listener).start();</span></span><br></pre></td></tr></table></figure>
<p><font color=Crmison>如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，这是不合法的。</font></p>
<h2 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h2><ol>
<li>对于<strong>只有一个抽象方法的接口</strong>，需要这种接口的<strong>对象</strong>时，就可以提供一个 lambda 表达式，这种接口称为函数式接口。</li>
<li>最好把 lambda 表达式看作是一个函数，而不是一个对象， 另外要接受 lambda 表达式可以传递到函数式接口。</li>
<li>在 Java 中，对 lambda 表达式所能做的也只是能转换为函数式接口。java保持了接口概念而没有增加函数类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此包中定义了很多非常通用的函数式接口。</span></span><br><span class="line"><span class="keyword">import</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在底层， Arrays.sort 方法会接收实现了 Comparator&lt;String&gt; 的某个类的对象。在这个对象上调用 compare 方法会执行这个 lambda 表达式的体。</span></span><br><span class="line">Arrays.sort (words, (first, second) -&gt; first.length() - second.length()) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口BiFunction&lt;T, U, R&gt; 描述了参数类型为 T 和 U 而且返回类型为 R 的函数。可以将lambda表达式保存在该类型的变量中。</span></span><br><span class="line">BiFunction&lt;String, String, Integer&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口 Predicate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>; </span><br><span class="line">    <span class="comment">// Additional default and static methods   //可以有其它非抽象方法，但抽象方法只能有一个。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ArrayList 类有一个 removelf 方法， 它的参数就是一个 Predicate。这个接口专门用来传递lambda 表达式。</span></span><br><span class="line">list.removelf(e -&gt; e == <span class="keyword">null</span>);  <span class="comment">//从一个数组列表删除所有 null 值。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><ol>
<li>有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作，故可直接将该方法的表达式传递到此处，该表达式称为方法引用，要用<code>::</code> 操作符分隔方法名与对象或类名。</li>
<li>类似于 lambda 表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。</li>
<li>如果有多个同名的重载方法， 编译器就会尝试从上下文中找出你指的那一个方法。</li>
<li>可以在方法引用中使用 this 参数，使用super也是合法的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法引用的格式有三种</span></span><br><span class="line"><span class="comment">//方法引用等价于提供方法参数的 lambda 表达式。</span></span><br><span class="line">object::instanceMethod </span><br><span class="line">Class::staticMethod</span><br><span class="line">Class::instanceMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法引用的应用</span></span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, System.out::println);  <span class="comment">//System.out::println 等价于 lambda 表达式  x -&gt; System.out.println(x)</span></span><br><span class="line">Math::pow;  <span class="comment">//等价于（x，y) -&gt; Math.pow(x, y)。</span></span><br><span class="line">Arrays.sort(strings，String::conpareToIgnoreCase)   <span class="comment">//String::conpareToIgnoreCase等同于 (x, y) -&gt; x.compareToIgnoreCase(y)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>::equals <span class="comment">//等同于 x -&gt; this.equals(x)。</span></span><br><span class="line"><span class="keyword">super</span>::instanceMethod</span><br></pre></td></tr></table></figure>

<h2 id="5-构造器引用"><a href="#5-构造器引用" class="headerlink" title="5. 构造器引用"></a>5. 构造器引用</h2><ol>
<li>构造器引用与方法引用很类似，只不过方法名为 new,编译器会根据上下文调用某个确定的构造器。</li>
<li>可以用数组类型建立构造器引用。</li>
<li>Java 有一个限制，无法构造泛型类型 T 的数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Person&gt; people = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[]::<span class="keyword">new</span> <span class="comment">//等价于 lambda 表达式 x -&gt; new int[x]</span></span><br><span class="line"></span><br><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h2 id="6-变量作用域"><a href="#6-变量作用域" class="headerlink" title="6. 变量作用域"></a>6. 变量作用域</h2><ol>
<li>lambda 表达式由3部分组成：一个代码块；参数；自由变量的值，指非参数而且不在代码中定义的变量。</li>
<li>自由变量被lambda表达式捕获：表示 lambda 表达式的数据结构必须存储自由变量的值。可以把一个 lambda 表达式转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中。</li>
<li>在 Java 中，lambda 表达式就是<strong>闭包</strong>。</li>
<li>要确保所捕获的变量是<strong>最终变量</strong>，在 lambda 表达式中，只能引用值不会改变的变量(不论是在lambda中改变还是在外部改变)，否则并发执行多个动作时就会不安全。</li>
<li>lambda 表达式的体与嵌套块有相同的作用域。在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</li>
<li>在一个 lambda 表达式中使用 this 关键字时， 是指创建这个 lambda 表达式的方法的 this参数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ActionListener listener = event -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(text);    <span class="comment">//在这里，text 总是指示同一个 String 对象，所以捕获这个变量是合法的。</span></span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Path first = Paths.get(<span class="string">"usr/bin"</span>);</span><br><span class="line">Couparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ActionListener listener * event -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="function">print <span class="title">n</span><span class="params">(<span class="keyword">this</span>.toString()</span>)</span>; <span class="comment">//this.toString() 会调用 Application 对象的 toString方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-处理lambda表达式"><a href="#7-处理lambda表达式" class="headerlink" title="7. 处理lambda表达式"></a>7. 处理lambda表达式</h2><p>使用 lambda 表达式的重点是<font color=Crmison>延迟执行</font>，需要延迟执行的原因如下：</p>
<blockquote>
<p>在一个单独的线程中运行代码；<br>多次运行代码；<br>在算法的适当位置运行代码（例如， 排序中的比较操作；）<br>发生某种情况时执行代码（如， 点击了一个按钮， 数据到达， 等等；）<br>只在必要时才运行代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n, Runnable action)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) action.run();   <span class="comment">//调用 action.runO 时会执行这个 lambda 表达式的主体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntConsumer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n, IntConsumer action)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) action.accept(i); <span class="comment">//告诉这个动作它出现在哪一次迭代中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大多数标准函数式接口都提供了非抽象方法来生成或合并函数。</span></span><br><span class="line">Predicate.isEqual(a);  <span class="comment">//等同于 a::equals</span></span><br><span class="line">Predicate.isEqual(a).or(Predicate.isEqual(b)); <span class="comment">//等同于 x -&gt; a.equals(x) || b.equals(x)</span></span><br></pre></td></tr></table></figure>
<p>如果使用注解@FunctionalInterface标记一个自己设计的接口，该接口只有一个抽象方法，则若无意中增加了另一个非抽象方法， 编译器会产生一个错误消息。另外 javadoc 页里会指出你的接口是一个函数式接口。<br><img src="%E6%8E%A5%E5%8F%A31.png" alt="常用函数式接口"></p>
<hr>
<p><img src="%E6%8E%A5%E5%8F%A32.png" alt="常用函数式接口"></p>
<h2 id="8-再谈-Comparator"><a href="#8-再谈-Comparator" class="headerlink" title="8. 再谈 Comparator"></a>8. 再谈 Comparator</h2><p>Comparator 接口包含很多方便的静态方法来创建比较器。 这些方法可以用于 lambda 表达式或方法引用。静态 comparing 方法取一个“键提取器” 函数，它将类型 T 映射为一个可比较的类型。(如 String)。对要比较的对象应用这个函数， 然后对返回的键完成比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(people, Comparator.comparing(Person::getName)); <span class="comment">//按名字对这些对象排序</span></span><br><span class="line">Arrays.sort(people,Comparator.comparing(Person::getlastName).thenConiparing(Person::getFirstName)); <span class="comment">//如果两个人的姓相同， 就会使用第二个比较器。</span></span><br><span class="line">Arrays.sort(people, Comparator.comparing(Person::getName, (s, t) -&gt; Integer.compare(s.length(), t.length())));  <span class="comment">//根据人名长度完成排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//comparing 和 thenComparing 方法都有变体形式，可以避免 int、 long 或 double 值的装箱。</span></span><br><span class="line">Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));  </span><br><span class="line"></span><br><span class="line">Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder())));  <span class="comment">//使用nullsFirst 和 nullsLast 适配器可使在遇到 null 值时不会抛出异常</span></span><br><span class="line">naturalOrder().reversed(); <span class="comment">//让比较器逆序比较</span></span><br></pre></td></tr></table></figure>

<h1 id="四、内部类"><a href="#四、内部类" class="headerlink" title="四、内部类"></a>四、内部类</h1><p>使用内部类的主要原因：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</li>
</ol>
<h2 id="1-使用内部类访问对象状态"><a href="#1-使用内部类访问对象状态" class="headerlink" title="1. 使用内部类访问对象状态"></a>1. 使用内部类访问对象状态</h2><ol>
<li>内部类位于外部类的内部，但<font color=Crmison>不是每个外部类对象都有一个内部类对象的实例域，内部类对象是由外部类的方法构造的。</font></li>
<li>内部类既可以访问自身的数据域，也可以直接访问创建它的外围类对象的所有成员(包括private成员和静态成员)。即使用内部类可以不必提供仅用于访问其他类的访问器。</li>
<li>外部类只能通过创建成员内部类的对象，再通过指向这个对象的引用来访问。</li>
<li>只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。若内部类声明为私有的，则只有外部类的方法才能够构造内部类对象。</li>
</ol>
<hr>
<p>内部类能够访问外部类成员的原因是内部类的对象总有一个隐式引用，它指向了创建它的外部类对象，这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。因为 TimePrinter 类没有定义构造器，所以编译器为这个类生成了一个默认的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interval = interval;</span><br><span class="line">        <span class="keyword">this</span>.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ActionListener listener = <span class="keyword">new</span> TimePrinter();   <span class="comment">//当在 start 方法中创建了 TimePrinter 对象后，编译器就会将 this 引用传递给当前的语音时钟的构造器:</span></span><br><span class="line">                                                            <span class="comment">//ActionListener listener = new TimePrinter(this);</span></span><br><span class="line">        Timer t = <span class="keyword">new</span> Timer(interval, listener); t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span>   <span class="comment">//因为 TimePrinter 类没有定义构造器，所以编译器为这个类生成了一个默认的构造器：</span></span></span><br><span class="line"><span class="function">        </span>&#123;                                                <span class="comment">//public TimePrinter(TalkingGock clock)&#123;outer = clock;&#125;</span></span><br><span class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();   <span class="comment">//if(beep)等价于outer.beep  outer 不是 Java 的关键字,只是用它说明内部类中的机制</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-内部类的特殊语法规则"><a href="#2-内部类的特殊语法规则" class="headerlink" title="2. 内部类的特殊语法规则"></a>2. 内部类的特殊语法规则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用外围类引用的正规语法</span></span><br><span class="line">OuterClass.<span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TalkingClock.<span class="keyword">this</span>.beep) Toolkit.getDefaultToolkit().beep(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//明确地编写内部对象的构造器语法规则</span></span><br><span class="line">outerObject.<span class="keyword">new</span> InnerClass(construction parameters)</span><br><span class="line"></span><br><span class="line">ActionListener listener = <span class="keyword">this</span>.<span class="keyword">new</span> TimePrinter();  <span class="comment">//this 限定词是多余的,不过，可以通过显式地命名将外围类引用设置为其他的对象。</span></span><br><span class="line"></span><br><span class="line">TalkingClock jabberer = <span class="keyword">new</span> TalkingClock(<span class="number">1000</span>, <span class="keyword">true</span>);</span><br><span class="line">TalkingClock.TimePrinter listener = jabberer.<span class="keyword">new</span> TimePrinter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在外围类的作用域之外，可以这样引用内部类：</span></span><br><span class="line">OuterClass.InnerClass</span><br></pre></td></tr></table></figure>

<ol>
<li>内部类中声明的所有静态域都必须是 final,因为对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是 final,它可能就不是唯一的。</li>
<li>内部类不能有 static 方法。</li>
</ol>
<h2 id="3-内部类是否有用、必要和安全"><a href="#3-内部类是否有用、必要和安全" class="headerlink" title="3. 内部类是否有用、必要和安全"></a>3. 内部类是否有用、必要和安全</h2><p>当使用了内部类的时候，编译器做了这样一件事：它在外围类添加了一个静态方法 <code>static boolean access$0(外部类);</code>内部类方法将调用这个函数。这个是有风险的，因为任何人都可以通过access$0方法很容易的读取到外围类的私有域。黑客可以使用十六进制编辑器轻松创建一个用虚拟机指令调用这个函数的类文件。即如果内部类访问了私有数据域，就有可能通过附加在外围类所在的包中的其他类访问它们，应慎用。</p>
<h2 id="4-局部内部类"><a href="#4-局部内部类" class="headerlink" title="4. 局部内部类"></a>4. 局部内部类</h2><ol>
<li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。局部类有一个优势， 即对外部世界可以完全地隐藏起来。</li>
<li>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit.beep(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener); </span><br><span class="line">    t.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-由外部方法访问变量"><a href="#5-由外部方法访问变量" class="headerlink" title="5. 由外部方法访问变量"></a>5. 由外部方法访问变量</h2><p>//局部类不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须<font color=Crmison>事实上为</font> final，一旦赋值就绝不会改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Systea.out.println(<span class="string">"At the tone, the tiie is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit.beep(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener); </span><br><span class="line">    t.start();  <span class="comment">//将调用actionPerformed方法，此时局部变量beep已经被销毁，因此编译器会在局部类内部自动生成一个beep的拷贝final boolean val$beep;当创建一个对象的时候，beep 就会</span></span><br><span class="line">                <span class="comment">//被传递给构造器，并存储在 val$beep 域中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6. 匿名内部类"></a>6. 匿名内部类</h2><ol>
<li>如果只创建这个类的一个对象，就不必命名了，称为匿名内部类。</li>
<li>匿名内部类没有类名故不能有构造器，而是将构造器参数传递给超类构造器。<font color=Crmison>且在内部类实现接口的时候，不能有任何构造参数。</font></li>
<li>使用匿名内部类的解决方案比较简短、更切实际、更易于理解。</li>
<li>使用匿名内部类可以实现事件监听器和其他回调，但不如lambda表达式简洁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> ActionListener() <span class="comment">//创建一个实现 ActionListener 接口的类的新对象，需要实现的方法 actionPerformed 定义在括号内。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date())；</span><br><span class="line">            <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener); </span><br><span class="line">    t.start(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用语法</span></span><br><span class="line"><span class="keyword">new</span> SuperType(construction parameters) </span><br><span class="line">&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span>   //<span class="title">SuperType</span> 可以是接口也可以是类。若是接口则必须实现它，若是类，则内部类就要扩展它。</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Person</span> <span class="title">queen</span> </span>= <span class="keyword">new</span> Person(<span class="string">"Mary"</span>); <span class="comment">// 一个Person对象</span></span><br><span class="line">Person count = <span class="keyword">new</span> Person(<span class="string">"Dracula"</span>) &#123; . . . &#125;;<span class="comment">// 一个扩展了Person类的内部类对象</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>双括号初始化技巧</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果不再需要这个数组列表，最好让它作为一个匿名列表。</span></span><br><span class="line">invite(<span class="keyword">new</span> ArrayList&lt;String&gt;<span class="number">0</span> &#123;&#123; add(<span class="string">"Harry"</span>); add(<span class="string">"Tony"</span>); &#125;&#125;);  <span class="comment">//外层括号建立了 ArrayList 的一个匿名子类。内层括号则是一个对象构造块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成日志或调试消息时， 通常希望包含当前类的类名</span></span><br><span class="line"><span class="comment">//静态方法没有 this，在静态方法中获取所在类的类名方式如下：</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;&#125;.getClass().getEnclosingClass();  <span class="comment">//new Object()&#123;&#125; 会建立 Object 的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类。</span></span><br></pre></td></tr></table></figure>

<h2 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7. 静态内部类"></a>7. 静态内部类</h2><ol>
<li>静态内部类使用static关键字声明，就不会对外部类对象产生引用，使用静态内部类通常只是为了把一个类隐藏在另外一个类的内部。</li>
<li>只有内部类可以声明为 static。</li>
<li>静态内部类对象是在静态方法中构造的。</li>
<li>与常规内部类不同，静态内部类可以有静态域和方法。</li>
<li>声明在接口中的内部类自动成为 static 和 public 类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            first = f;</span><br><span class="line">            second = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">minmax</span><span class="params">(doublet[] values)</span>  <span class="comment">//ArrayAlg.Pair p = ArrayAlg.minmax(d);</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">double</span> min = Double.POSITIVE_NFINITY;</span><br><span class="line">            <span class="keyword">double</span> max = Double.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> v : values)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; v) min = v;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; v) max = v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(min, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、代理"><a href="#五、代理" class="headerlink" title="五、代理"></a>五、代理</h1><h2 id="1-何时使用代理"><a href="#1-何时使用代理" class="headerlink" title="1. 何时使用代理"></a>1. 何时使用代理</h2><ol>
<li>代理类可以实现指定的接口，可以在运行时创建全新的类。这样就可以在编译时获得一个表示接口对象的确切类型。</li>
<li>不能在运行时定义<font color=Crmison>指定接口和Object类中的全部方法</font>，而是要提供一个调用处理器。调用处理器是实现了 InvocationHandler 接口的类对象。</li>
<li>无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用，并向其传递Method 对象和原始的调用参数。 调用处理器必须给出处理调用的方式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  <span class="comment">//实现调用处理器接口中的方法</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-创建代理对象"><a href="#2-创建代理对象" class="headerlink" title="2. 创建代理对象"></a>2. 创建代理对象</h2><p>创建代理对象需要使用Proxy 类的 newProxylnstance 方法，它包含三个参数</p>
<ul>
<li>一个类加载器，用 null 可表示使用默认的类加载器。</li>
<li>一个 Class 对象数组， 每个元素都是需要实现的接口。</li>
<li>一个调用处理器。</li>
</ul>
<p>使用代理可机制可解决的问题，例：</p>
<ul>
<li>路由对远程服务器的方法调用。</li>
<li>在程序运行期间，将用户接口事件与动作关联起来。</li>
<li>为调试， 跟踪方法调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceHandler</span><span class="params">(Object t)</span> </span>&#123;</span><br><span class="line">        target = t;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span> <span class="params">(Object proxy, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">        </span>&#123;    <span class="comment">// 打印方法名和参数</span></span><br><span class="line">            System.out.print(target);  <span class="comment">//打印隐式参数</span></span><br><span class="line">            System,out.print(<span class="string">"."</span> + m.getName() + <span class="string">"("</span>);  <span class="comment">//打印方法名</span></span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;   <span class="comment">//打印显式参数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) </span><br><span class="line">                &#123;</span><br><span class="line">                    System,out.print(args[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; args.length - <span class="number">1</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System,out.println(<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用真正的方法</span></span><br><span class="line">            <span class="keyword">return</span> m.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造用于跟踪方法调用的代理对象</span></span><br><span class="line">Object value = ...</span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> TraceHandler(value) ; <span class="comment">// 为一个或多个接口构造代理</span></span><br><span class="line">Class[] interfaces = <span class="keyword">new</span> Class[] &#123;Comparable<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">Object proxy = Proxy.newProxylnstance(<span class="keyword">null</span> , interfaces, handler); <span class="comment">//无论何时用 proxy 调用某个方法， 这个方法的名字和参数就会打印出来，之后再用 value 调用它。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应用：使用代理对象对二分查找过程进行跟踪。</span></span><br><span class="line">Object[] elements = <span class="keyword">new</span> Object[<span class="number">1000</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i ++) </span><br><span class="line">&#123;</span><br><span class="line">    Integer value = i + <span class="number">1</span>;  <span class="comment">//Integer 类实现了 Comparable 接口。代理对象属于在运行时定义的类（它有一个名字， 如 $ProxyO) 这个类也实现了Comparable 接口,且会调用代理对象处理器的invoke方法。</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> TraceHandler(value);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(<span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123; Comparable<span class="class">.<span class="keyword">class</span> &#125;,<span class="title">handler</span>)</span>;</span><br><span class="line">    elements[i] = proxy <span class="comment">//数组代理</span></span><br><span class="line">&#125;</span><br><span class="line">Integer key = <span class="keyword">new</span> Random().nextlnt(elements.length) + <span class="number">1</span>;   </span><br><span class="line"><span class="keyword">int</span> result = Arrays.binarySearch(elements, key) ; <span class="comment">//查找元素,由于数组中填充了代理对象， 所以 compareTo 调用了 TraceHander 类中的 invoke 方法。这个方法打印出了方法名和参数，之后用包装好的 </span></span><br><span class="line">                                                <span class="comment">//Integer 对象调用 compareTo。</span></span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) System.out.println(elements[result]); <span class="comment">//打印元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">500</span>.compareTo(<span class="number">288</span>) <span class="number">2</span>SO.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">375</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">312</span>. compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">281</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">296</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">288</span>.compareTo(<span class="number">288</span>)</span><br><span class="line"><span class="number">288</span>.toString()   <span class="comment">//即使不属于 Comparable 接口，toString 方法也被代理，实际上有相当一部分的Object 方法都被代理。</span></span><br></pre></td></tr></table></figure>
<p>Integer 类实际上实现了<code>Comparable&lt;Integer&gt;</code>。然而，在运行时，所有的泛型类都被取消，代理将它们构造为原 <code>Comparable</code> 类的类对象。</p>
<h2 id="3-代理类的特性"><a href="#3-代理类的特性" class="headerlink" title="3. 代理类的特性"></a>3. 代理类的特性</h2><ol>
<li>代理类是在程序运行过程中创建的，一旦被创建，就变成了常规类。</li>
<li>所有的代理类都扩展于 Proxy 类。一个代理类只有一个实例域———调用处理器，它定义在 Proxy 的超类中。</li>
<li>为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。</li>
<li>所有的代理类都覆盖了 Object 类中的方法 toString、 equals 和 hashCode。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的 invoke，Object 类中的其他方法（如 clone和 getClass) 没有被重新定义。</li>
<li>没有定义代理类的名字，Sun 虚拟机中的 Proxy类将生成一个以字符串 $Proxy 开头的类名。</li>
<li>对于特定的类加载器和预设的一组接口来说，只能有一个代理类。</li>
<li>代理类一定是 public 和 final。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果使用同一个类加载器和接口数组调用两次 newProxylustance方法的话， 那么只能够得到同一个类的两个对象</span></span><br><span class="line">Class proxyClass = Proxy.getProxyClass(<span class="keyword">null</span>, interfaces);  <span class="comment">//可以利用 getProxyClass方法获得这个类</span></span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span>  <span class="comment">//定义了代理对象调用方法时希望执行的动作。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class&lt;?&gt;...interfaces)</span>  <span class="comment">//返回实现指定接口的代理类。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</span>  <span class="comment">//构造实现指定接口的代理类的一个新实例。所有方法会调用给定处理器对象的 invoke 方法。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span>  <span class="comment">//如果 cl 是一个代理类则返回 true。</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
