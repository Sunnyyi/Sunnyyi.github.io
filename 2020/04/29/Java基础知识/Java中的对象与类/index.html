<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="后端小萌新进阶大佬之路"><meta name="keywords" content="后端,Spring MVC,html,css,java,mysql"><title>Java中的对象与类 | 桃子果汁</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的对象与类</h1><a id="logo" href="/.">桃子果汁</a><p class="description">向阳生长</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java中的对象与类</h1><div class="post-meta"><a href="/2020/04/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2020/04/29/Java基础知识/Java中的对象与类/"></i>留言,<i id="changyan_parti_unit" data-xid="2020/04/29/Java基础知识/Java中的对象与类/"></i>参与</a><p><span class="date">Apr 29, 2020</span><span><a href="/categories/Java/" class="category">Java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>Java 是完全面向对象(OOP)的，而面向对象更加适用于解决规模较大的问题。</p>
<h1 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h1><h2 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h2><p><strong>类</strong>：类是构造对象的模板或蓝图，由类<strong>构造对象</strong>的过程称为<strong>创建类的实例</strong>。<br><strong>封装</strong>: 从形式上看，封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。<br><strong>实例域</strong>：对象中的数据。<br><strong>方法</strong>：操纵数据的过程。<br><strong>状态</strong>：对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。<br>并不是所有的类都具有面向对象特征，例如Math类只封装了功能，它不需要也不必隐藏数据。</p>
<h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h2><p>三个主要特征：</p>
<ol>
<li>对象的行为（behavior)—可以对对象施加哪些操作，或可以对对象施加哪些方法。 </li>
<li>对象的状态（state )—对象状态的改变必须通过调用方法实现，否则会破坏封装性。 </li>
<li>对象标识（identity )—每个对象都有一个唯一的身份。</li>
</ol>
<p>对象与对象变量的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Date deadline;  <span class="comment">//变量deadline不是一个对象， 实际上也没有引用对象,因此还不能将任何 Date 方法应用于这个变量上。</span></span><br><span class="line">deadline = <span class="keyword">new</span> Date();   <span class="comment">//一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</span></span><br><span class="line">                        <span class="comment">//表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 deadline 中。</span></span><br><span class="line">Date birthday = <span class="keyword">new</span> Date();</span><br><span class="line">deadline = birthday;   </span><br><span class="line"></span><br><span class="line">deadline = <span class="keyword">null</span>;  <span class="comment">//显式地将对象变量设置为 null,表明这个对象变量目前没有引用任何对象。该对象不能使用任何方法。</span></span><br><span class="line">                <span class="comment">//局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。</span></span><br></pre></td></tr></table></figure>


<h2 id="3-类之间的关系"><a href="#3-类之间的关系" class="headerlink" title="3. 类之间的关系"></a>3. 类之间的关系</h2><ol>
<li>依赖（“uses-a”）:一个类的方法操纵另一个类的对象，即一个类依赖于另一个类。又称为<font color=Crmison>耦合度</font>，实际开发中应让这种耦合最小。</li>
<li>聚合（“has-a”） :类 A 的对象包含类 B 的对象。</li>
<li>继承（“is-a”）:用于表示特殊与一般关系。如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。</li>
</ol>
<p>表示关系的UML符号：<br><img src="UML.png" alt="UML"></p>
<h1 id="二、使用预定义类"><a href="#二、使用预定义类" class="headerlink" title="二、使用预定义类"></a>二、使用预定义类</h1><h2 id="1-Java类库中的LocalDate类"><a href="#1-Java类库中的LocalDate类" class="headerlink" title="1. Java类库中的LocalDate类"></a>1. Java类库中的LocalDate类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Local Date.now(); <span class="comment">//使用类中的静态工厂方法</span></span><br><span class="line">LocalDate.of(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>); <span class="comment">//提供年、 月和日来构造对应一个特定日期的对象：</span></span><br><span class="line"></span><br><span class="line">LocalDate newYearsEve = Local Date.of(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>); <span class="comment">//将构造的对象保存在一个对象变量中供再次使用。</span></span><br><span class="line">LocalDate aThousandDaysLater = newYearsEve.plusDays(<span class="number">1000</span>); <span class="comment">//得到距当前对象指定天数的一个新日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function">LocalDate <span class="title">minusDays</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//生成当前日期之后或之前 n 天的日期。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMonthValue</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDayOfMonth</span><span class="params">( )</span> <span class="comment">//得到当前日期的年、 月和日。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">DayOfWeek getDayOfWeek</span>; <span class="comment">//得到当前日期是星期几， 作为 DayOfWeek 类的一个实例返回。 调用 getValue 来得到1 ~ 7 之间的一个数， 表示这是星期几， 1 表示星期一， 7 表示星期日。</span></span><br></pre></td></tr></table></figure>
<h2 id="2-CregorianCalendar类"><a href="#2-CregorianCalendar类" class="headerlink" title="2. CregorianCalendar类"></a>2. CregorianCalendar类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CregorianCalendar someDay = <span class="keyword">new</span> CregorianCalendar(<span class="number">1999</span>, <span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">someDay.add(Calendar.DAY_0F_M0NTH, <span class="number">1000</span>);  <span class="comment">//更改器方法</span></span><br><span class="line">year = someDay.get(Calendar.YEAR); <span class="comment">//访问器方法</span></span><br><span class="line">month = someDay.get(Calendar.MONTH)+ <span class="number">1</span>; </span><br><span class="line">day = someDay.get(Ca1endar.DAY_0F_M0NTH);</span><br></pre></td></tr></table></figure>

<h1 id="三、用户自定义类"><a href="#三、用户自定义类" class="headerlink" title="三、用户自定义类"></a>三、用户自定义类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//私有数据域</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">  <span class="keyword">private</span> Local Date hireDay;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器与类同名</span></span><br><span class="line"><span class="comment">//构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的，否则会产生编译错误。</span></span><br><span class="line"><span class="comment">//每个类可以有一个以上的构造器</span></span><br><span class="line"><span class="comment">//构造器可以有 0 个、1 个或多个参数，没有返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span> <span class="params">(String n , <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month , <span class="keyword">int</span> day)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    salary = s;</span><br><span class="line">    hireDay = Local Date,of(year, month, day);   <span class="comment">//注意， 不要在构造器中定义与实例域重名的局部变量。否则实例域会被覆盖从而使构造器失效。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//域访问器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Local Date <span class="title">getHireDay</span><span class="params">()</span> <span class="comment">//注意不要编写返回引用可变对象的访问器方法。否则会破坏封装性，由第三方改变类中的私有状态。该方法就违反了这个设计原则</span></span></span><br><span class="line"><span class="function"></span>&#123;                               <span class="comment">//如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone )。</span></span><br><span class="line">    <span class="comment">//return hireDay;</span></span><br><span class="line">    <span class="keyword">return</span> (Date)hireDay.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//域更改器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span>   <span class="comment">//raiseSalary 方法有两个参数。 第一个参数称为隐式参数， 是出现在方法名前的Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;  <span class="comment">//关键字 this 表示隐式参数</span></span><br><span class="line"> salary += raise;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-多个源文件的使用"><a href="#1-多个源文件的使用" class="headerlink" title="1. 多个源文件的使用"></a>1. 多个源文件的使用</h2><p>在开发中习惯于将每一个类存在一个单独的源文件中，这时既可以显式编译也可以隐式编译。当 Java 编译器发现 EmployeeTest.java 使用 Employee 类时会查找名为 Employee.class 的文件。如果没有找到这个文件， 就会自动地搜索 Employee.java, 然后，对它进行编译。如果 Employee,java 版本较已有的 Employee.class 文件版本新，Java 编译器就会自动地重新编译这个文件。</p>
<h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h2><p>封装一个类一般提供下面三项内容：</p>
<ol>
<li>私有的数据域；</li>
<li>公有的域访问器方法；</li>
<li>一个公有的域更改器方法。</li>
</ol>
<h2 id="3-基于类的访问权限"><a href="#3-基于类的访问权限" class="headerlink" title="3. 基于类的访问权限"></a>3. 基于类的访问权限</h2><p><font color=Crmison>类中的方法可以访问所属类对象的私有特性, 而不仅限于访问隐式参数的私有特性。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-私有方法"><a href="#4-私有方法" class="headerlink" title="4. 私有方法"></a>4. 私有方法</h2><p>绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。有些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密， 或者需要一个特别的协议以及一个特别的调用次序。在 Java 中，为了实现一个私有的方法， 只需将关键字 public 改为 private 即可。只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方法是公有的， 就不能将其删去，因为其他的代码很可能依赖它。</p>
<h2 id="5-final-实例域"><a href="#5-final-实例域" class="headerlink" title="5. final 实例域"></a>5. final 实例域</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类）。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">//必须确保在每一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于可变的类， 使用 final 修饰符可能会对读者造成混乱</span></span><br><span class="line">    <span class="comment">//final 关键字只是表示存储在 evaluations 变量中的对象引用不会再指示其他 StringBuilder对象。不过这个对象可以更改。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringBuiIcier evaluations;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、静态域与静态方法"><a href="#四、静态域与静态方法" class="headerlink" title="四、静态域与静态方法"></a>四、静态域与静态方法</h1><h2 id="1-静态域"><a href="#1-静态域" class="headerlink" title="1. 静态域"></a>1. 静态域</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextld = <span class="number">1</span>;  <span class="comment">//如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="2. 静态常量"></a>2. 静态常量</h2><p>静态变量使用得比较少，但静态常量却使用得比较多。静态常量可以被设置为public，因为final常量不允许被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out = . . .; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h2><p>使用静态方法的两种情况：</p>
<ol>
<li>一 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow)。</li>
<li>一个方法只需要访问类的静态域。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法不能访问实例域， 因为它不能操作对象。但是，静态方法可以访问自身类中的静态域</span></span><br><span class="line"><span class="comment">//可以认为静态方法是没有 this 参数的方法。</span></span><br><span class="line"><span class="comment">//可以使用对象调用静态方法但没必要。因为静态方法与对象实例域毫无关系。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextId; <span class="comment">// returns static field  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类名调用该方法</span></span><br><span class="line"><span class="keyword">int</span> n = Employee.getNextld();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color=Crmison>如果一个域是静态的基本数据类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化的值就是null。static关键字不能应用于局部变量，因此它只能作用于域。</font></p>
</blockquote>
<h2 id="4-工厂方法"><a href="#4-工厂方法" class="headerlink" title="4. 工厂方法"></a>4. 工厂方法</h2><p>工厂方法是静态方法的另一种常见用途，类似 LocalDate 和 NumberFormat 的类使用静态工厂方法来构造对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat currencyFormatter = NumberFormat.getCurrencylnstance();</span><br><span class="line">NumberFormat percentFormatter = NumberFormat.getPercentlnstance()；</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.1</span>;</span><br><span class="line">System.out.println(currencyFormatter.format(x)); <span class="comment">// prints $O.10</span></span><br><span class="line">System.out.println(percentFomatter.format(x)); <span class="comment">// prints 10%</span></span><br></pre></td></tr></table></figure>
<p>使用工厂方法的两个原因：</p>
<ol>
<li>无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例和百分比实例采用不用的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而 Factory 方法将返回一个 DecimalFormat类对象，这是 NumberFormat 的子类。</li>
</ol>
<h2 id="5-main方法"><a href="#5-main方法" class="headerlink" title="5. main方法"></a>5. main方法</h2><ol>
<li>main方法也是一种静态方法，不能操作所在类的实例域。静态的main 方法将执行并创建程序所需要的对象。</li>
<li>每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。可独立的对类进行测试。</li>
</ol>
<h1 id="五、方法参数"><a href="#五、方法参数" class="headerlink" title="五、方法参数"></a>五、方法参数</h1><ol>
<li><strong>按值调用</strong>：表示方法接收的是调用者提供的值，即形参为实参的一个拷贝，对形参的修改不能改变实参的值。</li>
<li><strong>按引用调用</strong>：表示方法接收的是调用者提供的变量地址。</li>
<li>Java 总是采用<font color=Crmison>按值调用</font>，方法不能修改传递给它的任何参数变量的内容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripieValue</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// doesn't work</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x = <span class="number">3</span> * x;      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;  </span><br><span class="line">tripieValue(percent);    <span class="comment">//一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span> <span class="params">(Employee x)</span> <span class="comment">// works</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x.raiseSa1ary(<span class="number">200</span>);  </span><br><span class="line">&#125;</span><br><span class="line">harry = <span class="keyword">new</span> Employee(. . .);</span><br><span class="line">tripleSalary(harry);     <span class="comment">//一个方法可以改变一个对象参数的状态。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x , Employee y)</span> <span class="comment">// doesn't work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee temp = x; </span><br><span class="line">    x = y; </span><br><span class="line">    y = temp;        <span class="comment">//一个方法不能让对象参数引用一个新的对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、对象构造"><a href="#六、对象构造" class="headerlink" title="六、对象构造"></a>六、对象构造</h1><h2 id="1-重载"><a href="#1-重载" class="headerlink" title="1. 重载"></a>1. 重载</h2><ol>
<li><strong>方法签名</strong>：要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名。返回类型不是方法签名的一部分。</li>
<li><strong>重载</strong>：多个方法有相同的名字、 不同的参数，便产生了重载。不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。</li>
<li><strong>重载解析</strong>:通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误。</li>
</ol>
<h2 id="2-默认域初始化"><a href="#2-默认域初始化" class="headerlink" title="2. 默认域初始化"></a>2. 默认域初始化</h2><ol>
<li>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。</li>
<li><font color=Crmison>域与局部变量不同，</font>必须明确地初始化方法中的局部变量。</li>
</ol>
<h2 id="3-无参数的构造器"><a href="#3-无参数的构造器" class="headerlink" title="3. 无参数的构造器"></a>3. 无参数的构造器</h2><ol>
<li>如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。</li>
<li>如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。此时必须显式提供一个不带参数的构造器才可以将所有的实例域设置为默认值。</li>
</ol>
<h2 id="4-显式域初始化"><a href="#4-显式域初始化" class="headerlink" title="4. 显式域初始化"></a>4. 显式域初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始值为常量值，用在当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时。</span></span><br><span class="line">    <span class="comment">//在执行构造器之前，先执行赋值操作。</span></span><br><span class="line">    <span class="keyword">private</span> String name =<span class="string">""</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始值不一定是常量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;  <span class="comment">//静态域在类加载时即被加载且未被赋初值的会被赋予默认值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用初始化块</span></span><br><span class="line">    <span class="comment">//在一个类的声明中，可以包含多个代码块</span></span><br><span class="line">    <span class="comment">//首先运行初始化块，然后才运行构造器的主体部分。</span></span><br><span class="line">    <span class="comment">//不常见</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextld;</span><br><span class="line">        nextld++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类第一次加载的时候， 将会进行静态域的初始化</span></span><br><span class="line">    <span class="comment">//所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">        nextld = generator.nextInt(lOOOO); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 Java SE 7 以后，java 程序首先会检查是否有一个 main 方法。</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Hel1o, World"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>域初始化的顺序很复杂，调用构造器的具体处理步骤：</p>
<ol>
<li>初始化父类中的静态成员变量和静态代码块 ； </li>
<li>初始化子类中的静态成员变量和静态代码块 ； </li>
<li>初始化父类的普通成员变量和代码块，再执行父类的构造方法；</li>
<li>初始化子类的普通成员变量和代码块，再执行子类的构造方法；</li>
</ol>
<h2 id="5-参数名"><a href="#5-参数名" class="headerlink" title="5. 参数名"></a>5. 参数名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String aNaie, <span class="keyword">double</span> aSalary)</span> </span>&#123;</span><br><span class="line">    name = aName ;</span><br><span class="line">    salary = aSalary; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String naie, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>,sal ary = salary; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-利用this调用同一个类中的另一个构造器"><a href="#6-利用this调用同一个类中的另一个构造器" class="headerlink" title="6. 利用this调用同一个类中的另一个构造器"></a>6. 利用this调用同一个类中的另一个构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可有效减少代码重复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123; <span class="comment">// calls Employee(String, double)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Employee #"</span> + nextld, s);</span><br><span class="line">    nextld++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、包"><a href="#七、包" class="headerlink" title="七、包"></a>七、包</h1><p>使用包的主要原因是确保类名的唯一性，而不会产生冲突。</p>
<h2 id="1-类的导入"><a href="#1-类的导入" class="headerlink" title="1. 类的导入"></a>1. 类的导入</h2><p>一个类可以使用所属包中的所有类， 以及其他包中的公有类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java.time.LocalDate today = java.tine.LocalDate.now();  <span class="comment">//繁琐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//import 语句应该位于源文件的顶部(但位于 package 语句的后面)。</span></span><br><span class="line"><span class="comment">//只能使用星号（*) 导入一个包， 而不能使用 import java.* 或import java.*.* 导入以 java 为前缀的所有包。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">LocalDate today = Local Date.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时若在程序直接使用 Date 类的时候， 就会出现一个编译错误，因为二者均包含Date类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可明确指出使用哪个包中的Date</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若两个Date均需要使用应添加上完整包名</span></span><br><span class="line">java.util.Date deadline = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">java.sql.Date today = <span class="keyword">new</span> java.sql.Date(...);</span><br></pre></td></tr></table></figure>
<h2 id="2-静态导入"><a href="#2-静态导入" class="headerlink" title="2. 静态导入"></a>2. 静态导入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line">out.println(<span class="string">"Goodbye, World!"</span>); <span class="comment">// System.out</span></span><br><span class="line">exit(<span class="number">0</span>); <span class="comment">//System.exit</span></span><br></pre></td></tr></table></figure>

<h2 id="3-将类放入包中"><a href="#3-将类放入包中" class="headerlink" title="3. 将类放入包中"></a>3. 将类放入包中</h2><p>如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包(没有名字)中。<br><img src="%E5%8C%85%E7%9B%AE%E5%BD%95.png" alt="包目录"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstmann.corejava;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line">javac PackageTest.java</span><br><span class="line">javac com/horstmann/corejava/Employee.java</span><br></pre></td></tr></table></figure>
<p><font color=Crmison>编译器在编译源文件的时候不检查目录结构。</font>如果源文件不在指定package中且不依赖于其他包， 就不会出现编译错误。但是， 最终的程序将无法运行，因为虚拟机找不到类。</p>
<h2 id="4-包作用域"><a href="#4-包作用域" class="headerlink" title="4. 包作用域"></a>4. 包作用域</h2><ol>
<li>标记为 public 的部分可以被任意的类使用；</li>
<li>标记为 private 的部分只能被定义它们的类使用。</li>
<li>如果没有指定 public 或 private , 这个部分（类、方法或变量）可以被同一个包中的所有方法访问。</li>
</ol>
<h1 id="八、类路径"><a href="#八、类路径" class="headerlink" title="八、类路径"></a>八、类路径</h1><p>类路径是所有包含类文件的路径的集合。<br>类路径包含三种情况：</p>
<ol>
<li>基目录 /home/user/classdir 或 c:\classes</li>
<li>当前目录 (.); </li>
<li>JAR 文件 /home/user/archives/archive.jar 或c:\archives\archive.jar</li>
</ol>
<p>类路径所列出的目录和归档文件是搜寻类的起始点。</p>
<h2 id="1-虚拟机搜寻类文件的过程"><a href="#1-虚拟机搜寻类文件的过程" class="headerlink" title="1. 虚拟机搜寻类文件的过程"></a>1. 虚拟机搜寻类文件的过程</h2><ol>
<li>首先要查看存储在 jre/lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。</li>
<li>若找不到相应类文件，再查看类路径。</li>
</ol>
<blockquote>
<p>/home/user/classdir/com/horstmann/corejava/Employee.class<br>com/horstmann/corejava/Employee.class 从当前目录开始<br>com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</p>
</blockquote>
<h2 id="2-编译器搜寻类文件的过程"><a href="#2-编译器搜寻类文件的过程" class="headerlink" title="2. 编译器搜寻类文件的过程"></a>2. 编译器搜寻类文件的过程</h2><ol>
<li>如果引用了一个类，而没有指出这个类所在的包， 那么编译器将首先查找包含这个类的包，并询查所有的 import 指令，确定其中是否包含了被引用的类。</li>
<li>如果找到了一个以上的类， 就会产生编译错误。</li>
<li>编译器还要查看源文件是否比类文件新，如果是这样的话，那么源文件就会被自动地重新编译。</li>
</ol>
<h2 id="3-设置类路径"><a href="#3-设置类路径" class="headerlink" title="3. 设置类路径"></a>3. 设置类路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用 -classpath (或 -cp) 选项指定类路径</span></span><br><span class="line">java -classpath /home/user/dassdir: .:/home/user/archives/archive.jar HyProg</span><br><span class="line">java -classpath c:\classdir; .;c:\archives\archive.jar MyProg</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 CLASSPATH 环境变量</span></span><br><span class="line">export CLASSPATH=/home/user/classdir:.:/ home/user/archives/archive.jar  <span class="comment">//Bourne Again shell ( bash)</span></span><br><span class="line">set CLASSPATH=c:\classdir;.;c:\archives\archive.jar <span class="comment">//Windows shell</span></span><br></pre></td></tr></table></figure>

<h1 id="九、文档注释"><a href="#九、文档注释" class="headerlink" title="九、文档注释"></a>九、文档注释</h1><p>利用JDK中的javadoc命令工具，可以由源文件生成一个 HTML 注释(/** */)文档。文档注释与源代码在同一个文件中，在修改源代码的同时， 重新运行 javadoc 就可以轻而易举地保持两者的一致性。</p>
<h2 id="1-注释的插入"><a href="#1-注释的插入" class="headerlink" title="1. 注释的插入"></a>1. 注释的插入</h2><p>javadoc抽取信息生成文档的位置如下，也应当在这些位置编写注释：</p>
<ol>
<li>包 </li>
<li>公有类与接口</li>
<li>公有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ol>
<p>文档注释的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自由格式文本：标记如<span class="doctag">@author</span>或 <span class="doctag">@param</span>等</span></span><br><span class="line"><span class="comment">* 第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽取出来形成概要页。</span></span><br><span class="line"><span class="comment">* 在自由格式文本中，可以使用 HTML 修饰符，如&lt;em&gt;&lt;/em&gt;等</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-类注释"><a href="#2-类注释" class="headerlink" title="2. 类注释"></a>2. 类注释</h2><p>类注释必须放在 import 语句之后，类定义之前。</p>
<h2 id="3-方法注释"><a href="#3-方法注释" class="headerlink" title="3. 方法注释"></a>3. 方法注释</h2><p>每一个方法注释必须放在所描述的方法之前。可以使用以下标记：<br><code>@param</code>:对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。<br><code>@return</code>:这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。<br><code>©throws</code>:这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。</p>
<h2 id="4-域注释"><a href="#4-域注释" class="headerlink" title="4. 域注释"></a>4. 域注释</h2><p>只需要对公有域（通常指的是静态常量）建立文档。</p>
<h2 id="5-通用注释"><a href="#5-通用注释" class="headerlink" title="5. 通用注释"></a>5. 通用注释</h2><p>用于类文档的注释中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 姓名</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@deprecated</span> 文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@see</span> 引用   <span class="doctag">@see</span> com.horstraann.corejava.Employee#raiseSalary(double) </span></span><br><span class="line"><span class="comment">            <span class="doctag">@see</span> &lt;a href="m«w.horstmann . com/corejava. htinl "&gt;The Core ]ava home page&lt;/a&gt;</span></span><br><span class="line"><span class="comment">            Isee "Core Java 2 volume 2n</span></span><br><span class="line"><span class="comment">&#123;<span class="doctag">@link</span> package.class#feature label &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-包与概述注释"><a href="#6-包与概述注释" class="headerlink" title="6. 包与概述注释"></a>6. 包与概述注释</h2><p>要想产生包注释，就需要在每一个包目录中添加一个单独的文件。有两种方式添加：</p>
<ol>
<li>提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;—&lt;/body&gt; 之间的所有文本都会被抽取出来。</li>
<li>提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** 和 */ 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。</li>
</ol>
<p>还可以为所有的源文件提供一个概述性的注释。名为overview,html 的文件中，这个文件位于包含所有源文件的父目录中。标记&lt;body&gt;—&lt;/body&gt;间的所有文本将被抽取出来。</p>
<h2 id="7-注释的抽取"><a href="#7-注释的抽取" class="headerlink" title="7. 注释的抽取"></a>7. 注释的抽取</h2><p>详见<a href="http://docs.oracle.com/javase/8/docs/guides/javadoc" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/guides/javadoc</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//docDirectory为HTML文件的存放目录</span></span><br><span class="line"><span class="number">1</span>. 切换到包含想要生成文档的源文件目录。</span><br><span class="line"><span class="number">2</span>. javadoc -d docDirectory nameOfPackage   <span class="comment">//如果省略了 -d docDirectory 选项， 那 HTML 文件就会被提取到当前目录下。</span></span><br><span class="line"><span class="number">3</span>. javadoc -d docDirectory nameOfPackage1 nameOfPackage2 . . .</span><br><span class="line"><span class="number">4</span>. javadoc -d docDirectory *.java  <span class="comment">//文件在默认包中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用 -author 和 -version 选项在文档中包含@author 和@version 标记（默认情况下，这些标记会被省略)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用-link为标准类添加超链接</span></span><br><span class="line">javadoc -link http:<span class="comment">//docs.oracle.eom/:javase/8/docs/api *.java  //所有的标准类库类都会自动地链接到 Oracle 网站的文档。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 -linksource 选项，则每个源文件被转换为 HTML (不对代码着色，但包含行编号) 并且每个类和方法名将转变为指向源代码的超链接。</span></span><br></pre></td></tr></table></figure>

<h1 id="十、类设计技巧"><a href="#十、类设计技巧" class="headerlink" title="十、类设计技巧"></a>十、类设计技巧</h1><ol>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型</li>
<li>不是所有的域都需要独立的域访问器和域更改器</li>
<li>将职责过多的类进行分解</li>
<li>类名和方法名要能够体现它们的职责</li>
<li>优先使用不可变的类</li>
</ol>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2020/05/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/" class="pre">Java中的继承</a><a href="/2020/04/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="next">Java基本语法</a></div><div id="comments"><div id="SOHUCS" sid="2020/04/29/Java基础知识/Java中的对象与类/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、类和对象"><span class="toc-text">一、类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-类"><span class="toc-text">1. 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-对象"><span class="toc-text">2. 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-类之间的关系"><span class="toc-text">3. 类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、使用预定义类"><span class="toc-text">二、使用预定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java类库中的LocalDate类"><span class="toc-text">1. Java类库中的LocalDate类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CregorianCalendar类"><span class="toc-text">2. CregorianCalendar类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、用户自定义类"><span class="toc-text">三、用户自定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-多个源文件的使用"><span class="toc-text">1. 多个源文件的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-封装"><span class="toc-text">2. 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-基于类的访问权限"><span class="toc-text">3. 基于类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-私有方法"><span class="toc-text">4. 私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-final-实例域"><span class="toc-text">5. final 实例域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、静态域与静态方法"><span class="toc-text">四、静态域与静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-静态域"><span class="toc-text">1. 静态域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-静态常量"><span class="toc-text">2. 静态常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-静态方法"><span class="toc-text">3. 静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-工厂方法"><span class="toc-text">4. 工厂方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-main方法"><span class="toc-text">5. main方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、方法参数"><span class="toc-text">五、方法参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、对象构造"><span class="toc-text">六、对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-重载"><span class="toc-text">1. 重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-默认域初始化"><span class="toc-text">2. 默认域初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-无参数的构造器"><span class="toc-text">3. 无参数的构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-显式域初始化"><span class="toc-text">4. 显式域初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-参数名"><span class="toc-text">5. 参数名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-利用this调用同一个类中的另一个构造器"><span class="toc-text">6. 利用this调用同一个类中的另一个构造器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、包"><span class="toc-text">七、包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-类的导入"><span class="toc-text">1. 类的导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-静态导入"><span class="toc-text">2. 静态导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-将类放入包中"><span class="toc-text">3. 将类放入包中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-包作用域"><span class="toc-text">4. 包作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、类路径"><span class="toc-text">八、类路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-虚拟机搜寻类文件的过程"><span class="toc-text">1. 虚拟机搜寻类文件的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-编译器搜寻类文件的过程"><span class="toc-text">2. 编译器搜寻类文件的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-设置类路径"><span class="toc-text">3. 设置类路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九、文档注释"><span class="toc-text">九、文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-注释的插入"><span class="toc-text">1. 注释的插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-类注释"><span class="toc-text">2. 类注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-方法注释"><span class="toc-text">3. 方法注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-域注释"><span class="toc-text">4. 域注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-通用注释"><span class="toc-text">5. 通用注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-包与概述注释"><span class="toc-text">6. 包与概述注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-注释的抽取"><span class="toc-text">7. 注释的抽取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十、类设计技巧"><span class="toc-text">十、类设计技巧</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/">Java内存区域与内存溢出异常</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/">Java中的并发</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/">Java中的集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">Java中的泛型程序设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/">Java中的异常、断言和日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/21/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/">Java中的接口、lambda 表达式与内部类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/">Codeup和PAT刷题记录——算法初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/">Java中的继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">Java中的对象与类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Java基本语法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://docschina.org/" title="印象中文" target="_blank">印象中文</a><ul></ul><a href="https://kingdot.github.io/" title="木丁夕雨何" target="_blank">木丁夕雨何</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><span>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i> 次</i></span><span>|</span><span>Copyright &copy;<a href="/." rel="nofollow">桃子果汁.</a></span></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?281cc941ca205b4ebca856d71ae45a55";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytF5aDWy'; 
  var conf = 'prod_0650efe38e465b0e4820ce8d9c386815'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>