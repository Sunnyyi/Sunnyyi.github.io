<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="后端小萌新进阶大佬之路"><meta name="keywords" content="后端,Spring MVC,html,css,java,mysql"><title>Java中的异常、断言和日志 | 桃子果汁</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的异常、断言和日志</h1><a id="logo" href="/.">桃子果汁</a><p class="description">向阳生长</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java中的异常、断言和日志</h1><div class="post-meta"><a href="/2020/05/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2020/05/23/Java基础知识/Java中的异常、断言和日志/"></i>留言,<i id="changyan_parti_unit" data-xid="2020/05/23/Java基础知识/Java中的异常、断言和日志/"></i>参与</a><p><span class="date">May 23, 2020</span><span><a href="/categories/Java/" class="category">Java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="一、处理错误"><a href="#一、处理错误" class="headerlink" title="一、处理错误"></a>一、处理错误</h1><h2 id="1-异常分类"><a href="#1-异常分类" class="headerlink" title="1. 异常分类"></a>1. 异常分类</h2><p>所有的异常都是由 Throwable 继承而来的，异常的继承层次如下：<br><img src="%E5%BC%82%E5%B8%B8.png" alt="异常"></p>
<ol>
<li><strong>Error</strong>: 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。<font color=Crmison>应用程序不应该抛出这种类型的对象,因为我们对其没有任何控制能力。</font></li>
<li><strong>Exception</strong>：由程序错误导致的异常属于 RuntimeException ; 而程序本身没有问题， 但由于像 I/O 错误这类问题导致的异常属于其他异常。</li>
<li><strong>派生于RuntimeException的异常</strong>：错误的类型转换;数组访问越界;访问 null 指针。<font color=Crmison>这些异常也不该声明，因为这些运行时错误完全在我们的控制之下。</font></li>
<li><strong>不是派生于RuntimeException的异常</strong>: 试图在文件尾部后面读取数据; 试图打开一个不存在的文件; 试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在。</li>
<li><strong>非受查异常</strong>：派生于Error类或 RuntimeException 类的所有异常称为非受查异常。</li>
<li><strong>受查异常</strong>: 所有其它异常。编译器将核查是否为所有的受査异常提供了异常处理器。否则代码不能通过编译。</li>
</ol>
<h2 id="2-声明受查异常"><a href="#2-声明受查异常" class="headerlink" title="2. 声明受查异常"></a>2. 声明受查异常</h2><ol>
<li>一个方法必须声明(<strong>throws</strong>)所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生（ RuntimeException)。</li>
<li>若方法在运行时真的抛出了一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理它。</li>
<li>如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用和更多。</li>
<li>如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。而是必须捕获所有受查异常。</li>
<li>抛出异常的情况有4种：</li>
</ol>
<ul>
<li>调用一个抛出受査异常的方法；</li>
<li>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常；</li>
<li>程序出现错误，例如，a[-1]=0 会抛出一个 ArraylndexOutOfBoundsException 这样的非受查异常。</li>
<li>Java 虚拟机和运行时库出现的内部错误。</li>
</ul>
<ol start="6">
<li>如果类中的一个方法声明将会抛出一个异常， 而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常， 或者这个类的任意一个子类的异常。</li>
<li>在 Java中，没有 throws 说明符的方法将不能抛出任何受查异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">loadlmage</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException,FileNotFoundException,EOFException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-如何抛出异常"><a href="#3-如何抛出异常" class="headerlink" title="3. 如何抛出异常"></a>3. 如何抛出异常</h2><ol>
<li>找到一个合适的异常类。</li>
<li>创建这个类的一个对象。</li>
<li>使用<strong>throw</strong>关键字将对象抛出。</li>
</ol>
<p>如果只是抛出异常而不在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。即一旦方法抛出了异常，这个方法就不可能返回到调用者，除非进行异常捕获。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException  <span class="comment">//声明异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (…) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();  <span class="comment">//抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-创建异常类"><a href="#4-创建异常类" class="headerlink" title="4. 创建异常类"></a>4. 创建异常类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFormatException</span> <span class="keyword">extends</span> <span class="title">IOException</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">(String gripe)</span>   <span class="comment">//超类 Throwable 的 toString 方法将会打印出这些详细信息， 这在调试中非常有用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(gripe); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(BufferedReader in)</span> <span class="keyword">throws</span> FileFormatException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (…) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileFornatException();  <span class="comment">//抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Throwable常用API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Throwable;</span><br><span class="line"></span><br><span class="line">Throwable( ) <span class="comment">//构造一个新的 Throwabie 对象， 这个对象没有详细的描述信息。</span></span><br><span class="line">Throwable(String message ) <span class="comment">//构造一个新的 throwable 对象， 这个对象带有特定的详细描述信息。习惯上，所有派生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器。</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">( )</span>  <span class="comment">//获得 Throwable 对象的详细描述信息。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="二、捕获异常"><a href="#二、捕获异常" class="headerlink" title="二、捕获异常"></a>二、捕获异常</h1><h2 id="1-捕获异常"><a href="#1-捕获异常" class="headerlink" title="1. 捕获异常"></a>1. 捕获异常</h2><p>如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> Filei叩utStream(filename);</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()<span class="number">3</span> != -<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            process input</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException exception) </span><br><span class="line">    &#123;</span><br><span class="line">        exception.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果在try语句块中的任何代码抛出了一个在 catch 子句中说明的异常类,则程序将跳过 try语句块的其余代码并执行catch 子句中的处理器代码，否则将跳过 catch 子句。</li>
<li>如果方法中的任何代码拋出了一个在 catch 子句中没有声明的异常类型，或者仅仅是声明了可能抛出的异常，那么这个异常就会传递给调用者进行处理。</li>
<li>如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递。</li>
<li>如果想传递一个异常， 就必须在方法的首部添加一个 throws 说明符， 以便告知调用者这个方法可能会抛出异常。</li>
<li>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。</li>
</ol>
<h2 id="2-捕获多个异常"><a href="#2-捕获多个异常" class="headerlink" title="2. 捕获多个异常"></a>2. 捕获多个异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might throwexceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> missing files</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnknownHostException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> unknown hosts</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> all other I/O problems</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当捕获的异常类型彼此之间不存在子类关系且多个异常的处理动作一样时，同一个 catch 子句中可以捕获多个异常类型。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e)  <span class="comment">//捕获多个异常不仅会让你的代码看起来更简单，还会更高效。</span></span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> missing files and unknown hosts  <span class="comment">//捕获多个异常时， 异常变量隐含为 final 变量。即不能在此处为e赋不同的值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> all other I/O problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-再次抛出异常与异常链"><a href="#3-再次抛出异常与异常链" class="headerlink" title="3. 再次抛出异常与异常链"></a>3. 再次抛出异常与异常链</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再次抛出异常的基本方法</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException e) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"database error: "</span> + e.getMessage()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原始异常设置为新异常的“原因”,这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">    Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Throwable e = se.getCause();  <span class="comment">//当捕获到异常时， 就可以使用下面这条语句重新得到原始异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只想记录一个异常， 再将它重新抛出，而不做任何改变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateRecord</span><span class="params">()</span> <span class="keyword">throws</span> SQLException  <span class="comment">//抛出的异常比声明的异常更通用时，Java SE7之前编译器会指出这个方法可以抛出任何 Exception 而不只是 SQLException。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        access the database</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)  <span class="comment">//Java SE7之后，编译器会跟踪到 e 来自 try块。假设这个 try 块中仅有的已检査异常是 SQLException 实例，另外，假设 e 在catch 块中未改变，将外围方法声明为 throws </span></span><br><span class="line">                        <span class="comment">//SQLException 就是合法的。</span></span><br><span class="line">    &#123;</span><br><span class="line">        logger.log(level, message, e);</span><br><span class="line">        <span class="keyword">throw</span> e; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-finally-子句"><a href="#4-finally-子句" class="headerlink" title="4. finally 子句"></a>4. finally 子句</h2><p>在需要关闭资源时，通常需要使用finally子句。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(. . .);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//可能抛出异常的代码</span></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="comment">//展示异常信息</span></span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure><br> 代码执行顺序有三种情况：</p>
<ol>
<li>代码没有抛出异常：执行顺序为 1，2，5，6。</li>
<li>抛出一个在 catch 子句中捕获的异常：</li>
</ol>
<ul>
<li>当catch字句没有抛出异常将执行 1，3，4，5，6。</li>
<li>当catch字句抛出了一个异常，在执行完1，3，5之后异常将被抛回这个方法的调用者。</li>
</ul>
<ol start="3">
<li><p>代码抛出了一个异常， 但这个异常不是由 catch 子句捕获的：在执行 1，5 后将异常抛给这个方法的调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//try 语句可以只有 finally 子句，而没有 catch 子句。</span></span><br><span class="line">InputStream in = . .</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might throwexceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    in.close();  <span class="comment">//不论try中是否遇到异常，该语句都将被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解耦合 try/catch 和 try/finally 语句块</span></span><br><span class="line">InputStrean in = . . .;</span><br><span class="line"><span class="comment">//外层的try语句块仅确保报告出现的错误。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 内层的try语句块仅确保关闭输入流。</span></span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;</span><br><span class="line">        code that might throwexceptions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        in.close();   <span class="comment">//若try语句中和finally语句中同时抛出异常则finally语句中的异常将会覆盖原始异常，转而抛出close方法的异常，此时需要用到带资源的try语句进行处理。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在try-catch-finally语句中使用return语句会带来的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = n * n;</span><br><span class="line">        <span class="keyword">return</span> r;    <span class="comment">//在方法返回前，finally 子句的内容将被执行。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n = <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这个返回值覆盖了原始的返回值。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-带资源的-try-语句"><a href="#5-带资源的-try-语句" class="headerlink" title="5. 带资源的 try 语句"></a>5. 带资源的 try 语句</h2><ol>
<li>若资源属于一个实现了 AutoCloseable 接口(close方法声明抛出Exception异常)或其子接口 Closeable 接口(close方法声明抛出IOException异常)的类，则try块退出时，会自动调用 <code>resource.close()</code>。</li>
<li>带资源的try语句会抛出原来的异常，而 close方法抛出的异常会“ 被抑制”，被抑制的异常将自动捕获，并由 <code>addSuppressed</code> 方法增加到原来的异常。可以调用 <code>getSuppressed</code> 方法得到从 close 方法抛出并被抑制的异常列表。</li>
<li>带资源的 try 语句自身也可以有 catch 子句和一个 finally 子句。这些子句会在关闭资源之后执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不论正常退出还是存在异常，都会调用resource.close()方法，就好像使用了fianlly块。</span></span><br><span class="line"><span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"usr/share/dict/words"</span>), <span class="string">"UTF-8"</span>);  <span class="comment">//可指定多个资源，不论块如何退出，in和out都会关闭而避免嵌套2个try-finally语句。</span></span><br><span class="line">    PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"out.txt"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        out.println(in.next().toUpperCase());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-分析堆栈轨迹元素"><a href="#6-分析堆栈轨迹元素" class="headerlink" title="6. 分析堆栈轨迹元素"></a>6. 分析堆栈轨迹元素</h2><p>堆栈轨迹是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述信息</span></span><br><span class="line">Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">StringWriter out = <span class="keyword">new</span> <span class="function">StringWri <span class="title">ter</span><span class="params">()</span></span>; </span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> PrintWriter(out));</span><br><span class="line">String description = out.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 getStackTrace 方法， 它会得到 StackTraceElement 对象的一个数组，可以在程序中分析这个对象数组。</span></span><br><span class="line">Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement frame : frames)</span><br><span class="line">    analyze frame</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态的 Thread.getAllStackTrace 方法， 它可以产生所有线程的堆栈轨迹 </span></span><br><span class="line">Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();</span><br><span class="line"><span class="keyword">for</span> (Thread t : map.keySet()) &#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    analyze frames</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、使用异常机制的技巧"><a href="#三、使用异常机制的技巧" class="headerlink" title="三、使用异常机制的技巧"></a>三、使用异常机制的技巧</h1><ol>
<li>异常处理不能代替简单的测试；</li>
<li>不要过分地细化异常；</li>
<li>利用异常层次结构(应该寻找更加适当的子类或创建自己的异常类)；</li>
<li>不要压制异常(应该将很大概率不会抛出的异常关闭)；</li>
<li><strong>早抛出：</strong>在检测错误时，“ 苛刻 ” 要比放任更好;</li>
<li><strong>晚捕获：</strong>不要羞于传递异常(传递给高层要比捕获异常更加合适)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// code that threatens to throw checked exceptions</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)  <span class="comment">//即使发生了异常也会被忽略。</span></span><br><span class="line">    &#123;&#125; <span class="comment">// so there</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、使用断言"><a href="#四、使用断言" class="headerlink" title="四、使用断言"></a>四、使用断言</h1><h2 id="1-断言的概念"><a href="#1-断言的概念" class="headerlink" title="1. 断言的概念"></a>1. 断言的概念</h2><p>断言(assert)机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//均对表达式进行检测，若结果为 false, 则抛出一个 AssertionError 异常。</span></span><br><span class="line"><span class="keyword">assert</span> 条件;</span><br><span class="line"><span class="keyword">assert</span> 条件:表达式;  <span class="comment">//表达式将被传入 AssertionError 的构造器，并转换成一个消息字符串(表达式的唯一目的)，表达式的值不会被存储。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span>; <span class="comment">//断言 x 是一个非负数值</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若希望条件也生成错误报告的一部分，就必须将它以字符串的形式传递给 AssertionError 对象。</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">"x &gt;= 0"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-启用和禁用断言"><a href="#2-启用和禁用断言" class="headerlink" title="2. 启用和禁用断言"></a>2. 启用和禁用断言</h2><ol>
<li>在默认情况下，断言被禁用。</li>
<li>在启用或禁用断言时不必重新编译程序，因为这是类加载器的功能，当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。</li>
<li>可以在某个类或整个包中使用断言。</li>
<li>有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。</li>
<li>启用和禁用所有断言的 -ea 和 -da 开关不能应用到那些没有类加载器的“系统类” 上,此时应使用 -enablesystemassertions/-esa 开关启用断言。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -enableassertions MyApp</span><br><span class="line">java -ea:MyClass -ea:com.mycompany.mylib...  MyApp <span class="comment">//开启 MyClass 类以及在 com.mycompany.mylib 包和它的子包中的所有类的断言。</span></span><br><span class="line"></span><br><span class="line">java -ea:... -da:MyClass MyApp  <span class="comment">//用选项 -disableassertions 或 -da 禁用某个特定类和包的断言</span></span><br></pre></td></tr></table></figure>

<h2 id="3-使用断言完成参数检查"><a href="#3-使用断言完成参数检查" class="headerlink" title="3. 使用断言完成参数检查"></a>3. 使用断言完成参数检查</h2><ol>
<li>断言失败是致命的、不可恢复的错误，有时候会拋出一个断言错误，有时候会产生一个 null 指针异常，这完全取决于类加载器的配置。</li>
<li>断言检查只用于开发和测阶段。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> a != <span class="keyword">null</span>; <span class="comment">//检查参数是否非空</span></span><br></pre></td></tr></table></figure>

<h2 id="4-为文档假设使用断言"><a href="#4-为文档假设使用断言" class="headerlink" title="4. 为文档假设使用断言"></a>4. 为文档假设使用断言</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// (i % 3 == 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为以上注释使用断言</span></span><br><span class="line"><span class="keyword">assert</span> i &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span> i % <span class="number">3</span> == <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ClassLoader;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultAssertionStatus</span><span class="params">( <span class="keyword">boolean</span> b )</span> <span class="comment">//对于通过类加载器加载的所有类来说， 如果没有显式地说明类或包的断言状态， 就启用或禁用断言。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCIassAssertionStatus</span><span class="params">(String className , <span class="keyword">boolean</span> b )</span> <span class="comment">//对于给定的类和它的内部类，启用或禁用断言。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPackageAssertionStatus</span><span class="params">( String packageName , bool ean b )</span> <span class="comment">//对于给定包和其子包中的所有类，启用或禁用断言。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAssertionStatus</span><span class="params">()</span> <span class="comment">//移去所有类和包的显式断言状态设置， 并禁用所有通过这个类加载器加载的类的断言。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="五、记录日志"><a href="#五、记录日志" class="headerlink" title="五、记录日志"></a>五、记录日志</h1><h2 id="1-基本日志"><a href="#1-基本日志" class="headerlink" title="1. 基本日志"></a>1. 基本日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用全局日志记录器生成简单的日志记录</span></span><br><span class="line">Logger.getClobal().info(<span class="string">"File-&gt;Open menu item selected"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在适当的地方（如 main 开始）调用将会取消所有的日志</span></span><br><span class="line">Logger.getClobal().setLevel(Level.OFF);</span><br></pre></td></tr></table></figure>

<h2 id="2-高级日志"><a href="#2-高级日志" class="headerlink" title="2. 高级日志"></a>2. 高级日志</h2><ol>
<li>不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义日志记录器。</li>
<li>未被任何变量引用的日志记录器可能会被垃圾回收，因此需要用一个静态变量存储日志记录器的一个引用。</li>
<li>日志记录器名也具有层次结构,父与子之间将会共享某些属性，例如，若对父日志记录器设置了日志级别，它的子记录器也会继承这个级别。</li>
<li>默认的日志配置记录了 INFO 或更高级别的所有记录，如果将记录级别设计为 INFO 或者更低， 则需要修改日志处理器的配置。</li>
<li>应该使用 CONFIG、FINE, FINER 和 FINEST 级别来记录那些有助于诊断，但对于程序员又没有太大意义的调试信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建或获取记录器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger myLogger = Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7 个日志记录器级别</span></span><br><span class="line">SEVERE</span><br><span class="line">WARNING</span><br><span class="line">INFO</span><br><span class="line">CONFIG</span><br><span class="line">FINE</span><br><span class="line">FINER</span><br><span class="line">FINEST</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况下，只记录前三个级别。 也可以设置其他的级別，还可以使用Level.ALL 开启所有级别的记录， 或者使用 Level.OFF 关闭所有级别的记录</span></span><br><span class="line">logger.setLevel(Level.FINE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志记录方法</span></span><br><span class="line">logger.warning(message);</span><br><span class="line">logger.fine(message);</span><br><span class="line">logger.log(Level.FINE, message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的日志记录将显示包含日志调用的类名和方法名,但是,如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以调用 logp 方法获得调用类和方法的确切位置。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logp</span><span class="params">(Level l, String className, String methodName, String message)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用来跟踪执行流的方法,将生成 FINER 级别和以字符串 ENTRY 和 RETURN 开始的日志记录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entering</span><span class="params">(String dassName , String methodName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entering</span><span class="params">(String className , String methodName , Object param)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entering</span><span class="params">(String className , String methodName , Object[] params)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exiting</span><span class="params">(String className , String methodName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exiting</span><span class="params">(String className , String methodName , Object result)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="comment">//记录日志的常见用途是记录那些不可预料的异常。</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOException exception = <span class="keyword">new</span> IOException(<span class="string">". . ."</span>);</span><br><span class="line">    logger.throwing(<span class="string">"com•mycompany.mylib.Reader"</span>, <span class="string">"read"</span>, exception); <span class="comment">//调用 throwing 可以记录一条 FINER 级别的记录和一条以 THROW 开始的信息。</span></span><br><span class="line">    <span class="keyword">throw</span> exception; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>).log(Level.WARNING , <span class="string">"Reading image"</span>, e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-修改日志管理器配置"><a href="#3-修改日志管理器配置" class="headerlink" title="3. 修改日志管理器配置"></a>3. 修改日志管理器配置</h2><ol>
<li>可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下，配置文件存在于：<code>jre/lib/1ogging.properties</code>。</li>
<li>也可将 <code>java.util.logging.config.file</code> 特性设置为配置文件的存储位置来使用另一个配置文件。</li>
<li>日志记录并不将消息发送到控制台上，这是处理器的任务。</li>
<li>在曰志管理器配置的属性设置不是系统属性，不会对日志记录器产生任何影响。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志管理器在 VM 启动过程中初始化，这在 main 执行之前完成</span></span><br><span class="line">System.setProperty(<span class="string">"java.util.logging.config.file"</span>,file);  <span class="comment">//在main中调用该方法后也会调用 `LogManager.readConfiguration()` 来重新初始化曰志管理器。</span></span><br><span class="line"></span><br><span class="line">java -Djava.util.logging.config.file=configFile MainClass  <span class="comment">//使用另一个配置文件启动应用程序</span></span><br><span class="line"></span><br><span class="line">.level=INFO  <span class="comment">//编辑配置文件，修改默认的日志记录级别</span></span><br><span class="line">com.mycompany.myapp.level=FINE  <span class="comment">//指定自己的日志记录级别</span></span><br><span class="line"></span><br><span class="line">java.util.logging.ConsoleHandler.level=FINE  <span class="comment">//设置处理器级别以在控制台上看到 FINE 级别的消息</span></span><br></pre></td></tr></table></figure>

<h2 id="4-本地化"><a href="#4-本地化" class="headerlink" title="4. 本地化"></a>4. 本地化</h2><ol>
<li>本地化的应用程序包含资源包中的本地特定信息,资源包由各个地区的映射集合组成，日志消息本地化后让全球的用户都可以阅读它。。</li>
<li>每个资源包都有一个名字，要想将映射添加到一个资源包中，需要为每个地区创建一个文件(例如com/mycompany/logmessages_en.properties)，这些文件都是纯文本文件。</li>
<li>可以将这些文件与应用程序的类文件放在一起， 以便 ResourceBundle 类自动地对它们进行定位。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源包中的映射</span></span><br><span class="line">readingFile=Achtung! Datei wird eingelesen</span><br><span class="line">renamingFile=Datei wird umbenannt</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求日志记录器时指定一个资源包</span></span><br><span class="line">Logger logger = Logger.getLogger(loggerName , <span class="string">"com.mycompany.logmessages"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为日志消息指定资源包的关键字</span></span><br><span class="line">logger.info(<span class="string">"readingFile"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若需要在本地化的消息中增加一些参数， 因此，消息应该包括占位符&#123;0&#125;、&#123;1&#125;</span></span><br><span class="line">Reading file &#123;<span class="number">0</span>&#125;.</span><br><span class="line">Achtung! Datei &#123;<span class="number">0</span>&#125; wird eingelesen.</span><br><span class="line"><span class="comment">//调用下面的一个方法向占位符传递具体的值</span></span><br><span class="line">logger.log(Level.INFO, <span class="string">"readingFile"</span>, fileName);</span><br><span class="line">logger.log(Level.INFO, <span class="string">"renamingFile"</span>, <span class="keyword">new</span> Object[] &#123; oldName , newName &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-处理器"><a href="#5-处理器" class="headerlink" title="5. 处理器"></a>5. 处理器</h2><ol>
<li>默认情况下日志记录器将记录发送到 ConsoleHandler 中， 并由它输出到 System.err流中。</li>
<li>其他情况下，日志记录器还会将记录发送到父处理器中，而最终的处理器（命名为“ ”,所有日志记录器的父类）有一个 ConsoleHandler。</li>
<li>对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志管理器配置文件设置的默认控制台处理器的日志记录级别</span></span><br><span class="line">java.util.logging.ConsoleHandler.level =INFO</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改配置文件中的默认日志记录级别和处理器级别来改变处理器的默认设置</span></span><br><span class="line">Logger logger = Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>);</span><br><span class="line">logger.setLevel(Level.FINE); </span><br><span class="line">logger.setUseParentHandlers(<span class="keyword">false</span>); <span class="comment">//原始日志记录器将会把所有等于或高于 INFO 级別的记录发送到控制台,为了避免看到重复记录，应该将useParentHandlers 属性设置为 false。</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> ConsoleHandler();</span><br><span class="line">handler.setLevel(Level.FINE); </span><br><span class="line">logger.addHandler(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接将记录发送到默认文件的处理器，即用户主目录的 javan.log 文件中， n 是文件名的唯一编号。也可发送到其他地方，但需要添加其它的处理器，如FileHandler(特定文件)、SocketHandler(特定主机)。</span></span><br><span class="line"><span class="comment">//默认情况下， 记录被格式化为 XML</span></span><br><span class="line">FileHandler handler = <span class="keyword">new</span> FileHandler(); </span><br><span class="line">logger.addHandler(handler);</span><br></pre></td></tr></table></figure>

<h2 id="6-过滤器"><a href="#6-过滤器" class="headerlink" title="6. 过滤器"></a>6. 过滤器</h2><ol>
<li>默认情况下，过滤器根据日志记录的级别进行过滤。每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤。</li>
<li>也可自定义过滤器，并调用setFilter 方法将一个过滤器安装到一个日志记录器或处理器中，注意一时刻最多只能有一个过滤器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过实现 Filter 接口并定义下列方法来自定义过滤器。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLoggable</span><span class="params">(LogRecord record)</span>  <span class="comment">//可以利用自己喜欢的标准，对日志记录进行分析，返回 true 表示这些记录应该包含在日志中。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="7-格式化器"><a href="#7-格式化器" class="headerlink" title="7. 格式化器"></a>7. 格式化器</h2><p>对日志记录自定义格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展 Formatter 类并覆盖下面这个方法实现自定义日志记录的格式</span></span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(LogRecord record)</span>  <span class="comment">//根据自己的愿望对记录中的信息进行格式化，并返冋结果字符串。</span></span></span><br><span class="line"><span class="function">String <span class="title">formatMessage</span><span class="params">(LogRecord record)</span>  <span class="comment">//这个方法对记录中的部分消息进行格式化、 参数替换和本地化应用操作，可在format方法中调用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//要覆盖下面两个方法，实现在已格式化的记录的前后加上一个头部和尾部</span></span></span><br><span class="line"><span class="function">String <span class="title">getHead</span> <span class="params">(Handler h)</span></span></span><br><span class="line"><span class="function">String <span class="title">getTail</span> <span class="params">(Handler h)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//最后，调用 setFormatter 方法将格式化器安装到处理器中。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六、调试技巧"><a href="#六、调试技巧" class="headerlink" title="六、调试技巧"></a>六、调试技巧</h1><ol>
<li>可以调用合适的方法打印或记录任意变量的值；</li>
<li>在每一个类中放置一个单独的 main方法对每一个类进行单元测试；</li>
<li>使用JUnit单元测试框架，详见<a href="http://junit.org" target="_blank" rel="noopener">http://junit.org</a> </li>
<li>使用日志代理截获方法调用， 并进行日志记录，然后调用超类中的方法。</li>
<li>利用 Throwable 类提供的 printStackTace 方法。</li>
<li>—般来说，堆栈轨迹显示在 System.err 上。也可以利用 <code>printStackTrace(PrintWriter s)</code>方法将它发送到一个文件中，还可将其捕获到一个字符串中。</li>
<li>将一个程序中的错误信息保存在一个文件中。</li>
<li>不让非捕获异常的堆栈轨迹出现在 System.err 中。</li>
<li>用 -verbose 标志启动 Java 虚拟机观察类的加载过程有助于诊断由于类路径引发的问题。</li>
<li>-Xlint 选项告诉编译器对一些普遍容易出现的代码逻辑问题进行检査。</li>
<li>java 虚拟机增加了对 Java 应用程序进行监控和管理的支持，例如jconsole 图形工具，对于像应用程序服务器这样大型的、 长时间运行的 Java 程序来说特别重要。</li>
<li>使用 jmap 实用工具获得一个堆的转储并进行探查，其中显示了堆中的每个对象。</li>
<li>使用 -Xprof 标志运行 Java 虚拟机，就会运行一个基本的剖析器来跟踪那些代码中经常被调用的方法。剖析信息将发送给 System.out。输出结果中还会显示哪些方法是由即时编译器编译的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">Logger.getClobal().info(<span class="string">"nx="</span> + x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志代理</span></span><br><span class="line">Random generator = <span class="keyword">new</span></span><br><span class="line">Random() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span>    <span class="comment">//当调用 nextDouble 方法时， 就会产生一个日志消息。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="keyword">super</span>.nextDouble()</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.getClobal().info(<span class="string">"nextDouble: "</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread.duapStack();  <span class="comment">//无须捕获异常，在代码的任何位置插入下面这条语句就可以获得堆栈轨迹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将对战轨迹捕获到一个字符串中</span></span><br><span class="line">StringWriter out = <span class="keyword">new</span> StringWriter();</span><br><span class="line"><span class="keyword">new</span> Throwable().printStackTrace(<span class="keyword">new</span> PrintWriter(out));</span><br><span class="line">String description = out.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个程序中的错误信息保存在一个文件中。</span></span><br><span class="line">java MyProgram <span class="number">2</span>&gt; errors.txt <span class="comment">//捕获错误流</span></span><br><span class="line">java MyProgram <span class="number">1</span>&gt; errors.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span> <span class="comment">//在同一个文件中同时捕获 System.en•和 System.out</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改变非捕获异常的处理器</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">    <span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            save information in logfile</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对代码的简单逻辑进行检查</span></span><br><span class="line">javac -Xlint:fallthrough</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示虚拟机性能的统计结果</span></span><br><span class="line">jconsole processID</span><br><span class="line"></span><br><span class="line"><span class="comment">//转储堆中的内容进行探查</span></span><br><span class="line">jmap -dump:format=b, file=dumpFileName processID</span><br><span class="line">jhat dumpFileName</span><br><span class="line"><span class="comment">//通过浏览器进人丨oCalhOSt:7000, 将会运行一个网络应用程序，借此探查转储对象时堆的内容。</span></span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Java基础知识</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2020/05/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="pre">Java中的泛型程序设计</a><a href="/2020/05/21/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/" class="next">Java中的接口、lambda 表达式与内部类</a></div><div id="comments"><div id="SOHUCS" sid="2020/05/23/Java基础知识/Java中的异常、断言和日志/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、处理错误"><span class="toc-text">一、处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-异常分类"><span class="toc-text">1. 异常分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-声明受查异常"><span class="toc-text">2. 声明受查异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-如何抛出异常"><span class="toc-text">3. 如何抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-创建异常类"><span class="toc-text">4. 创建异常类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、捕获异常"><span class="toc-text">二、捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-捕获异常"><span class="toc-text">1. 捕获异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-捕获多个异常"><span class="toc-text">2. 捕获多个异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-再次抛出异常与异常链"><span class="toc-text">3. 再次抛出异常与异常链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-finally-子句"><span class="toc-text">4. finally 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-带资源的-try-语句"><span class="toc-text">5. 带资源的 try 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-分析堆栈轨迹元素"><span class="toc-text">6. 分析堆栈轨迹元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、使用异常机制的技巧"><span class="toc-text">三、使用异常机制的技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、使用断言"><span class="toc-text">四、使用断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-断言的概念"><span class="toc-text">1. 断言的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-启用和禁用断言"><span class="toc-text">2. 启用和禁用断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-使用断言完成参数检查"><span class="toc-text">3. 使用断言完成参数检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-为文档假设使用断言"><span class="toc-text">4. 为文档假设使用断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、记录日志"><span class="toc-text">五、记录日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-基本日志"><span class="toc-text">1. 基本日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-高级日志"><span class="toc-text">2. 高级日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-修改日志管理器配置"><span class="toc-text">3. 修改日志管理器配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-本地化"><span class="toc-text">4. 本地化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-处理器"><span class="toc-text">5. 处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-过滤器"><span class="toc-text">6. 过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-格式化器"><span class="toc-text">7. 格式化器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、调试技巧"><span class="toc-text">六、调试技巧</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/JDBC/Apache-DBUtils%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C/">Apache-DBUtils实现CRUD操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/JDBC/%20Druid%EF%BC%88%E5%BE%B7%E9%B2%81%E4%BC%8A%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">Druid数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/JDBC/DBCP%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">DBCP数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/JDBC/C3P0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">C3P0数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/DAO%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/">DAO开发模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/JDBC%E8%AE%BE%E7%BD%AEMySQL%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">使用JDBC设置MySQL的隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/%E4%BD%BF%E7%94%A8JDBC%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1/">使用JDBC操作事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/22/JDBC/JDBC%E4%B8%AD%E7%9A%84%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/">JDBC中的批量插入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/JDBC/JDBC%E6%93%8D%E4%BD%9CBLOB%E5%AD%97%E6%AE%B5/">JDBC操作BLOB字段</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDE/">IDE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDBC/">JDBC</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">Java基础知识</a> <a href="/tags/C-C-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">C/C++算法</a> <a href="/tags/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 15px;">JVM自动内存管理</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/IDE/" style="font-size: 15px;">IDE</a> <a href="/tags/JDBC/" style="font-size: 15px;">JDBC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://docschina.org/" title="印象中文" target="_blank">印象中文</a><ul></ul><a href="https://kingdot.github.io/" title="木丁夕雨何" target="_blank">木丁夕雨何</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><span>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i> 次</i></span><span>|</span><span>Copyright &copy;<a href="/." rel="nofollow">桃子果汁.</a></span></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?281cc941ca205b4ebca856d71ae45a55";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytF5aDWy'; 
  var conf = 'prod_0650efe38e465b0e4820ce8d9c386815'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>