<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="后端小萌新进阶大佬之路"><meta name="keywords" content="后端,Spring MVC,html,css,java,mysql"><title>Java中的集合 | 桃子果汁</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的集合</h1><a id="logo" href="/.">桃子果汁</a><p class="description">向阳生长</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java中的集合</h1><div class="post-meta"><a href="/2020/05/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2020/05/26/Java基础知识/Java中的集合/"></i>留言,<i id="changyan_parti_unit" data-xid="2020/05/26/Java基础知识/Java中的集合/"></i>参与</a><p><span class="date">May 26, 2020</span><span><a href="/categories/Java/" class="category">Java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>集合是Java中非常重要的内容。</p>
<h1 id="一、Java-集合框架"><a href="#一、Java-集合框架" class="headerlink" title="一、Java 集合框架"></a>一、Java 集合框架</h1><h2 id="1-将集合的接口与实现分离"><a href="#1-将集合的接口与实现分离" class="headerlink" title="1. 将集合的接口与实现分离"></a>1. 将集合的接口与实现分离</h2><p>队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; </span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列实现</span></span><br><span class="line"><span class="comment">//循环队列,循环数组要比链表更高效，因此多数人优先选择循环数组。</span></span><br><span class="line"><span class="comment">//循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    CircularArrayQueue(<span class="keyword">int</span> capacity) &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="keyword">private</span> E[] elements; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Link head;</span><br><span class="line">    <span class="keyword">private</span> Link tail;</span><br><span class="line">    LinkedListQueue() &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; ... &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用接口类型存放集合的引用</span></span><br><span class="line">Queue&lt;Customer&gt; expresslane = <span class="keyword">new</span> CircularArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">"Harry"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//只需修改接口的引用即可使用另外一种实现</span></span><br><span class="line">Queue&lt;Custoaer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">"Harry"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="2-Collection-接口"><a href="#2-Collection-接口" class="headerlink" title="2. Collection 接口"></a>2. Collection 接口</h2><p>Java类库中集合的基本接口，集合中不允许有重复对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>; <span class="comment">//如果添加元素确实改变了集合就返回 true, 如果集合没有发生变化就返回 false。</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">//iterator方法用于返回一个实现了 Iterator 接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h2><ol>
<li>迭代器是不断向前滑动的，当读取或删除一个元素后就向后滑动一个位置。</li>
<li>元素被访问的顺序取决于集合类型。 如果对 ArrayList 进行迭代， 迭代器将从索引 0开 始，每迭代一次，索引值加1，如果访问 HashSet 中的元素， 每个元素将会按照某种随机的次序出现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Iterator迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;  <span class="comment">//逐个访问集合中的每个元素，在调用 next 之前调用 hasNext方法。如果迭代器对象还有多个供访问的元素， 这个方法就返回 true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;   <span class="comment">//remove的是上一个被next的元素，故remove之前必须调用next方法读取。</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合遍历</span></span><br><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) </span><br><span class="line">&#123;</span><br><span class="line">    String element = iter.next();</span><br><span class="line">    <span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foreach 遍历：可以与任何实现了 Iterable 接口的对象一起工作</span></span><br><span class="line"><span class="comment">//Collection 接口扩展了 Iterable 接口。因此， 对于标准类库中的任何集合都可以使用“ foreach” 循环。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String element : c) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式遍历</span></span><br><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-泛型实用方法"><a href="#4-泛型实用方法" class="headerlink" title="4. 泛型实用方法"></a>4. 泛型实用方法</h2><ol>
<li>由于 Collection 与 Iterator 都是泛型接口，可以编写操作任何集合类型的实用方法。</li>
<li>Collection 接口中已经实现了很多默认方法供类库使用者直接调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstracted1ection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : <span class="keyword">this</span>) <span class="comment">// calls iterator()</span></span><br><span class="line">        <span class="keyword">if</span> (element.equals(obj))</span><br><span class="line">        <span class="keyword">return</span> = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-集合框架中的接口"><a href="#5-集合框架中的接口" class="headerlink" title="5. 集合框架中的接口"></a>5. 集合框架中的接口</h2><p><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E6%8E%A5%E5%8F%A3.png" alt="集合"><br>集合有两个基本接口：Collection 和 Map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection插入读取（使用迭代器）元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Map插入读取元素</span></span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//List 是一个有序集合，可迭代器访问也可随机访问</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Listlterator 接口是 Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//标记接口 RandomAccess 不包含任何方法，不过可以用它来测试一个特定的集合是否支持高效的随机访问。</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(c <span class="keyword">instanceof</span> RandomAccess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    use random access algorithm</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    use sequential access algorithm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集（set) 的 add方法不允许增加重复的元素。</span></span><br><span class="line"><span class="comment">//要适当地定义集的 equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。</span></span><br><span class="line"><span class="comment">//hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口 NavigableSet 和 NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法,TreeSet 和 TreeMap 类实现了这些接口。</span></span><br></pre></td></tr></table></figure>

<h1 id="二、具体的集合"><a href="#二、具体的集合" class="headerlink" title="二、具体的集合"></a>二、具体的集合</h1><p><img src="%E5%85%B7%E4%BD%93%E9%9B%86%E5%90%881.png" alt="集合"><br><img src="%E5%85%B7%E4%BD%93%E9%9B%86%E5%90%882.png" alt="集合"><br>以 Map 结尾的类实现了 Map 接口,除此之外，其他类都实现了Collection 接口。</p>
<h2 id="1-链表（LinkedList）"><a href="#1-链表（LinkedList）" class="headerlink" title="1. 链表（LinkedList）"></a>1. 链表（LinkedList）</h2><ol>
<li>Java中的所有链表实际上都是双向链接的，LinkedList类实现了List接口。</li>
<li>链表是一个有序集合,有n+1个位置添加新元素。</li>
<li>迭代器是描述集合中位置的，所以这种依赖于位置的 add 方法（例如将元素添加到链表中间）将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。</li>
<li>在调用remove之前调用next，则删除的是迭代器左侧元素，若在调用remove之前调用previous，则删除的是右侧元素。</li>
<li>add 方法只依赖于迭代器的位置， 而 remove 方法依赖于迭代器的状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// LinkedList implements List</span></span><br><span class="line">staff.add(<span class="string">"Amy"</span>);   <span class="comment">//LinkedList.add 方法将对象添加到链表的尾部。</span></span><br><span class="line">staff.add(<span class="string">"Bob"</span>)；</span><br><span class="line">staff.add(<span class="string">"Carl"</span>);</span><br><span class="line">Iterator iter = staff.iterator();</span><br><span class="line">String first = iter.next();<span class="comment">// visit first element</span></span><br><span class="line">String second = iter.next(); <span class="comment">//visit second element</span></span><br><span class="line">iter.remove(); <span class="comment">// remove last visited element</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子接口ListIterator</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;  <span class="comment">//假定添加操作总会改变链表，在当前迭代器位置之前添加一个新对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span>   <span class="comment">//反向遍历链表</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ListIterator&lt;String&gt; iter </span>= staff.listIterator();</span><br><span class="line">iter.next();</span><br><span class="line">iter.add(<span class="string">"juliet"</span>);  <span class="comment">//在第二个元素之前添加“Juliet”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。</span></span><br><span class="line"><span class="comment">//添加、删除元素属于结构性修改，而set 方法不被视为结构性修改。</span></span><br><span class="line">ListIterator&lt;String&gt; iter = list.listIterator();</span><br><span class="line">String oldValue = iter.next(); <span class="comment">// returns first element</span></span><br><span class="line">iter.set(newValue); <span class="comment">// sets first element to newValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并发修改异常</span></span><br><span class="line"><span class="comment">//解决方法：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。</span></span><br><span class="line"><span class="comment">//检测并发修改的异常： 每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。</span></span><br><span class="line">List&lt;String&gt; list = ...</span><br><span class="line">ListIterator&lt;String&gt; iter1 = list.listlterator();</span><br><span class="line">ListIterator&lt;String&gt; iter2 = list.listlterator();</span><br><span class="line">iter1.next();</span><br><span class="line">iter1.remove();</span><br><span class="line">iter2.next(); <span class="comment">// throws ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问某个特定元素,效率低</span></span><br><span class="line">LinkedList&lt;String&gt; list = ...;</span><br><span class="line">String obj = list.get(n);  <span class="comment">//每次査找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-数组列表（ArrayList）"><a href="#2-数组列表（ArrayList）" class="headerlink" title="2. 数组列表（ArrayList）"></a>2. 数组列表（ArrayList）</h2><p>ArrayList类实现了List接口，它封装了一个动态再分配的对象数组。</p>
<h2 id="3-散列集（HashSet）"><a href="#3-散列集（HashSet）" class="headerlink" title="3. 散列集（HashSet）"></a>3. 散列集（HashSet）</h2><ol>
<li>在 Java 中，散列表用链表数组实现，散列码是由对象的实例域产生的一个整数。</li>
<li>如果自定义类，就要负责实现这个类的 hashCode 方法，自己实现的 hashCode方法应该与 equals 方法兼容。</li>
<li>散列表可以用来实现Set及HashSet。</li>
<li>装填因子指表大小占预计元素个数的比例，若表中超过该比例的位置已经填入元素，这个表就会用双倍的表长自动地进行再散列。</li>
<li>如果要对散列表再散列， 就需要创建一个表长更大的表，并将所有元素插入到这个新表中，然后丢弃原来的表。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet() <span class="comment">//构造一个空散列表。 </span></span><br><span class="line">HashSet(Collection&lt;? extends E&gt; elements ) <span class="comment">//构造一个散列集， 并将集合中的所有元素添加到这个散列集中。 </span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity) <span class="comment">//构造一个空的具有指定容量（桶数）的散列集。 </span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity , <span class="keyword">float</span> loadFactor ) <span class="comment">//构造一个具有指定容量和装填因子（一个 0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列）的空散列集。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">( )</span>  <span class="comment">//返回这个对象的散列码,equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCode() 必须等于 y.hashCode()。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-树集（TreeSet）"><a href="#4-树集（TreeSet）" class="headerlink" title="4. 树集（TreeSet）"></a>4. 树集（TreeSet）</h2><ol>
<li>树集是一个有序集合，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</li>
<li>排序是利用红黑树实现的，即每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。</li>
<li>要使用树集，必须能够比较元素。这些元素必须实现 Comparable 接口或者构造集时必须提供一个 Comparator。</li>
<li>从 JavaSE 6 起，TreeSet 类实现了 NavigableSet 接口。 这个接口增加了几个便于定位元素以及反向遍历的方法。</li>
</ol>
<h2 id="5-队列与双端队列（Deque）"><a href="#5-队列与双端队列（Deque）" class="headerlink" title="5. 队列与双端队列（Deque）"></a>5. 队列与双端队列（Deque）</h2><p>Deque 接口由 ArrayDeque 和 LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</p>
<h2 id="6-优先级队列（PriorityQueue）"><a href="#6-优先级队列（PriorityQueue）" class="headerlink" title="6. 优先级队列（PriorityQueue）"></a>6. 优先级队列（PriorityQueue）</h2><ol>
<li>优先级队列使用堆对元素进行检索，堆是一个可以自我调整的二叉树，对树执行添加（add) 和删除（remove) 操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</li>
<li>无论何时调用 remove 方法，总会删除当前优先级队列中最小的元素。</li>
</ol>
<h1 id="三、映射"><a href="#三、映射" class="headerlink" title="三、映射"></a>三、映射</h1><p>映射用来存放键/值对。如果提供了键，就能够查找到值。</p>
<h2 id="1-基本映射操作"><a href="#1-基本映射操作" class="headerlink" title="1. 基本映射操作"></a>1. 基本映射操作</h2><ol>
<li>Java 类库为map接口提供了两个通用的实现：HashMap 和 TreeMap。</li>
<li>键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用 put 方法，第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Employee&gt; staff = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>);</span><br><span class="line">staff.put(<span class="string">"987-98-9996"</span>, harry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检索</span></span><br><span class="line">String id = <span class="string">"987-98-9996"</span>; </span><br><span class="line">Employee e = staff.get(id);<span class="comment">// gets harry,如果在映射中没有与给定键对应的信息， get 将返回 null。</span></span><br><span class="line">Map&lt;String, Integer&gt; scores = ...;</span><br><span class="line"><span class="keyword">int</span> score = scores.get(id,<span class="number">0</span>); <span class="comment">// 如果get(id)不存在则默认get(0)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//remove 方法用于从映射中删除给定键对应的元素。size 方法用于返回映射中的元素数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式遍历映射</span></span><br><span class="line">scores.forEach((k, v) -&gt; System.out.println(<span class="string">"key="</span> + k + <span class="string">", value:"</span> + v));</span><br></pre></td></tr></table></figure>

<h2 id="2-更新映射项"><a href="#2-更新映射项" class="headerlink" title="2. 更新映射项"></a>2. 更新映射项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">counts.put(word, counts.get(word)+ <span class="number">1</span>); <span class="comment">//当第一次添加 word 时，get 会返回 null, 因此会出现一个 NullPointerException 异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">counts,put(word, counts.getOrDefault(word, <span class="number">0</span>)+ <span class="number">1</span>);  <span class="comment">//若word第一次添加，则利用默认值+1</span></span><br><span class="line"></span><br><span class="line">counts.putlfAbsent(word, <span class="number">0</span>);  <span class="comment">//只有当键原先存在时才会放入一个值。</span></span><br><span class="line">counts.put(word, counts.get(word)+ <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);  <span class="comment">//如果键原先不存在，将把word与1关联，否则将原值和1求和。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-映射视图"><a href="#3-映射视图" class="headerlink" title="3. 映射视图"></a>3. 映射视图</h2><ol>
<li>映射有三种视图：键集、 值集合（不是一个集） 以及键/值对集。</li>
<li>不能向键集视图和键值对视图中增加元素，但可以删除，若试图调用 add方法， 它会抛出一个 UnsupportedOperationException。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种视图</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span>  <span class="comment">//keySet是实现了 Set 接口的另外某个类的对象。</span></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K, V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//视图遍历</span></span></span><br><span class="line"><span class="function"><span class="comment">//键视图</span></span></span><br><span class="line"><span class="function">Set&lt;String&gt; keys </span>= map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keys) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键值对视图</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Employee&gt; entry : staff.entrySet()) </span><br><span class="line">&#123;</span><br><span class="line">    String k = entry.getKey();</span><br><span class="line">    Employee v = entry.getValue();</span><br><span class="line">    <span class="keyword">do</span> something with k, v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counts.forEach((k，v) -&gt; &#123;<span class="keyword">do</span> somethingwith k, v &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-弱散列映射-WeakHashMap"><a href="#4-弱散列映射-WeakHashMap" class="headerlink" title="4. 弱散列映射(WeakHashMap)"></a>4. 弱散列映射(WeakHashMap)</h2><ol>
<li>WeakHashMap用来配合垃圾回收器删除无用映射对象。</li>
<li>WeakHashMap 使用弱引用 （ weak references) 保存键。WeakReference 对象将引用保存到另外一个对象中，在这里，就是散列键。</li>
<li>如果某个对象只能由 WeakReference 引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap 将周期性地检查队列，以便找出新添加的弱引用，然后由WeakHashMap 删除对应的条目。</li>
</ol>
<h2 id="5-链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）"><a href="#5-链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）" class="headerlink" title="5. 链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）"></a>5. 链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）</h2><ol>
<li>LinkedHashSet 和 LinkedHashMap 类用来记住插入元素项的顺序，当条目插入到表中时，就会并入到双向链表中。</li>
<li>LinkedHashSet 按照插入顺序来访问元素项。</li>
<li>LinkedHashMap 按照“最近最少使用”原则来访问元素项，每次调用 get 或put访问一个元素后，该元素就被从当前位置删除并放到链表的尾部。当在表中找不到元素项且表又已经满时，可以将迭代器加入到表中，并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造散列映射表</span></span><br><span class="line">LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, <span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个覆盖了removeEldestEntry方法的子类以实现自动化删除最近最少使用元素</span></span><br><span class="line">Map&lt;K, V&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">128</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">100</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<h2 id="6-枚举集（EnumSet）与枚举映射（EnumMap）"><a href="#6-枚举集（EnumSet）与枚举映射（EnumMap）" class="headerlink" title="6. 枚举集（EnumSet）与枚举映射（EnumMap）"></a>6. 枚举集（EnumSet）与枚举映射（EnumMap）</h2><ol>
<li>所有的枚举类型都扩展于泛型 Enum 类。</li>
<li>EnumSet 是一个枚举类型元素集的高效实现，内部用位序列实现。如果对应的值在集中，则相应的位被置为 1。</li>
<li>EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);</span><br><span class="line"></span><br><span class="line">EnumMap&lt;Weekday, Employee&gt; personlnCharge = <span class="keyword">new</span> EnumMapo(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-标识散列映射（IdentityHashMap）"><a href="#7-标识散列映射（IdentityHashMap）" class="headerlink" title="7. 标识散列映射（IdentityHashMap）"></a>7. 标识散列映射（IdentityHashMap）</h2><ol>
<li>类 IdentityHashMap的键的散列值不是用 hashCode 函数计算的，而是用 System.identityHashCode 方法由Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式计算的。</li>
<li>在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals，即不同的键对象， 即使内容相同， 也被视为是不同的对象。</li>
<li>在实现对象遍历算法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。</li>
</ol>
<h1 id="四、视图与包装器"><a href="#四、视图与包装器" class="headerlink" title="四、视图与包装器"></a>四、视图与包装器</h1><p>映射类中的keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h2 id="1-轻量级集合包装器-Collections"><a href="#1-轻量级集合包装器-Collections" class="headerlink" title="1. 轻量级集合包装器(Collections)"></a>1. 轻量级集合包装器(Collections)</h2><p>Collections 类包含很多实用方法， 这些方法的参数和返回值都是集合，如空集、 列表、 映射等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个包装了普通 Java 数组的 List 包装器。</span></span><br><span class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);  <span class="comment">//是一个视图对象， 带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法（例如，与迭代器相关的 add 和 remove 方法）都会抛出一个</span></span><br><span class="line">                                                <span class="comment">//Unsupported OperationException 异常。</span></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span> , <span class="string">"Bob"</span>, <span class="string">"Carl "</span>); <span class="comment">//返回一个实现了 List 接口的不可修改的对象</span></span><br><span class="line">List&lt;String&gt; settings = Collections.nCopies(<span class="number">100</span>, <span class="string">"DEFAULT"</span>); <span class="comment">//创建一个包含100个字符串的List, 每个串都被设置为“DEFAULT”</span></span><br></pre></td></tr></table></figure>

<h2 id="2-子范围视图"><a href="#2-子范围视图" class="headerlink" title="2. 子范围视图"></a>2. 子范围视图</h2><p>可以为很多集合建立子范围视图，将任何操作应用于子范围，并且能够自动地反映整个列表的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List group2 = staff.subList(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">//返回索引[10.20)之间的子范围元素视图</span></span><br><span class="line">group2.clear();  <span class="comment">//删除子视图元素，反映到整个列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于有序集和映射， 可以使用排序顺序而不是元素位置建立子范围。</span></span><br><span class="line"><span class="comment">//返回大于等于 from 且小于 to 的所有元素子集。</span></span><br><span class="line">SortedSet&lt; E&gt; subSet(E from, E to)</span><br><span class="line">SortedSet&lt; E&gt; headSet(E to)</span><br><span class="line">SortedSet&lt; E&gt; <span class="function">tail <span class="title">Set</span><span class="params">(E from)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K from, K to)</span></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//NavigableSet 接口赋予子范围操作更多的控制能力。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive, E to, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to, <span class="keyword">boolean</span> tolncIusive)</span></span></span><br><span class="line"><span class="function">Navigab1eSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-不可修改的视图"><a href="#3-不可修改的视图" class="headerlink" title="3. 不可修改的视图"></a>3. 不可修改的视图</h2><ol>
<li>Collections 还有几个方法，用于产生集合的不可修改视图,这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改， 就抛出一个异常，同时这个集合将保持未修改的状态。</li>
<li>由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下方法可获得一个不可修改视图</span></span><br><span class="line"><span class="comment">//它的 equals 方法不调用底层集合的 equals 方法。它继承了 Object 类的 equals 方法， 这个方法只是检测两个对象是否是同一个对象。</span></span><br><span class="line">Collections.unmodifiableCollection  </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用底层集合的 equals 方法和 hashCode 方法。</span></span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line"></span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure>

<h2 id="4-同步视图"><a href="#4-同步视图" class="headerlink" title="4. 同步视图"></a>4. 同步视图</h2><ol>
<li>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。</li>
<li>同步操作即在另一个线程调用另一个方法之前，刚才的方法调用必须彻底完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collections 类的静态 synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的 Map</span></span><br><span class="line">Map&lt;String, Employee&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Employee&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="5-受查视图"><a href="#5-受查视图" class="headerlink" title="5. 受查视图"></a>5. 受查视图</h2><p>受查视图可以在调用add 方法时检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 ClassCastException。这样做的好处是错误可以在正确的位置得以报告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayListo()</span><br><span class="line">ArrayList rawList = strings; <span class="comment">// 仅出现警告</span></span><br><span class="line">rawList.add(<span class="keyword">new</span> Date()); <span class="comment">// now strings contains a Date object!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：使用受查视图</span></span><br><span class="line">List&lt;String&gt; safestrings = Collections.checkedList(strings，String,<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">ArrayList rawList = safestrings;</span><br><span class="line">rawList.add(<span class="keyword">new</span> Date());<span class="comment">// 抛出异常 ClassCastException</span></span><br></pre></td></tr></table></figure>

<h1 id="五、算法"><a href="#五、算法" class="headerlink" title="五、算法"></a>五、算法</h1><h2 id="1-排序与混排"><a href="#1-排序与混排" class="headerlink" title="1. 排序与混排"></a>1. 排序与混排</h2><ol>
<li>java中对列表的排序直接将所有元素转入一个数组，对数组进行排序，然后再将排序后的序列复制回列表。</li>
<li>不能将不可修改列表如unmodifiableList 列表传递给排序算法，传递的列表必须是可修改的，但不必是可以改变大小的。<ul>
<li>如果列表支持 set 方法，则是可修改的。</li>
<li>如果列表支持 add 和 remove 方法， 则是可改变大小的。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">fill collection</span><br><span class="line">Collections.sort(staff);   <span class="comment">//方法假定列表元素实现了 Comparable 接口</span></span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));  <span class="comment">//使用 List 接口的 sort方法并传入一个 Comparator 对象。</span></span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.reverseOrder());  <span class="comment">//按降序排列</span></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed())  <span class="comment">//按工资逆序排序</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);  <span class="comment">//随机地混排列表中元素的顺序,如果提供的列表没有实现 RandomAccess 接口，shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-二分查找（binarySearch）"><a href="#2-二分查找（binarySearch）" class="headerlink" title="2. 二分查找（binarySearch）"></a>2. 二分查找（binarySearch）</h2><ol>
<li>要使用二分查找，必须提供排好序的集合以及要查找的元素，且该集合必须实现List接口。</li>
<li>如果集合没有采用 Comparable 接口的 compareTo 方法进行排序， 就还要提供一个比较器对象。</li>
<li>只有采用随机访问，二分査找才有意义，若果为 binarySearch 算法提供一个链表，它将自动地变为线性查找。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值 &gt;=0 ,表示匹配对象的索引。</span></span><br><span class="line"><span class="comment">//返回负值，表示没有匹配的元素。应该将这个键插人到列表索引（-i - l）的位置上，以保持列表的有序性。</span></span><br><span class="line">i = Collections.binarySearch(c, element); </span><br><span class="line">i = Collections.binarySearch(c, element, comparator);</span><br><span class="line">c.get(i);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">    c.add(-i - <span class="number">1</span>, element);</span><br></pre></td></tr></table></figure>

<h2 id="3-简单算法"><a href="#3-简单算法" class="headerlink" title="3. 简单算法"></a>3. 简单算法</h2><p>Collections 类中提供的各种简单算法可以增加代码的可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.replaceAll (<span class="string">"C++"</span>, <span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">words.removelf(w -&gt; w.length() &lt;= <span class="number">3</span>);</span><br><span class="line">words.replaceAll(String::toLowerCase);</span><br></pre></td></tr></table></figure>

<h2 id="4-批操作"><a href="#4-批操作" class="headerlink" title="4. 批操作"></a>4. 批操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 coll1 中删除 coll2 中出现的所有元素。</span></span><br><span class="line">colll.removeAll(coll2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求coll1和coll2的交集</span></span><br><span class="line">coll1.retainAll(coll2);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">result.retainAll(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在视图上批量操作</span></span><br><span class="line">Map&lt;String, Employee&gt; staffMap = ...;</span><br><span class="line">Set&lt;String&gt; terminatedIDs = ...;</span><br><span class="line">staffMap.keySet().removeAll(terminatedIDs);</span><br><span class="line">relocated.addAll(staff.subList(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">staff.subList(<span class="number">0</span>, <span class="number">10</span>).clear();</span><br></pre></td></tr></table></figure>

<h2 id="5-集合与数组的转换"><a href="#5-集合与数组的转换" class="headerlink" title="5. 集合与数组的转换"></a>5. 集合与数组的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把一个数组转换为集合</span></span><br><span class="line">String[] values = ...;</span><br><span class="line">HashSet&lt;String&gt; staff = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//从集合得到数组</span></span><br><span class="line">Object[] values = staff.toArray();   <span class="comment">//返回的数组是一个 Object[] 数组，不能使用强制类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个所需类型而且长度为 0 的数组</span></span><br><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);  <span class="comment">// 返回的数组就会创建为相同的数组类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以构造一个指定大小的数组</span></span><br><span class="line">staff.toArray(<span class="keyword">new</span> String[staff.size()]);  <span class="comment">//这种情况不会创建新数组</span></span><br></pre></td></tr></table></figure>

<h2 id="6-编写自己的算法"><a href="#6-编写自己的算法" class="headerlink" title="6. 编写自己的算法"></a>6. 编写自己的算法</h2><p>如果编写自己的算法（实际上，是以集合作为参数的任何方法，) 应该尽可能地使用接口，而不要使用具体的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用接口作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillMenu</span><span class="params">(]Menu menu, Collection&lt;]MenuItem&gt; items)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (JMenuItem item : items)</span><br><span class="line">        menu.add(item); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回接口,在这种情况下，调用者返回的对象是一个不可修改的列表。</span></span><br><span class="line">List&lt;]MenuItem&gt; getAllItems(<span class="keyword">final</span> JHenu menu) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span></span><br><span class="line">    AbstractList&lt;&gt;() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> JMenuItem <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> menu.getltem(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> menu.getltemCount(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、遗留的集合"><a href="#六、遗留的集合" class="headerlink" title="六、遗留的集合"></a>六、遗留的集合</h1><p>在集合框架出现之前已经存在大量“遗留的” 容器类。这些类已经集成到集合框架中。<br><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%81%97%E7%95%99%E7%B1%BB.png" alt="遗留类"></p>
<h2 id="1-Hashtable-类"><a href="#1-Hashtable-类" class="headerlink" title="1. Hashtable 类"></a>1. Hashtable 类</h2><ol>
<li>Hashtable 类与 HashMap 类的作用一样，它们拥有相同的接口。</li>
<li>Hashtable 和Vector类的方法是同步的，如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 HashMap。如果需要并发访问， 则要使用 ConcurrentHashMap。</li>
</ol>
<h2 id="2-枚举（Enumeration）"><a href="#2-枚举（Enumeration）" class="headerlink" title="2. 枚举（Enumeration）"></a>2. 枚举（Enumeration）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遗留集合使用 Enumeration 接口对元素序列进行遍历。</span></span><br><span class="line">Enumeration&lt;Employee&gt; e = staff.elements();</span><br><span class="line">whi1e (e.HasMoreElements()) </span><br><span class="line">&#123;</span><br><span class="line">    Employee e = e.nextElement(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留方法，其参数是枚举类型的。</span></span><br><span class="line">List&lt;InputStream&gt; streams = ...;</span><br><span class="line">SequenceInputStream in = <span class="keyword">new</span> SequencelnputStream(Collections.enumeration(streams));</span><br></pre></td></tr></table></figure>

<h2 id="3-属性映射（Properties）"><a href="#3-属性映射（Properties）" class="headerlink" title="3. 属性映射（Properties）"></a>3. 属性映射（Properties）</h2><p>属性映射是一个类型非常特殊的映射结构,通常用于程序的特殊配置选项。</p>
<ul>
<li>键与值都是字符串。 </li>
<li>表可以保存到一个文件中，也可以从文件中加载。 </li>
<li>使用一个默认的辅助表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties() <span class="comment">//创建一个空的属性映射。 </span></span><br><span class="line">Properties(Properties defaults)  <span class="comment">//创建一个带有一组默认值的空的属性映射。 </span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span> <span class="comment">//获得属性的对应关系；返回与键对应的字符串。 如果在映射中不存在，返回默认表中与这个键对应的字符串。 </span></span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span> <span class="comment">//获得在键没有找到时具有的默认值属性；它将返回与键对应的字符串，如果在映射中不存在，就返回默认的字符串。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span>  <span class="comment">//从 InputStream 加载属性映射。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out, String commentstring)</span> <span class="comment">//把属性映射存储到 OutputStream。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-栈（Stack）"><a href="#4-栈（Stack）" class="headerlink" title="4. 栈（Stack）"></a>4. 栈（Stack）</h2><p>Stack类扩展于Vector类，Vector 类并不太令人满意，它可以让栈使用不属于栈操作的 insert 和 remove 方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E item)</span> <span class="comment">//将 item 压入桟并返回 item。  </span></span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span> <span class="comment">//弹出并返回栈顶的 item。如果栈为空，请不要调用这个方法。 </span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span> <span class="comment">//返回栈顶元素，但不弹出。如果栈为空，请不要调用这个方法。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="5-位集（BitSet）"><a href="#5-位集（BitSet）" class="headerlink" title="5. 位集（BitSet）"></a>5. 位集（BitSet）</h2><ol>
<li>BitSet 类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适)。如果需要高效地存储位序列（例如，标志）就可以使用位集。</li>
<li>由于位集将位包装在字节里，所以使用位集要比使用 Boolean 对象的 ArrayList 更加高效。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bucketOfBits.get(i) <span class="comment">//如果第 i 位处于“开” 状态，就返回 true; 否则返回 false。</span></span><br><span class="line">bucketOfBits.set(i) <span class="comment">//将第 i 位置为“开” 状态。</span></span><br><span class="line">bucketOfBits.clear(i)  <span class="comment">//将第 i 位置为“关” 状态。</span></span><br><span class="line"></span><br><span class="line">BitSet(<span class="keyword">int</span> initialCapacity) <span class="comment">//创建一个位集。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//返回位集的“逻辑长度”， 即 1 加上位集的最高设置位的索引。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">and</span><span class="params">(BitSet set )</span> <span class="comment">//这个位集与另一个位集进行逻辑“ AND”。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">or</span><span class="params">(BitSet set )</span> <span class="comment">//这个位集与另一个位集进行逻辑“ OR”。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(BitSet set )</span> <span class="comment">//这个位集与另一个位集进行逻辑“ X0R” 异或。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andNot</span><span class="params">(BitSet set)</span> <span class="comment">//清除这个位集中对应另一个位集中设置的所有位。</span></span></span><br></pre></td></tr></table></figure>

</div><div class="tags"><a href="/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Java基础知识</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2020/05/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/" class="pre">Java中的并发</a><a href="/2020/05/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="next">Java中的泛型程序设计</a></div><div id="comments"><div id="SOHUCS" sid="2020/05/26/Java基础知识/Java中的集合/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Java-集合框架"><span class="toc-text">一、Java 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-将集合的接口与实现分离"><span class="toc-text">1. 将集合的接口与实现分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Collection-接口"><span class="toc-text">2. Collection 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-迭代器"><span class="toc-text">3. 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-泛型实用方法"><span class="toc-text">4. 泛型实用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-集合框架中的接口"><span class="toc-text">5. 集合框架中的接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、具体的集合"><span class="toc-text">二、具体的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-链表（LinkedList）"><span class="toc-text">1. 链表（LinkedList）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数组列表（ArrayList）"><span class="toc-text">2. 数组列表（ArrayList）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-散列集（HashSet）"><span class="toc-text">3. 散列集（HashSet）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-树集（TreeSet）"><span class="toc-text">4. 树集（TreeSet）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-队列与双端队列（Deque）"><span class="toc-text">5. 队列与双端队列（Deque）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-优先级队列（PriorityQueue）"><span class="toc-text">6. 优先级队列（PriorityQueue）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、映射"><span class="toc-text">三、映射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-基本映射操作"><span class="toc-text">1. 基本映射操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-更新映射项"><span class="toc-text">2. 更新映射项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-映射视图"><span class="toc-text">3. 映射视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-弱散列映射-WeakHashMap"><span class="toc-text">4. 弱散列映射(WeakHashMap)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）"><span class="toc-text">5. 链接散列集（LinkedHashSet）与链接映射（LinkedHashMap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-枚举集（EnumSet）与枚举映射（EnumMap）"><span class="toc-text">6. 枚举集（EnumSet）与枚举映射（EnumMap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-标识散列映射（IdentityHashMap）"><span class="toc-text">7. 标识散列映射（IdentityHashMap）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、视图与包装器"><span class="toc-text">四、视图与包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-轻量级集合包装器-Collections"><span class="toc-text">1. 轻量级集合包装器(Collections)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-子范围视图"><span class="toc-text">2. 子范围视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-不可修改的视图"><span class="toc-text">3. 不可修改的视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-同步视图"><span class="toc-text">4. 同步视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-受查视图"><span class="toc-text">5. 受查视图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、算法"><span class="toc-text">五、算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-排序与混排"><span class="toc-text">1. 排序与混排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-二分查找（binarySearch）"><span class="toc-text">2. 二分查找（binarySearch）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-简单算法"><span class="toc-text">3. 简单算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-批操作"><span class="toc-text">4. 批操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-集合与数组的转换"><span class="toc-text">5. 集合与数组的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编写自己的算法"><span class="toc-text">6. 编写自己的算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、遗留的集合"><span class="toc-text">六、遗留的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Hashtable-类"><span class="toc-text">1. Hashtable 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-枚举（Enumeration）"><span class="toc-text">2. 枚举（Enumeration）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-属性映射（Properties）"><span class="toc-text">3. 属性映射（Properties）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-栈（Stack）"><span class="toc-text">4. 栈（Stack）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-位集（BitSet）"><span class="toc-text">5. 位集（BitSet）</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/JDBC/Apache-DBUtils%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C/">Apache-DBUtils实现CRUD操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/JDBC/%20Druid%EF%BC%88%E5%BE%B7%E9%B2%81%E4%BC%8A%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">Druid数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/JDBC/DBCP%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">DBCP数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/JDBC/C3P0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">C3P0数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">数据库连接池</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/DAO%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/">DAO开发模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/JDBC%E8%AE%BE%E7%BD%AEMySQL%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">使用JDBC设置MySQL的隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/JDBC/%E4%BD%BF%E7%94%A8JDBC%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1/">使用JDBC操作事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/22/JDBC/JDBC%E4%B8%AD%E7%9A%84%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/">JDBC中的批量插入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/JDBC/JDBC%E6%93%8D%E4%BD%9CBLOB%E5%AD%97%E6%AE%B5/">JDBC操作BLOB字段</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDE/">IDE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDBC/">JDBC</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">Java基础知识</a> <a href="/tags/C-C-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">C/C++算法</a> <a href="/tags/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 15px;">JVM自动内存管理</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/IDE/" style="font-size: 15px;">IDE</a> <a href="/tags/JDBC/" style="font-size: 15px;">JDBC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://docschina.org/" title="印象中文" target="_blank">印象中文</a><ul></ul><a href="https://kingdot.github.io/" title="木丁夕雨何" target="_blank">木丁夕雨何</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><span>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i> 次</i></span><span>|</span><span>Copyright &copy;<a href="/." rel="nofollow">桃子果汁.</a></span></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?281cc941ca205b4ebca856d71ae45a55";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytF5aDWy'; 
  var conf = 'prod_0650efe38e465b0e4820ce8d9c386815'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>