<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="后端小萌新进阶大佬之路"><meta name="keywords" content="后端,Spring MVC,html,css,java,mysql"><title>Java中的泛型程序设计 | 桃子果汁</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的泛型程序设计</h1><a id="logo" href="/.">桃子果汁</a><p class="description">向阳生长</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java中的泛型程序设计</h1><div class="post-meta"><a href="/2020/05/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2020/05/25/Java基础知识/Java中的泛型程序设计/"></i>留言,<i id="changyan_parti_unit" data-xid="2020/05/25/Java基础知识/Java中的泛型程序设计/"></i>参与</a><p><span class="date">May 25, 2020</span><span><a href="/categories/Java/" class="category">Java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="一、定义简单泛型类"><a href="#一、定义简单泛型类" class="headerlink" title="一、定义简单泛型类"></a>一、定义简单泛型类</h1><ol>
<li>一个泛型类就是具有一个或多个<strong>类型变量</strong>的类。</li>
<li>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。</li>
<li>类型变量使用大写形式，变量 E 表示集合的元素类型，K 和 V 分别表示表的关键字与值的类型，T 可表示任意类型。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，换句话说，泛型类可看作普通类的工厂。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义简单泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; first = <span class="keyword">null</span> ; second = <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123; <span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123; first = newValue; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123; second = newValue; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入多个类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123; . . . &#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、泛型方法"><a href="#二、泛型方法" class="headerlink" title="二、泛型方法"></a>二、泛型方法</h1><ol>
<li>可以定义一个带有类型参数的简单方法，称为泛型方法。</li>
<li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>
<li>当调用一个泛型方法时,在方法名前的尖括号中放入具体的类型,有些情况下具体类型可省略。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span> <span class="comment">//参数类型放在方法返回值前面</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用泛型方法</span></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>, <span class="string">"Q"</span>, <span class="string">"Public"</span>);</span><br><span class="line"><span class="comment">//编译器能够用 names 的类型（即 String[ ]) 与泛型类型 T[ ]进行匹配并推断出 T 一定是 String。故在这种情况下可省略类型参数。</span></span><br><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">"John"</span>, <span class="string">"Q"</span>, <span class="string">"Public"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器将会自动打包参数为 1 个Double 和 2 个 Integer 对象，而后寻找这些类的共同超类型为Number 和 Comparable 接口，此时会得到一个错误报告提示可以将结果赋给Number 或 Comparable 接口。</span></span><br><span class="line"><span class="comment">//可以使用这种方式有目的地引入一个错误，并研究编译器对一个泛型方法调用最终推断出哪种类型</span></span><br><span class="line"><span class="keyword">double</span> middle = ArrayAlg.getMiddle(<span class="number">3.14</span>, <span class="number">1729</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="三、类型变量的限定"><a href="#三、类型变量的限定" class="headerlink" title="三、类型变量的限定"></a>三、类型变量的限定</h1><ol>
<li>利用关键字extends来限定类型变量，一个类型变量或通配符可以有多个限定，用<code>&amp;</code>分隔，而逗号用来分隔类型变量。</li>
<li><font color=Crmison>可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。</font></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//对T进行限定：表明泛型的min方法只能被实现了 Comparable 接口的类（如 String、 LocalDate 等）的数组调用。否则会产生一个编译错误。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparab1e&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> <span class="comment">// almost correct</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">null</span> || a.length = <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        T smallest = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (smallest.compareTo(a[i]) &gt; <span class="number">0</span>) smallest = a[i];</span><br><span class="line">        <span class="keyword">return</span> smallest; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个类型变量或通配符可以有多个限定，&amp;隔开</span></span><br><span class="line">T extends Comparable &amp; Serializable</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a = <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    T min = a[<span class="number">0</span>];</span><br><span class="line">    T max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inin.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i]; &lt;<span class="number">2</span> <span class="keyword">if</span> (max .coinpareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、泛型代码和虚拟机"><a href="#四、泛型代码和虚拟机" class="headerlink" title="四、泛型代码和虚拟机"></a>四、泛型代码和虚拟机</h1><h2 id="1-类型擦除"><a href="#1-类型擦除" class="headerlink" title="1. 类型擦除"></a>1. 类型擦除</h2><p>虚拟机没有泛型类型对象—所有对象都属于普通类。Java中的泛型是用擦除实现的，即仅于编译时类型检查，在运行时擦除类型信息，这样可以避免运行时代码膨胀。</p>
<ol>
<li>无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型。</li>
<li>原始类型就是擦除类型变量, 并替换为限定类型（无限定的变量用 Object 替换）后的普通类型。</li>
<li>原始类型用第一个限定的类型变量来替换， 如果没有给定限定就用 Object 替换。</li>
<li>为了提高效率，应该将标签接口（即没有方法的接口）放在边界列表的末尾。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span>  //可以实现接口</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span> <span class="params">(T first, T second)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; lower = second; upper = first; &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的原始类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span> <span class="params">(Comparable first, Comparable second)</span> </span>&#123; . . . &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-翻译泛型表达式"><a href="#2-翻译泛型表达式" class="headerlink" title="2. 翻译泛型表达式"></a>2. 翻译泛型表达式</h2><ol>
<li>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。</li>
<li>当存取一个泛型域时也要插入强制类型转换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器把这个方法调用翻译为两条虚拟机指令：对原始方法 Pair.getFirst 的调用;  将返回的 Object 类型强制转换为 Employee 类型。</span></span><br><span class="line">Pair&lt;Employee&gt; buddies = . .</span><br><span class="line">Employee buddy = buddies.getFirst();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//假设Pair 类的 first 域和 second 域都是公有的</span></span><br><span class="line">Employee buddy = buddies.first; <span class="comment">//会在结果字节码中插人强制类型转换。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-翻译泛型方法"><a href="#3-翻译泛型方法" class="headerlink" title="3. 翻译泛型方法"></a>3. 翻译泛型方法</h2><ol>
<li>类型擦除之前认为泛型方法为一个方法族，而擦除类型之后，只剩下一个方法。</li>
<li>类型擦除与多态发生了冲突，要想多态正确的发挥作用，需要编译器在 Datelnterval 类中生成一个桥方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Datelnterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.compareTo(getFirst()) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">super</span>.setSecond(second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成桥方法来保持多态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span> </span>&#123; setSecond((Date) second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Datelnterval interval = <span class="keyword">new</span> Datelnterval(. . .);</span><br><span class="line">Pair&lt;Loca1Date&gt; pair = interval; </span><br><span class="line">pair.setSecond(aDate); </span><br><span class="line"></span><br><span class="line"><span class="comment">//对于可协变返回类型的方法不能生成桥方法，因为在虚拟机中，用参数类型和返回类型确定一个方法。虚拟机能够正确处理这一情况。</span></span><br><span class="line"><span class="function">LocalDate <span class="title">getSecond</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Object <span class="title">getSecond</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>有关 Java 泛型转换的事实:</p>
<ol>
<li>虚拟机中没有泛型，只有普通的类和方法。</li>
<li>所有的类型参数都用它们的限定类型替换。</li>
<li>桥方法被合成来保持多态。 </li>
<li>为保持类型安全性，必要时插入强制类型转换。</li>
</ol>
<h2 id="4-调用遗留代码"><a href="#4-调用遗留代码" class="headerlink" title="4. 调用遗留代码"></a>4. 调用遗留代码</h2><ol>
<li>Java允许泛型代码和遗留代码之间能够互操作。</li>
<li>当利用原始类型操作泛型对象时以及由遗留的类得到一个原始类型的对象时都会产生一个警告，若在设计代码时可以确保不会发生错误，则可以使用注解<code>@SuppressWarnings(&quot;unchecked&quot;)</code>消除这些警告。</li>
</ol>
<h1 id="五、约束与局限性"><a href="#五、约束与局限性" class="headerlink" title="五、约束与局限性"></a>五、约束与局限性</h1><p>在使用泛型时需要考虑一些限制，大多数限制都是由类型擦除引起的。</p>
<h2 id="1-不能用基本类型实例化类型参数"><a href="#1-不能用基本类型实例化类型参数" class="headerlink" title="1. 不能用基本类型实例化类型参数"></a>1. 不能用基本类型实例化类型参数</h2><ol>
<li>不能用基本类型实例化类型参数的原因是类型擦除，擦除之后原始类型中含有Object类型的域，而 Object 不能存储基本类型的值。</li>
<li>这并不是一个致命的缺陷，它与Java 语言中基本类型的独立状态相一致。</li>
</ol>
<h2 id="2-运行时类型查询只适用于原始类型"><a href="#2-运行时类型查询只适用于原始类型" class="headerlink" title="2. 运行时类型查询只适用于原始类型"></a>2. 运行时类型查询只适用于原始类型</h2><p>因为虚拟机中没有泛型类型，而是总有一个特定的非泛型类型，故运行时类型查询只适用于原始类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">// 会得到一个编译器错误</span></span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; <span class="comment">//会得到一个警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//getClass 方法总是返回原始类型。</span></span><br><span class="line">Pair&lt;String&gt; stringPair = . .</span><br><span class="line">Pair&lt;Employee&gt; employeePair = . .</span><br><span class="line"><span class="keyword">if</span> (stringPair.getClass() == employeePair.getClass()) <span class="comment">//比较的结果是 true, 这是因为两次调用 getClass 都将返回 Pair.class。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-不能创建参数化类型的数组"><a href="#3-不能创建参数化类型的数组" class="headerlink" title="3. 不能创建参数化类型的数组"></a>3. 不能创建参数化类型的数组</h2><ol>
<li><font color=Crmison>因为类型擦除会让数组能够记住它的元素类型的机制失效，往参数化类型数组中添加各种类型后就能够通过数组检查，这违背了泛型设计的原则，故不能创建参数化类型的数组。</font></li>
<li>只是不允许创建这些数组，而声明类型为 <code>Pair&lt;String&gt;[]</code> 的变量仍是合法的,只是不能通过<code>new Pair&lt;String&gt;[10]</code> 初始化这个变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//table 的类型是 Pair[] 可以把它转换为 Object[] </span></span><br><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// 不能创建参数化类型的数组</span></span><br><span class="line">Object[] objarray = table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型擦除使数组能够记住它的元素类型的机制失效了，即以下赋值能够通过存储检查，</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="string">"Hello"</span>;  <span class="comment">//运行时会导致一个类型错误，违背了泛型设计的原则。</span></span><br><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以声明通配类型的数组， 然后进行类型转换,但这样是不安全的</span></span><br><span class="line"><span class="comment">//如果在 table[0] 中存储一个 Pair&lt;Employee&gt;, 然后对 table[0].getFirst() 调用一个 String 方法， 会得到一个 ClassCastException 异常。</span></span><br><span class="line">Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) <span class="keyword">new</span> Pair&lt;?&gt;[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//收集参数化类型对象的唯一安全有效的方法</span></span><br><span class="line">ArrayList:ArrayList&lt;Pair&lt;String&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-Varargs-警告"><a href="#4-Varargs-警告" class="headerlink" title="4. Varargs 警告"></a>4. Varargs 警告</h2><ol>
<li>向参数个数可变的方法传递一个泛型类型的实例时，Java 虚拟机必须建立一个 <code>Pair&lt;String&gt;</code> 数组，这就违反了虚拟机中没有泛型的规则，但是对于这种情况只会得到一个警告而不是错误。</li>
<li>可增加注解<code>@SuppressWamings(&quot;unchecked&quot;。)</code>或<code>@SafeVarargs</code>来抑制这个警告，之后就可以提供泛型类型来调用这个方法了。</li>
<li>对于只需要读取参数数组元素的所有方法，都可以使用这两个注解。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collections coll, T... ts)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (t : ts) coll.add(t);</span><br><span class="line">&#125;</span><br><span class="line">Col1ection&lt;Pair&lt;String&gt;&gt; table = . . .;</span><br><span class="line">Pair&lt;String&gt; pairl = . . .;</span><br><span class="line">Pair&lt;String&gt; pair2 = . .</span><br><span class="line">addAll(table, pairl, pair2);</span><br><span class="line"></span><br><span class="line"><span class="meta">@SafeVarargs</span> <span class="keyword">static</span> &lt;E&gt; E[] array(E... array) &#123; <span class="keyword">return</span> array;&#125;</span><br><span class="line">Pair&lt;String&gt;[] table = array(pairl, pair2);</span><br><span class="line">Object[] objarray = table;</span><br><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();  <span class="comment">//能顺利运行而不会出现 ArrayStoreException 异常（因为数组存储只会检查擦除的类型) 但在处理 table[0] 时会在别处得到一个异常。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-不能实例化类型变量"><a href="#5-不能实例化类型变量" class="headerlink" title="5. 不能实例化类型变量"></a>5. 不能实例化类型变量</h2><ol>
<li>不能使用像 <code>new T(...)</code> <code>new T[...]</code> 或 <code>T.class</code> 这样的表达式中的类型变量。</li>
<li>解决办法是让调用者提供一个构造器表达式或者通过反射调用 <code>Class.newInstance</code> 方法来构造泛型对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; first = <span class="keyword">new</span> T(); second = <span class="keyword">new</span> T(); &#125;</span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">first = T<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>; </span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> Pair(cl.newInstance(), cl.newInstance()); &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125; </span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-不能构造泛型数组"><a href="#6-不能构造泛型数组" class="headerlink" title="6. 不能构造泛型数组"></a>6. 不能构造泛型数组</h2><p>因为数组中的类型在虚拟机中会被擦除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉 T[] minmax(T[] a) &#123; T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>]; . . . &#125;  <span class="comment">//类型擦除会让这个方法永远构造 Comparable[2] 数组。</span></span><br><span class="line"><span class="comment">//Error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmax(T... a) &#123;</span><br><span class="line">Object[] mm = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> (T[]) mm; <span class="comment">// compiles with warning</span></span><br><span class="line">&#125;</span><br><span class="line">String[] ss = ArrayAlg.minmax(<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="comment">//用户提供一个数组构造器表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmax(IntFunction&lt;TD&gt; constr, T... a) </span><br><span class="line">&#123; </span><br><span class="line">    T[] mm = constr.apply(<span class="number">2</span>); </span><br><span class="line">&#125;</span><br><span class="line">String口 ss = ArrayAlg.minmax (String[]::<span class="keyword">new</span>，<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</span><br><span class="line"><span class="comment">//利用反射构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt;T[] minmax(T... a) </span><br><span class="line">&#123; </span><br><span class="line">    T[] mm = (T[]) Array.newlnstance(a.getClass().getComponentType(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//toArray方法</span></span><br><span class="line">Object[] toArray()</span><br><span class="line">T[] toArray(T[] result) <span class="comment">//如果数组足够大， 就使用这个数组。 否则， 用 result 的成分类型构造一个足够大的新数组。</span></span><br></pre></td></tr></table></figure>

<h2 id="7-泛型类的静态上下文中类型变量无效"><a href="#7-泛型类的静态上下文中类型变量无效" class="headerlink" title="7. 泛型类的静态上下文中类型变量无效"></a>7. 泛型类的静态上下文中类型变量无效</h2><p>不能在静态域或方法中引用类型变量。因为由于类型擦除静态域的特定功能也会消失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance; <span class="comment">// Error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span> <span class="comment">// Error</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleinstance == <span class="keyword">null</span>) </span><br><span class="line">            construct <span class="keyword">new</span> instance of T</span><br><span class="line">        <span class="keyword">return</span> singlelnstance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-不能抛出或捕获泛型类的实例"><a href="#8-不能抛出或捕获泛型类的实例" class="headerlink" title="8. 不能抛出或捕获泛型类的实例"></a>8. 不能抛出或捕获泛型类的实例</h2><ol>
<li>既不能抛出也不能捕获泛型类对象。</li>
<li>泛型类扩展 Throwable 是不合法的。</li>
<li>catch 子句中不能使用类型变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error 不能扩展Throwable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* . . . */</span> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//Error 不能编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (T e) <span class="comment">// Error 不能捕获类型变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        Logger,global.info(...) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在异常规范中使用类型变量是允许的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T <span class="comment">// OK</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> work</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable realCause) </span><br><span class="line">    &#123; </span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-可以消除对受查异常的检查"><a href="#9-可以消除对受查异常的检查" class="headerlink" title="9. 可以消除对受查异常的检查"></a>9. 可以消除对受查异常的检查</h2><ol>
<li>泛型可以消除java异常处理中必须为所有受查异常提供一个处理器的限制，可利用注解<code>@SupressWarnings(&quot;unchecked&quot;)</code>来实现。</li>
<li>通过使用泛型类、擦除和 <code>@SuppressWarnings</code> 注解， 就能消除 Java 类型系统的部分基本限制。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">toThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   <span class="comment">//run方法不会介意受查异常Exception</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    body();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable t) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//以下代码会把所有异常都转换为编译器所认为的非受查异常。</span></span><br><span class="line">                    Block.&lt;RuntimeException&gt;throwAs(t); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> (T) e; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Block()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileC<span class="string">'ququx") , "UTF-8");</span></span><br><span class="line"><span class="string">                while (in.hasNext())</span></span><br><span class="line"><span class="string">                System.out.println(in.next()); </span></span><br><span class="line"><span class="string">            &#125; </span></span><br><span class="line"><span class="string">        &#125; </span></span><br><span class="line"><span class="string">        .toThread().start(); </span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-注意擦除后的冲突"><a href="#10-注意擦除后的冲突" class="headerlink" title="10. 注意擦除后的冲突"></a>10. 注意擦除后的冲突</h2><ol>
<li>泛型类在擦除后可能会与Object类中的方法产生冲突，解决方法是重新命名引发错误的方法。</li>
<li>要想支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑Pair&lt;String&gt;，它有两个equals方法，这两个方法在方法擦除后会产生冲突</span></span><br><span class="line"><span class="comment">//解决方法是重新命名equals</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span> <span class="comment">// 定义在Pair&lt;T&gt;中，擦除后变为boolean equals(Object)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span> <span class="comment">// 继承自Object</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Error，因为Manager 会实现 Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt;, 这是同一接口的不同参数化。</span></span></span><br><span class="line"><span class="function"><span class="comment">//实现了 C0mpamble&lt;X&gt; 的类可以获得一个桥方法，对于不同类型的 X 不能有两个这样的方法。</span></span></span><br><span class="line"><span class="function">class Employee implements Comparable&lt;Employee&gt; </span>&#123; . . . &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Manager</span>&gt; </span>&#123; . . . &#125; <span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123; <span class="keyword">return</span> compareTo((X) other); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、泛型类型的继承规则"><a href="#六、泛型类型的继承规则" class="headerlink" title="六、泛型类型的继承规则"></a>六、泛型类型的继承规则</h1><ol>
<li>处于类型安全的考虑，Java规定无论 S 与 T 有什么联系，通常，Pair<S> 与 Pair<T>没有什么联系。</li>
<li>泛型类可以扩展或实现其他的泛型类。如ArrayList<T> 类实现 List<T> 接口。这意味着， 一个 ArrayList<Manager> 可以被转换为一个 List<Manager>。但是，一个 ArrayList<Manager> 不是一个ArrayList<Employee> 或 List<Employee>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Manager&gt; managerBuddies = <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair&lt;Employee&gt; employeeBuddies = managerBuddies; <span class="comment">// 非法</span></span><br><span class="line">employeeBuddies.setFirst(lowlyEmployee);</span><br><span class="line"></span><br><span class="line">Pair&lt;Manager&gt; managerBuddies = <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair rawBuddies = managerBuddies; <span class="comment">// OK</span></span><br><span class="line">rawBuddies.setFirst(<span class="keyword">new</span> File(<span class="string">". . ."</span>)); <span class="comment">// 只会出现编译警告</span></span><br></pre></td></tr></table></figure>

<h1 id="七、通配符类型"><a href="#七、通配符类型" class="headerlink" title="七、通配符类型"></a>七、通配符类型</h1><h2 id="1-通配符的概念"><a href="#1-通配符的概念" class="headerlink" title="1. 通配符的概念"></a>1. 通配符的概念</h2><ol>
<li>通配符类型中，允许类型参数变化。</li>
<li>通配符限定与类型变量限定十分类似，而且还可以指定一个超类型限定。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示任何泛型 Pair 类型， 它的类型参数是 Employee 的子类</span></span><br><span class="line"><span class="comment">//类型 Pair&lt;Manager&gt; 和Pair&lt;Manager&gt; 是 Pair&lt;? extends Employee&gt; 的子类型</span></span><br><span class="line"><span class="comment">//但是类型 Pair&lt;Manager&gt; 和Pair&lt;Manager&gt;之间没有任何关系</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span>   <span class="comment">//子类型限定通配符</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将 getFirst 的返回值赋给一个 Employee 的引用完全合法。</span></span></span><br><span class="line"><span class="function"><span class="comment">//但不能调用setFirst方法</span></span></span><br><span class="line"><span class="function">Pair&lt;Manager&gt; managerBuddies </span>= <span class="keyword">new</span> Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair&lt;? extends Employee&gt; wildcardBuddies = managerBuddies; <span class="comment">// OK</span></span><br><span class="line">wildcardBuddies.setFirst(lowlyEmployee); <span class="comment">// 会产生编译错误</span></span><br><span class="line"></span><br><span class="line">? <span class="function">extends Employee <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? extends Employee)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-通配符的超类型限定"><a href="#2-通配符的超类型限定" class="headerlink" title="2. 通配符的超类型限定"></a>2. 通配符的超类型限定</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">带有超类型限定的通配符可以向泛型对象写入（set方法），带有子类型限定的通配符可以从泛型对象读取（get方法）。</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? <span class="keyword">super</span> Manager)</span> </span></span><br><span class="line"><span class="function">? <span class="keyword">super</span> Manager <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minmaxBonus</span><span class="params">(Manager[] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Manager rain = a[<span class="number">0</span>];</span><br><span class="line">    Manager max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i *<span class="number">1</span>; i &lt; a.length; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (min.getBonus() &gt; a[i].getBonus()) rain = a[i];</span><br><span class="line">        <span class="keyword">if</span> (max.getBonus() &lt; a[i].getBonus()) max = a[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    result.setFirst(min);</span><br><span class="line">    result.setSecond(max); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Conparable&lt;? <span class="keyword">super</span> T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicated&lt;? <span class="keyword">super</span> E&gt; filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArrayList&lt;Employee&gt; staff = . .;</span><br><span class="line">    Predicate&lt;Object&gt; oddHashCode = obj -&gt; obj.hashCode() %<span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">    staff.removelf(oddHashCode):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-无限定通配符"><a href="#3-无限定通配符" class="headerlink" title="3. 无限定通配符"></a>3. 无限定通配符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getFirst 的返回值只能赋给一个 Object。setFirst 方法不能被调用， 甚至不能用 Object 调 用。</span></span><br><span class="line"></span><br><span class="line">? getFirst()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//可以调用 setFirst(null)。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() = <span class="keyword">null</span> || p.getSecond() =<span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过将 hasNulls 转换成泛型方法，可以避免使用通配符类型,</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-通配符捕获"><a href="#4-通配符捕获" class="headerlink" title="4. 通配符捕获"></a>4. 通配符捕获</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通配符不是类型变量，因此，不能在编写代码中使用“？”作为一种类型。</span></span><br><span class="line">? t = p.getFirst(); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符捕获</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    T t = p.getFirst(); </span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(t); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123; swapHelper(p); &#125;  <span class="comment">//参数T 捕获通配符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxminBonus</span><span class="params">(Manager ] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    minmaxBonus(a, result);</span><br><span class="line">    PairAlg.swap(result); <span class="comment">// OK swapHelper captures wildcard type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、反射和泛型"><a href="#八、反射和泛型" class="headerlink" title="八、反射和泛型"></a>八、反射和泛型</h1><h2 id="1-泛型-Class-类"><a href="#1-泛型-Class-类" class="headerlink" title="1. 泛型 Class 类"></a>1. 泛型 Class 类</h2><p>//反射不能获得泛型类型参数的太多信息，因为它们会被擦除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span> <span class="comment">//返回无参数构造器构造的一个新实例。</span></span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span> <span class="comment">//如果 obj 为 null 或有可能转换成类型 T， 则 返 回 obj ; 否 则 拋 出 BadCastException异常。</span></span></span><br><span class="line"><span class="function">T[ ] <span class="title">getEnumConstants</span><span class="params">( )</span> <span class="comment">//如果 T 是枚举类型， 则返回所有值组成的数组，否则返回 null。</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperclass</span><span class="params">( )</span> <span class="comment">//返回这个类的超类。如果 T 不是一个类或 Object 类， 则返回 null。</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>  <span class="comment">//获得公有的构造器， 或带有给定参数类型的构造器。</span></span></span><br><span class="line"><span class="function">T <span class="title">newlnstance</span><span class="params">(<span class="number">0</span>bject... parameters)</span> <span class="comment">//返回用指定参数构造的新实例。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-使用-Class-参数进行类型匹配"><a href="#2-使用-Class-参数进行类型匹配" class="headerlink" title="2. 使用 Class 参数进行类型匹配"></a>2. 使用 Class<T> 参数进行类型匹配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Employee.class 是类型 Class&lt;Employee&gt; 的一个对象。makePair 方法的类型参数 T 同 Employee匹配， 并且编译器可以推断出这个方法将返回一个 Pair&lt;Employee&gt;。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pai r&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Pairo(c.newInstance(), c.newInstance()); </span><br><span class="line">&#125;</span><br><span class="line">makePair(Employee<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="3-虚拟机中的泛型类型信息"><a href="#3-虚拟机中的泛型类型信息" class="headerlink" title="3. 虚拟机中的泛型类型信息"></a>3. 虚拟机中的泛型类型信息</h2><p>可以使用反射 API 来确定： </p>
<ul>
<li>这个泛型方法有一个叫做 T 的类型参数。<br>这个类型参数有一个子类型限定，其自身又是一个泛型类型。<br>这个限定类型有一个通配符参数。<br>这个通配符参数有一个超类型限定。<br>这个泛型方法有一个泛型数组参数。</li>
</ul>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2020/05/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/" class="pre">Java中的集合</a><a href="/2020/05/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" class="next">Java中的异常、断言和日志</a></div><div id="comments"><div id="SOHUCS" sid="2020/05/25/Java基础知识/Java中的泛型程序设计/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、定义简单泛型类"><span class="toc-text">一、定义简单泛型类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、泛型方法"><span class="toc-text">二、泛型方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、类型变量的限定"><span class="toc-text">三、类型变量的限定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、泛型代码和虚拟机"><span class="toc-text">四、泛型代码和虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-类型擦除"><span class="toc-text">1. 类型擦除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-翻译泛型表达式"><span class="toc-text">2. 翻译泛型表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-翻译泛型方法"><span class="toc-text">3. 翻译泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-调用遗留代码"><span class="toc-text">4. 调用遗留代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、约束与局限性"><span class="toc-text">五、约束与局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-不能用基本类型实例化类型参数"><span class="toc-text">1. 不能用基本类型实例化类型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-运行时类型查询只适用于原始类型"><span class="toc-text">2. 运行时类型查询只适用于原始类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-不能创建参数化类型的数组"><span class="toc-text">3. 不能创建参数化类型的数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Varargs-警告"><span class="toc-text">4. Varargs 警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-不能实例化类型变量"><span class="toc-text">5. 不能实例化类型变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-不能构造泛型数组"><span class="toc-text">6. 不能构造泛型数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-泛型类的静态上下文中类型变量无效"><span class="toc-text">7. 泛型类的静态上下文中类型变量无效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-不能抛出或捕获泛型类的实例"><span class="toc-text">8. 不能抛出或捕获泛型类的实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-可以消除对受查异常的检查"><span class="toc-text">9. 可以消除对受查异常的检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-注意擦除后的冲突"><span class="toc-text">10. 注意擦除后的冲突</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、泛型类型的继承规则"><span class="toc-text">六、泛型类型的继承规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、通配符类型"><span class="toc-text">七、通配符类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-通配符的概念"><span class="toc-text">1. 通配符的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-通配符的超类型限定"><span class="toc-text">2. 通配符的超类型限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-无限定通配符"><span class="toc-text">3. 无限定通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-通配符捕获"><span class="toc-text">4. 通配符捕获</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、反射和泛型"><span class="toc-text">八、反射和泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-泛型-Class-类"><span class="toc-text">1. 泛型 Class 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-使用-Class-参数进行类型匹配"><span class="toc-text">2. 使用 Class 参数进行类型匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-虚拟机中的泛型类型信息"><span class="toc-text">3. 虚拟机中的泛型类型信息</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/">Java中的集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">Java中的泛型程序设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/">Java中的异常、断言和日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/21/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/">Java中的接口、lambda 表达式与内部类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/">Codeup和PAT刷题记录——算法初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/">Java中的继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">Java中的对象与类</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Java基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/">Codeup和PAT刷题记录——入门模拟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">算法复杂度和黑盒测试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithms/">algorithms</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://docschina.org/" title="印象中文" target="_blank">印象中文</a><ul></ul><a href="https://kingdot.github.io/" title="木丁夕雨何" target="_blank">木丁夕雨何</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><span>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i> 次</i></span><span>|</span><span>Copyright &copy;<a href="/." rel="nofollow">桃子果汁.</a></span></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?281cc941ca205b4ebca856d71ae45a55";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytF5aDWy'; 
  var conf = 'prod_0650efe38e465b0e4820ce8d9c386815'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>